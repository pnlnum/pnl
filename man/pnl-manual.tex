
\documentclass[a4paper,11pt,twoside]{article}
\usepackage{a4wide}
\usepackage{t1enc,lmodern}
\usepackage{hyperref}
\usepackage{textcomp,color}
\usepackage{verbatim,moreverb,alltt}
\usepackage{makeidx}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage[strings]{underscore}
\usepackage{amsmath,amsfonts}
\usepackage{listings}
\lstset{language=C, basicstyle=\small\ttfamily, breaklines=true}

\synctex=1

%% --------------------------------------------
\hbadness=10000
\emergencystretch=\hsize
\tolerance=9999
\parindent=0pt
%% --------------------------------------------

\newcommand{\R}{{\mathbb R}}
\newcommand{\C}{{\mathbb C}}
\newcommand{\N}{{\mathbb N}}
\newcommand{\ptr}{\textasteriskcentered}
\newcommand{\cD}{{\mathcal D}}
\newcommand{\ind}[1]{1_{\left\{#1\right\}}}

%%\renewcommand{\exp}[1]{\operatorname{e}^{ #1 } }
\newcommand{\cotan}{\operatorname{cotan}}
\newcommand{\cotanh}{\operatorname{cotanh}}
\newcommand{\expp}[1]{\operatorname{e}^{ #1 } }
\newcommand{\paren}[1]{\left( #1 \right)}
\newcommand{\recaco}[1]{\left [ #1 \right ]}
\newcommand{\crochet}[1]{\left \langle #1 \right \rangle}
\newcommand{\acolade}[1]{\left\{ #1 \right\}}
\newcommand{\real}[1]{\operatorname{Re}(#1)}

\makeatletter

% For pdflatex generation
\ifx\HCode\undefined%

\def\var#1{{\tt #1}}
% Describing functions
\newcommand{\describefunNoStar}[3]{%
  \index{#2}\label{#2} {#1~{\bf #2}~(#3)}}
\newcommand{\describefunStar}[3]{%
  {#1~{\bf #2}~(#3)}}
\newcommand{\describefun}{\@ifstar
  \describefunStar%
  \describefunNoStar%
}

% Describing struct
\newcommand{\describestruct}[1]{%
  % \expandafter\newcommand\csname #1\endcsname{\refstruct{#1}\space}%
  \index{Structs!#1}\label{#1}}

% Describing variables
\newcommand{\describevar}[2]{{#1~{\bf #2}}}

\newcommand{\describemacro}[2]{%
  \index{#1}\label{#1} {{\bf #1}~(#2)}}

\newcommand{\constentry}[2]{%
  \index{#1}\label{#1}{\bf #1} &&  #2 \\ }

\definecolor{Red}{rgb}{1,0,0}
\definecolor{Blue}{rgb}{0,0,1}
\def\refstruct#1{\hyperref[#1]{\color{Red} #1}}
\def\reffun#1{\hyperref[#1]{#1}}
\def\refmacro{\reffun}
\newenvironment{describeconst}{%
  \noindent\begin{tabular}{lp{1cm}l}}{\end{tabular}}
\def\shortdescribe{\unskip\vskip1ex{\color{Blue} Description~}}
\def\sshortdescribe{\unskip\newline\hskip1em {\color{Blue} Description~}}
\def\parameters{\unskip\newline\hskip1em {\color{Blue} Parameters~}}
\def\example{\unskip\newline\hskip1em {\color{Blue} Example~}}

% Html related stuff
\else%

\def\var#1{\HCode{<span class='var'>}#1\HCode{</span>}}
% Describing functions
\newcommand{\describefunStar}[3]{%
{\HCode{<span class='ret'>}#1\HCode{</span>}~{\bf \HCode{<span class='fun'>}#2\HCode{</span>}}~(\HCode{<span class='args'>}#3\HCode{</span>})}}
\newcommand{\describefunNoStar}[3]{%
\index{#2}\label{#2} {\HCode{<span class='ret'>}#1\HCode{</span>}~{\bf \HCode{<span class='fun'>}#2\HCode{</span>}}~(\HCode{<span class='args'>}#3\HCode{</span>})}}
\newcommand{\describefun}{\@ifstar
  \describefunStar%
  \describefunNoStar%
}

% Describing variables
\newcommand{\describevar}[2]{{#1~{\bf #2}}}

\newcommand{\describemacro}[2]{%
  \index{#1}\label{#1} {{\bf #1}~(#2)}}

\newcommand{\constentry}[2]{%
  \index{#1}\label{#1}\HCode{<span class='struct'>}#1\HCode{</span>} && #2 \\ }

% Describing struct
\newcommand{\describestruct}[1]{%
  % \expandafter\newcommand\csname #1\endcsname{\refstruct{#1}\space}%
  \index{Structs!#1}\label{#1}}

\def\refstruct#1{\hyperref[#1]{\HCode{<span class='struct'>}#1\HCode{</span>}}}
\def\reffun#1{\hyperref[#1]{#1}}
\def\refmacro{\reffun}
\newenvironment{describeconst}{%
  \noindent\begin{tabular}{lp{1cm}l}}{\end{tabular}}
\def\shortdescribe{\unskip\vskip1ex{\HCode{<span class='description'>}Description~\HCode{</span>}}}
\def\sshortdescribe{\unskip\newline\hskip1em \HCode{<span class='description'>}Description~\HCode{</span>}}
\def\parameters{\unskip\newline\hskip1em \HCode{<span class='description'>}Parameters~\HCode{</span>}}
\def\example{\unskip\newline\hskip1em \HCode{<span class='description'>}Example~\HCode{</span>}}

\fi
\makeatother

% Macro for Pnl types
\def\PnlSpMat{\refstruct{PnlSpMat}\space}
\def\PnlMat{\refstruct{PnlMat}\space}
\def\PnlMatInt{\refstruct{PnlMatInt}\space}
\def\PnlMatComplex{\refstruct{PnlMatComplex}\space}
\def\PnlHmat{\refstruct{PnlHmat}\space}
\def\PnlArray{\refstruct{PnlArray}\space}
\def\PnlBandMat{\refstruct{PnlBandMat}\space}
\def\PnlBasis{\refstruct{PnlBasis}\space}
\def\PnlCell{\refstruct{PnlCell}\space}
\def\PnlCmplxFunc{\refstruct{PnlCmplxFunc}\space}
\def\PnlHmat{\refstruct{PnlHmat}\space}
\def\PnlList{\refstruct{PnlList}\space}
\def\PnlMat{\refstruct{PnlMat}\space}
\def\PnlMatComplex{\refstruct{PnlMatComplex}\space}
\def\PnlMatInt{\refstruct{PnlMatInt}\space}
\def\PnlMorseMat{\refstruct{PnlMorseMat}\space}
\def\PnlObject{\refstruct{PnlObject}\space}
\def\PnlPermutation{\refstruct{PnlPermutation}\space}
\def\PnlRng{\refstruct{PnlRng}\space}
\def\PnlSpMat{\refstruct{PnlSpMat}\space}
\def\PnlSparseFactorization{\refstruct{PnlSparseFactorization}\space}
\def\PnlSparseMat{\refstruct{PnlSparseMat}\space}
\def\PnlTridiagMat{\refstruct{PnlTridiagMat}\space}
\def\PnlTridiagMatLU{\refstruct{PnlTridiagMatLU}\space}
\def\PnlVect{\refstruct{PnlVect}\space}
\def\PnlVectCompact{\refstruct{PnlVectCompact}\space}
\def\PnlVectComplex{\refstruct{PnlVectComplex}\space}
\def\PnlVectInt{\refstruct{PnlVectInt}\space}
\def\PnlRnFuncR{\refstruct{PnlRnFuncR}\space}
\def\dcomplex{\refstruct{dcomplex}\space}

\setcounter{tocdepth}{2}
\title{Pnl Manual}
\date{\today}
\author{}

\makeindex
\begin{document}
\maketitle
\tableofcontents

\section{Introduction}
\subsection{What is Pnl}

Pnl is a scientific library written in C and distributed under
the Gnu Lesser General Public Licence (LGPL). This manual is divided into four
parts.
\begin{itemize}
\item Mathematical functions: complex numbers, special functions, standard
  financial functions for the Black \& Scholes model.
\item Linear algebra : vectors, matrices (dense and sparse), hypermatrices, tridiagonal matrices,
  band matrices and the corresponding routines to manipulate them and solve linear systems.
\item Probabilistic functions: random number generators and  cumulative
  distribution functions.
\item Deterministic toolbox : FFT, Laplace inversion, numerical integration, zero searching,
  multivariate polynomial regression, $\dots$
\end{itemize}

\subsection{A few helpful conventions}

\begin{itemize}
  \item All header file names are prefixed by \verb!pnl_! and are surrounded by
    the preprocessor conditionals
\begin{lstlisting}
#ifndef _PNL_MATRIX_H
#define _PNL_MATRIX_H

...

#endif /* _PNL_MATRIX_H
\end{lstlisting}
All the header files are protected by an \verb!extern "C"! declaration for
possible use with a C++ compiler. The header files must be include using
\begin{lstlisting}
#include "pnl/pnl_xxx.h"
\end{lstlisting}

  \item All function names are prefixed by \verb!pnl_! except those implementing
    complex number arithmetic which are named following the \textit{C99}
    complex library but using a capitalised first letter \verb!C!. \\
    For example, the addition of two complex numbers is performed by the
    function \verb!Cadd!.

  \item Function containing \verb!_create! in their names always return a
    pointer to an object created by one or several calls to dynamic
    allocation. Once these objects are not used, they must be freed by calling
    the same function but ending in \verb!_free!.
    A function \verb!pnl_foo_create_yyy! returns a \verb!PnlFoo *! object (note
    the ``\ptr'') and a function \verb!pnl_foo_bar_create_yyy! returns a
    \verb!PnlFooBar *! object (note the ``\ptr'').
    These objects must be freed by calling respectively \verb!pnl_foo_free! or
    \verb!pnl_foo_bar_free!.

  \item Functions ending in \verb!_clone! take two arguments \verb!src! and
    \verb!dest! and modify \verb!dest! to make it identical to \verb!src!, ie.
    they have the same size and data. Note that no new object is allocated,
    \verb!dest! must exist before calling this function.

  \item Functions ending in \verb!_copy! create a new object identical (ie. with
    the same size and content) as its argument but independent (ie. modifying
    one of them does not alter the other). Calling \verb!A = pnl_xxx_copy(B)!
    is equivalent to first calling \verb!A = pnl_xxx_new()! function and then
    \verb!pnl_xxx_clone(A, B)!.
    
  \item Every object must implement a \verb!pnl_xxx_new! function which returns
    a pointer to an empty object with all its elements properly set to $0$. This
    means that the objects returned by the \verb!pnl_xxx_new! functions can be
    used as output arguments for functions ending in \verb!_inplace! for
    instance. They are suitable for being resized. 

  \item Functions containing \verb!_wrap_! in their names always return an
    object, not a pointer to an object, and do not make any use of dynamic
    allocation. The returned object must not be freed. 
    For instance, a function \verb!pnl_foo_wrap_xxx! returns an object
    \verb!PnlFoo! and a function \verb!pnl_foo_bar_wrap_xxx! returns an object
    \verb!PnlFooBar! 
    \begin{lstlisting}
    PnlVectComplex *v1;
    PnlVectComplex v2;
    v1 = pnl_vect_complex_create_from_scalar (5, Complex(0., 1.));
    v2 = pnl_vect_complex_wrap_subvect (v1, 1, 2);

    ...

    pnl_vect_complex_free (&v1);
    \end{lstlisting}
    The vector \verb!v1! is of size 5 and contains the pure imaginary number
    $i$. The vector \verb!v2! only provides a view to \verb!v1(1:1+2)!, which
    means that modifying \verb!v2! will also modify \verb!v1! and vice-versa
    because \verb!v1! shares part of its data with \verb!v2!. Note that only
    \verb!v1! must be freed and {\bf not} \verb!v2!.
  
  \item Functions ending in \verb!_init! do not create any object but only
    perform some internal initialisation.
  
  \item Hypermatrices, matrices and vectors are stored using a flat block of
    memory obtained by concatenating the matrix rows and C-style
    pointer-to-pointer arrays. Matrices are stored in row-major order, which
    means that the column index moves continuously.
    Note that this convention is not \textit{Blas \& Lapack} compliant since
    Fortran expects 2-dimensional arrays to be stored in a column-major order.

  \item Type names always begin with \verb!Pnl!, they do not contain underscores
    but instead we use capital letters to separate units in type names. \\
    Examples : \verb!PnlMat!, \verb!PnlMatComplex!.

  \item Object and function names are intimately linked : an object
    \verb!PnlFoo! is manipulated by functions starting in \verb!pnl_foo!, an
    object \verb!PnlFooBar! is manipulated by functions starting in
    \verb!pnl_foo_bar!. In table~\ref{pnltypes}, we summarise the types and their
    corresponding prefixes.

    \begin{figure}[h!]
      \centering\begin{tabular}{|l|l|}
      \hline
      Pnl types & Pnl prefix \\
      \hline
      PnlVect & pnl_vect \\
      PnlVectComplex & pnl_vect_complex \\
      PnlVectInt & pnl_vect_int \\
       &\\
      PnlMat & pnl_mat \\
      PnlMatComplex & pnl_mat_complex \\
      PnlMatInt & pnl_mat_int \\
      & \\
      PnlSpMat & pnl_sp_mat \\
      PnlSpMatComplex & pnl_sp_mat_complex \\
      PnlSpMatInt & pnl_sp_mat_int \\
      & \\
      PnlHmat & pnl_hmat \\
      PnlHmatComplex & pnl_hmat_complex \\
      PnlHmatInt & pnl_hmat_int \\
      & \\
      PnlTridiagMat & pnl_tridiag_mat \\
      PnlBandMat & pnl_band_mat \\
      & \\
      PnlList & pnl_list \\
      & \\
      PnlBasis & pnl_basis \\
      & \\
      PnlCgSolver & pnl_cg_solver \\
      PnlBicgSolver & pnl_bicg_solver \\
      PnlGmresSolver & pnl_gmres_solver \\
      \hline
    \end{tabular}
    \caption{Pnl types}
    \label{pnltypes}
  \end{figure}

  \item All macro names begin with \verb!PNL_! and are capitalised.

  \item Differences between \textbf{copy} and \textbf{clone} methods.
    The \verb!copy! methods take a single argument and return a pointer to an object
    of the same type which is an independent copy of its argument. 
    Example:
    \begin{lstlisting}
    PnlVect *v1, *v2;
    v1 = pnl_vect_create_from_scalar (5, 2.5);
    v2 = pnl_vect_copy (v1);
    \end{lstlisting}
    \verb!v1! and \verb!v2! are two vectors of size 5 with all their elements
    equal to 2.5. Note that \verb!v2! {\bf must not} have been created by a call
    to \verb!pnl_vect_create_xxx! because otherwise it will cause a memory leak.
    \verb!v1! and \verb!v2! are independent in the sense that a modification to
    one of them does not affect the other.

    The \verb!clone! methods take two arguments and fill the first one with the
    second one. 
    Example:
    \begin{lstlisting}
    PnlVect *v1, *v2;
    v1 = pnl_vect_create_from_scalar (5, 2.5);
    v2 = pnl_vect_new ();
    pnl_vect_clone (v2, v1);
    \end{lstlisting}
    \verb!v1! and \verb!v2! are two vectors of size 5 with all their elements
    equal to 2.5. Note that \verb!v2! {\bf must} have been created by a call to
    \verb!pnl_vect_new! because otherwise the function
    \verb!pnl_vect_clone!  will crash.  \verb!v1! and \verb!v2! are independent
    in the sense that a modification to one of them does not modify the other.


  \item All objects are measured using integers \verb!int! and not
    \verb!size_t!. Hence, iterations over vectors, matrices, \dots should use an
    index of type \verb!int!.

  \item In fonctions ending in \verb!inplace!, the output parameter must be different
    from any of the input parameters.
\end{itemize}


\subsection{Using Pnl}

In this section, we assume that the library is installed in the directory
\verb!$HOME/pnl-xxx!.

Once installed, the library can be found in the
\verb!$HOME/pnl-xxx/lib!  directory and the header files in the
\verb!$HOME/pnl-xxx/include! directory. 

\subsubsection{Compiling and Linking}

The header files of the library are installed in a root \verb!pnl! directory and
should always be included with this \verb!pnl/! prefix. So, for instance to use
random number generators you should include 
\begin{lstlisting}
#include <pnl/pnl_random.h>
\end{lstlisting}

\paragraph{Compiling and linking by hand.}

If \verb!gcc! or \verb!llvm! is used, you should pass the following options
\begin{itemize}
\item \verb!-I$HOME/pnl-xxx/include! for compiling
\item \verb!-L$HOME/pnl-xxx/lib -lpnl! for linking
\end{itemize}
This does not work straight away on all OS especially if the library is not
installed in a standard directory namely \verb+/usr/+ or \verb+/usr/local/+ for
which you need a privileged writing access.
On some systems, you may need to add to the linker flags the dependencies of the
library, which can become very tedious. Therefore, we provide a second automatic
mechanism which takes care of the dependencies on its own.

\paragraph{Compiling and linking using an automatic Makefile.}

This mechanism only works under Unix (it has been tested under various Linux
distributions and Mac OS X).

First, you need to create a new directory wherever you want, put in all your
code and create a Makefile as below

To define your target just add the executable name, say \verb!my-exec!, to the
\verb!BINS!  list and create an entry \verb!my_exec_SRC! carrying the list
of source files needed to create your executable.  Note that if dashes '-' may
appear in an executable name, the name of the associated variable holding the
list of source files is obtained by replacing dashes with underscores '_' and
adding the _SRC suffix.

Assume you want to create two binaries : \verb+my-exec+ based on mixed C and C++
code (\verb+file1.c+ and \verb+file2.cpp+) and \verb+mybinary+ based on
\verb+poo1.cxx+ and \verb+poo2.cpp+. You can use the following Makefile.
\begin{lstlisting}
## Flags passed to the linker
LDFLAGS=

## Flags passed to the compiler
CFLAGS=

## list of executables to create
BINS=my-exec mybinary

my_exec_SRC=file1.c file2.cpp
# optional flags for compiling and linking
my_exec_CFLAGS=
my_exec_CXXFLAGS=
my_exec_LDFLAGS=

mybinary_SRC=poo1.cxx poo2.cpp
# optional flags for compiling and linking
mybinary_CFLAGS=
mybinary_CXXFLAGS=
mybinary_LDFLAGS=


## This line must be the last one
include full_path_to_pnl_build/CMakeuser.incl
\end{lstlisting}
Let us comment a little the different variables
\begin{itemize}
  \item \verb+CFLAGS+: global flags used for creating objects based on C code
  \item \verb+CXXFLAGS+: global flags used for creating objects based on C++ code
  \item \verb+LDFLAGS+: gobal linker flags.
  \item \verb+binaryname_CFLAGS+: flags used when creating the objects based on
    C code and required by \verb+binaryname+
  \item \verb+binaryname_CXXFLAGS+: flags used when creating the objects based on
    C++ code and required by \verb+binaryname+
  \item \verb+binaryname_LDFLAGS+: flags used when linking objects for creating
    \verb+binaryname+
\end{itemize}
An example of such a Makefile can be found in \verb+pnl-xxx/perso+.

\textbf{Warning:} if a file appears in the source list of several binairies, the
flags used to compile this file are determined by the ones of the first binary
involving this file. In the following example \verb+main.cpp+ will always be compiled
with the flag \verb+-O3+ even for generating \verb+bin2+
\begin{lstlisting}
BINS=bin1 bin2

bin1_SRC=main.cpp poo1.c
my_exec_CXXFLAGS=-O3

bin2_SRC=main.cpp poo2.c
mybinary_CXXFLAGS=-g -O0

## This line must be the last one
include full_path_to_pnl_build/CMakeuser.incl
\end{lstlisting}

\paragraph{Compiling and linking using CMake.}

If you already use CMake for your new project, just add the following to your toplevel
\verb!CMakeLists.txt!
\begin{lstlisting}
find_package(Pnl REQUIRED)
set(LIBS ${LIBS} ${PNL_LIBRARIES})
include_directories(${PNL_INCLUDE_DIRS})
# Deactivate PNL debugging stuff on Release builds
if(${CMAKE_BUILD_TYPE} STREQUAL "Release")
    add_definitions(-DPNL_RANGE_CHECK_OFF)
endif()
\end{lstlisting}
Then, call cmake with the following extra flag 
\begin{lstlisting}
-DCMAKE_PREFIX_PATH=path/to/build-dir
\end{lstlisting}
or add the variable \verb!CMAKE_BUILD_TYPE! to the GUI. \\

Just in case, we give an example of a complete although elementary \verb!CMakeLists.txt!
\verbatiminput{../perso/CMakeLists-example.txt}

\subsubsection{Inline Functions and getters}
\label{sec:inline}

If it is supported by your compiler, getter and setter functions are declared
as inline functions. This is automatically detected when running CMake. By
default, setter and getter functions check that the required access is valid,
basically it boils down to checking whether the index of the access is within an
acceptable range. These extra tests can become very expensive when getter and
setter functions are intensively called.

Thus,  it is possible to alter this default behaviour by defining the macro
\texttt{PNL_RANGE_CHECK_OFF}. This macro is automatically defined when the
library is compiled in Release mode, ie. with \verb!-DCMAKE_BUILD_TYPE=Release!
passed to CMake.


\input{types.tex}
\input{mathematical_functions.tex}
\input{linear_algebra.tex}


\input{cdf.tex}
\input{rng.tex}

\input{bases.tex}
\input{integ.tex}
\input{fft.tex}
\input{laplace.tex}
\input{ode.tex}
\input{optim.tex}
\input{roots.tex}
\input{specfun.tex}

\input{some_bindings.tex}

\input{finance.tex}

\clearpage
\addcontentsline{toc}{section}{Index}
\printindex


\end{document}
