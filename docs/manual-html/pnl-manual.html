<?xml version="1.0" encoding="utf-8" ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  
<!--http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd-->  
<html xmlns="http://www.w3.org/1999/xhtml"  
> 
<head><title>Pnl Manual</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="originator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<!-- xhtml,uni-html4,2,subsection+,next,html --> 
<meta name="src" content="pnl-manual.tex" /> 
<link rel="stylesheet" type="text/css" href="pnl-manual.css" /> 
</head><body 
>
<div class="maketitle">
                                                                                    

                                                                                    
                                                                                    

                                                                                    

<h2 class="titleHead">Pnl Manual</h2>
<div class="author" ></div><br />
<div class="date" ><span 
class="ec-lmr-12">January 11, 2023</span></div>
</div>
<h3 class="likesectionHead"><a 
 id="x1-1000"></a>Contents</h3>
<div class="tableofcontents">
&#x00A0;<span class="likesectionToc" ><a 
href="#x1-1000" id="QQ2-1-1">Contents</a></span>
<br />&#x00A0;<span class="sectionToc" >1 <a 
href="#x1-20001" id="QQ2-1-2">Introduction</a></span>
<br />&#x00A0;<span class="sectionToc" >2 <a 
href="#x1-110002" id="QQ2-1-12">Objects</a></span>
<br />&#x00A0;<span class="sectionToc" >3 <a 
href="#x1-150003" id="QQ2-1-17">Mathematical framework</a></span>
<br />&#x00A0;<span class="sectionToc" >4 <a 
href="#x1-270004" id="QQ2-1-29">Linear Algebra</a></span>
<br />&#x00A0;<span class="sectionToc" >5 <a 
href="#x1-1000005" id="QQ2-1-102">Cumulative distribution Functions</a></span>
<br />&#x00A0;<span class="sectionToc" >6 <a 
href="#x1-1010006" id="QQ2-1-103">Random Number Generators</a></span>
<br />&#x00A0;<span class="sectionToc" >7 <a 
href="#x1-1040007" id="QQ2-1-107">Function bases and regression</a></span>
<br />&#x00A0;<span class="sectionToc" >8 <a 
href="#x1-1090008" id="QQ2-1-113">Numerical integration</a></span>
<br />&#x00A0;<span class="sectionToc" >9 <a 
href="#x1-1120009" id="QQ2-1-116">Fast Fourier Transform</a></span>
<br />&#x00A0;<span class="sectionToc" >10 <a 
href="#x1-11800010" id="QQ2-1-122">Inverse Laplace Transform</a></span>
<br />&#x00A0;<span class="sectionToc" >11 <a 
href="#x1-11900011" id="QQ2-1-123">Ordinary differential equations</a></span>
<br />&#x00A0;<span class="sectionToc" >12 <a 
href="#x1-12200012" id="QQ2-1-126">Optimization</a></span>
<br />&#x00A0;<span class="sectionToc" >13 <a 
href="#x1-12900013" id="QQ2-1-133">Root finding</a></span>
<br />&#x00A0;<span class="sectionToc" >14 <a 
href="#x1-13400014" id="QQ2-1-138">Special functions</a></span>
<br />&#x00A0;<span class="sectionToc" >15 <a 
href="#x1-14300015" id="QQ2-1-147">Some bindings</a></span>
<br />&#x00A0;<span class="sectionToc" >16 <a 
href="#x1-14800016" id="QQ2-1-152">Financial functions</a></span>
<br />&#x00A0;<span class="sectionToc" ><a 
href="#Q1-1-153">Index</a></span>
<br />&#x00A0;<span class="likesectionToc" ><a 
href="#x1-149000" id="QQ2-1-154">Index</a></span>
</div>
<!--l. 165--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-20001"></a>Introduction</h3>
                                                                                    

                                                                                    
<!--l. 166--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">1.1   </span> <a 
 id="x1-30001.1"></a>What is Pnl</h4>
<!--l. 168--><p class="noindent" >Pnl is a scientific library written in C and distributed under the Gnu Lesser General Public Licence
(LGPL). This manual is divided into four parts. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 172--><p class="noindent" >Mathematical  functions:  complex  numbers,  special  functions,  standard  financial
     functions for the Black &amp; Scholes model.
     </p></li>
     <li class="itemize">
     <!--l. 174--><p class="noindent" >Linear  algebra  :  vectors,  matrices  (dense  and  sparse),  hypermatrices,  tridiagonal
     matrices, band matrices and the corresponding routines to manipulate them and solve
     linear systems.
     </p></li>
     <li class="itemize">
     <!--l. 176--><p class="noindent" >Probabilistic  functions:  random  number  generators  and  cumulative  distribution
     functions.
     </p></li>
     <li class="itemize">
     <!--l. 178--><p class="noindent" >Deterministic toolbox : FFT, Laplace inversion, numerical integration, zero searching,
     multivariate polynomial regression, <span 
class="lmmi-10x-x-109">&#x2026;</span></p></li></ul>
<!--l. 182--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">1.2   </span> <a 
 id="x1-40001.2"></a>A few helpful conventions</h4>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 185--><p class="noindent" >All header file names are prefixed by <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_</span></span></span> and are surrounded by the preprocessor
     conditionals
                                                                                    

                                                                                    
</p>
     <pre class="verbatim" id="verbatim-1">
     #ifndef&#x00A0;_PNL_MATRIX_H
     #define&#x00A0;_PNL_MATRIX_H
     
     ...
     
     #endif&#x00A0;/*&#x00A0;_PNL_MATRIX_H
</pre>
     <!--l. 194--><p class="nopar" >All the header files are protected by an <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">extern</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;"C"</span></span></span> declaration for possible use with a C++
     compiler. The header files must be include using
                                                                                    

                                                                                    
</p>
     <pre class="verbatim" id="verbatim-2">
     #include&#x00A0;"pnl/pnl_xxx.h"
</pre>
     <!--l. 199--><p class="nopar" >
     </p></li>
     <li class="itemize">
     <!--l. 201--><p class="noindent" >All function names are prefixed by <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_</span></span></span> except those implementing complex number
     arithmetic which are named following the <span 
class="ec-lmri-10x-x-109">C99 </span>complex library but using a capitalised first
     letter <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">C</span></span></span>. <br 
class="newline" />For example, the addition of two complex numbers is performed by the function
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">Cadd</span></span></span>.
     </p></li>
     <li class="itemize">
     <!--l. 207--><p class="noindent" >Function containing <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">_create</span></span></span> in their names always return a pointer to an object created by
     one or several calls to dynamic allocation. Once these objects are not used, they must be freed
     by calling the same function but ending in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">_free</span></span></span>. A function <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_foo_create_yyy</span></span></span> returns a
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlFoo</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;*</span></span></span> object (note the &#8220;<span 
class="ts1-lmr10-x-x-109">*</span>&#8221;) and a function <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_foo_bar_create_yyy</span></span></span> returns a
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlFooBar</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;*</span></span></span> object (note the &#8220;<span 
class="ts1-lmr10-x-x-109">*</span>&#8221;). These objects must be freed by calling respectively
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_foo_free</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_foo_bar_free</span></span></span>.
     </p></li>
     <li class="itemize">
     <!--l. 217--><p class="noindent" >Functions ending in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">_clone</span></span></span> take two arguments <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">src</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">dest</span></span></span> and modify <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">dest</span></span></span> to make it
     identical to <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">src</span></span></span>, ie. they have the same size and data. Note that no new object is allocated,
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">dest</span></span></span> must exist before calling this function.
     </p></li>
     <li class="itemize">
     <!--l. 222--><p class="noindent" >Functions ending in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">_copy</span></span></span> create a new object identical (ie. with the same size and content) as
     its argument but independent (ie. modifying one of them does not alter the other). Calling
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">A</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;pnl_xxx_copy(B)</span></span></span> is equivalent to first calling <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">A</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;pnl_xxx_new()</span></span></span> function and then
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_xxx_clone(A,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;B)</span></span></span>.
     </p></li>
     <li class="itemize">
     <!--l. 228--><p class="noindent" >Every object must implement a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_xxx_new</span></span></span> function which returns a pointer to an empty
     object with all its elements properly set to <span 
class="rm-lmr-10x-x-109">0</span>. This means that the objects returned by the
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_xxx_new</span></span></span> functions can be used as output arguments for functions ending in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">_inplace</span></span></span> for
     instance. They are suitable for being resized.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 234--><p class="noindent" >Functions containing <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">_wrap_</span></span></span> in their names always return an object, not a pointer to an
     object, and do not make any use of dynamic allocation. The returned object must not be
     freed. For instance, a function <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_foo_wrap_xxx</span></span></span> returns an object <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlFoo</span></span></span> and a function
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_foo_bar_wrap_xxx</span></span></span> returns an object <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlFooBar</span></span></span>
                                                                                    

                                                                                    
</p>
     <pre class="verbatim" id="verbatim-3">
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVectComplex&#x00A0;*v1;
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVectComplex&#x00A0;v2;
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;v1&#x00A0;=&#x00A0;pnl_vect_complex_create_from_scalar&#x00A0;(5,&#x00A0;Complex(0.,&#x00A0;1.));
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;v2&#x00A0;=&#x00A0;pnl_vect_complex_wrap_subvect&#x00A0;(v1,&#x00A0;1,&#x00A0;2);
     
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;...
     
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_vect_complex_free&#x00A0;(&amp;v1);
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;
</pre>
     <!--l. 249--><p class="nopar" >The vector <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v1</span></span></span> is of size 5 and contains the pure imaginary number <span 
class="lmmi-10x-x-109">i</span>. The vector <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span> only
     provides a view to <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v1(1:1+2)</span></span></span>, which means that modifying <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span> will also modify <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v1</span></span></span> and
     vice-versa because <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v1</span></span></span> shares part of its data with <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span>. Note that only <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v1</span></span></span> must be freed and <span 
class="ec-lmbx-10x-x-109">not</span>
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span>.
     </p></li>
     <li class="itemize">
     <!--l. 256--><p class="noindent" >Functions ending in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">_init</span></span></span> do not create any object but only perform some internal
     initialisation.
     </p></li>
     <li class="itemize">
     <!--l. 259--><p class="noindent" >Hypermatrices, matrices and vectors are stored using a flat block of memory obtained by
     concatenating the matrix rows and C-style pointer-to-pointer arrays. Matrices are stored in
     row-major order, which means that the column index moves continuously. Note that this
     convention is not <span 
class="ec-lmri-10x-x-109">Blas &amp; Lapack </span>compliant since Fortran expects 2-dimensional arrays to be
     stored in a column-major order.
     </p></li>
     <li class="itemize">
     <!--l. 266--><p class="noindent" >Type names always begin with <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">Pnl</span></span></span>, they do not contain underscores but instead we use
     capital letters to separate units in type names. <br 
class="newline" />Examples : <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlMat</span></span></span>, <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlMatComplex</span></span></span>.
     </p></li>
     <li class="itemize">
     <!--l. 270--><p class="noindent" >Object and function names are intimately linked : an object <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlFoo</span></span></span> is manipulated by
     functions starting in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_foo</span></span></span>, an object <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlFooBar</span></span></span> is manipulated by functions
     starting in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_foo_bar</span></span></span>. In table&#x00A0;<a 
href="#x1-40011">1<!--tex4ht:ref: pnltypes --></a>, we summarise the types and their corresponding
     prefixes.
</p>
                                                                                    

                                                                                    
     <hr class="figure" /><div class="figure" 
><a 
 id="x1-40011"></a> <!--tex4ht:inline--><div class="tabular"> <table id="TBL-2" class="tabular" 
 
><colgroup id="TBL-2-1g"><col 
id="TBL-2-1" /></colgroup><colgroup id="TBL-2-2g"><col 
id="TBL-2-2" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-1-1"  
class="td11">Pnl types           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-1-2"  
class="td11">Pnl prefix                 </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-2-1"  
class="td11">PnlVect              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-2-2"  
class="td11">pnl_vect                  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-3-1"  
class="td11">PnlVectComplex   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-3-2"  
class="td11">pnl_vect_complex     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-4-1"  
class="td11">PnlVectInt           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-4-2"  
class="td11">pnl_vect_int            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-5-1"  
class="td11">                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-5-2"  
class="td11">                   </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-6-1"  
class="td11">PnlMat </td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-6-2"  
class="td11">pnl_mat</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-7-1"  
class="td11">PnlMatComplex   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-7-2"  
class="td11">pnl_mat_complex     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-8-1"  
class="td11">PnlMatInt           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-8-2"  
class="td11">pnl_mat_int            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-9-1"  
class="td11">                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-9-2"  
class="td11">                   </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-10-1"  
class="td11">PnlSpMat </td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-10-2"  
class="td11">pnl_sp_mat</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-11-1"  
class="td11">PnlSpMatComplex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-11-2"  
class="td11">pnl_sp_mat_complex</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-12-1"  
class="td11">PnlSpMatInt        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-12-2"  
class="td11">pnl_sp_mat_int       </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-13-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-13-1"  
class="td11">                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-13-2"  
class="td11">                   </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-14-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-14-1"  
class="td11">PnlHmat </td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-14-2"  
class="td11">pnl_hmat</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-15-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-15-1"  
class="td11">PnlHmatComplex </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-15-2"  
class="td11">pnl_hmat_complex   </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-16-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-16-1"  
class="td11">PnlHmatInt         </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-16-2"  
class="td11">pnl_hmat_int           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-17-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-17-1"  
class="td11">                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-17-2"  
class="td11">                   </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-18-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-18-1"  
class="td11">PnlTridiagMat </td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-18-2"  
class="td11">pnl_tridiag_mat</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-19-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-19-1"  
class="td11">PnlBandMat        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-19-2"  
class="td11">pnl_band_mat         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-20-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-20-1"  
class="td11">                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-20-2"  
class="td11">                   </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-21-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-21-1"  
class="td11">PnlList </td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-21-2"  
class="td11">pnl_list</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-22-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-22-1"  
class="td11">                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-22-2"  
class="td11">                   </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-23-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-23-1"  
class="td11">PnlBasis </td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-23-2"  
class="td11">pnl_basis</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-24-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-24-1"  
class="td11">                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-24-2"  
class="td11">                   </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-25-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-25-1"  
class="td11">PnlCgSolver </td> <td  style="white-space:nowrap; text-align:left;" id="TBL-2-25-2"  
class="td11">pnl_cg_solver</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-26-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-26-1"  
class="td11">PnlBicgSolver       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-26-2"  
class="td11">pnl_bicg_solver        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-27-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-27-1"  
class="td11">PnlGmresSolver    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-2-27-2"  
class="td11">pnl_gmres_solver      </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-28-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-28-1"  
class="td11">                </td></tr></table>                                                           </div>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;1: </span><span  
class="content">Pnl types</span></div><!--tex4ht:label?: x1-40011 -->
     </div><hr class="endfigure" />
     </li>
     <li class="itemize">
     <!--l. 313--><p class="noindent" >All macro names begin with <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PNL_</span></span></span> and are capitalised.
     </p></li>
     <li class="itemize">
     <!--l. 315--><p class="noindent" >Differences between <span 
class="ec-lmbx-10x-x-109">copy </span>and <span 
class="ec-lmbx-10x-x-109">clone </span>methods. The <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">copy</span></span></span> methods take a single argument and
     return a pointer to an object of the same type which is an independent copy of its argument.
     Example:
                                                                                    

                                                                                    
</p>
     <pre class="verbatim" id="verbatim-4">
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVect&#x00A0;*v1,&#x00A0;*v2;
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;v1&#x00A0;=&#x00A0;pnl_vect_create_from_scalar&#x00A0;(5,&#x00A0;2.5);
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;v2&#x00A0;=&#x00A0;pnl_vect_copy&#x00A0;(v1);
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;
</pre>
     <!--l. 323--><p class="nopar" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v1</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span> are two vectors of size 5 with all their elements equal to 2.5. Note that <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span> <span 
class="ec-lmbx-10x-x-109">must</span>
     <span 
class="ec-lmbx-10x-x-109">not </span>have been created by a call to <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_vect_create_xxx</span></span></span> because otherwise it will cause a
     memory leak. <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v1</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span> are independent in the sense that a modification to one of them does
     not affect the other.
     </p><!--l. 330--><p class="noindent" >The <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">clone</span></span></span> methods take two arguments and fill the first one with the second one.
     Example:
                                                                                    

                                                                                    
</p>
     <pre class="verbatim" id="verbatim-5">
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVect&#x00A0;*v1,&#x00A0;*v2;
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;v1&#x00A0;=&#x00A0;pnl_vect_create_from_scalar&#x00A0;(5,&#x00A0;2.5);
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;v2&#x00A0;=&#x00A0;pnl_vect_new&#x00A0;();
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_vect_clone&#x00A0;(v2,&#x00A0;v1);
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;
</pre>
     <!--l. 338--><p class="nopar" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v1</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span> are two vectors of size 5 with all their elements equal to 2.5. Note that <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span> <span 
class="ec-lmbx-10x-x-109">must</span>
     have been created by a call to <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_vect_new</span></span></span> because otherwise the function <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_vect_clone</span></span></span>
     will crash. <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v1</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">v2</span></span></span> are independent in the sense that a modification to one of them does not
     modify the other.
     </p></li>
     <li class="itemize">
     <!--l. 346--><p class="noindent" >All objects are measured using integers <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">int</span></span></span> and not <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">size_t</span></span></span>. Hence, iterations over vectors,
     matrices, &#x2026;should use an index of type <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">int</span></span></span>.
     </p></li>
     <li class="itemize">
     <!--l. 350--><p class="noindent" >In fonctions ending in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">inplace</span></span></span>, the output parameter must be different from any of the input
     parameters.</p></li></ul>
<!--l. 355--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">1.3   </span> <a 
 id="x1-50001.3"></a>Using Pnl</h4>
<!--l. 357--><p class="noindent" >In this section, we assume that the library is installed in the directory <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">$HOME/pnl-xxx</span></span></span>.
</p><!--l. 360--><p class="noindent" >Once installed, the library can be found in the <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">$HOME/pnl-xxx/lib</span></span></span> directory and the header files in
the <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">$HOME/pnl-xxx/include</span></span></span> directory.
</p><!--l. 364--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">1.3.1   </span> <a 
 id="x1-60001.3.1"></a>Compiling and Linking</h5>
<!--l. 366--><p class="noindent" >The header files of the library are installed in a root <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl</span></span></span> directory and should always be included
with this <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/</span></span></span> prefix. So, for instance to use random number generators you should
include
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-6">
#include&#x00A0;&#x003C;pnl/pnl_random.h&#x003E;
</pre>
<!--l. 371--><p class="nopar" >
</p>
<!--l. 373--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-7000"></a><span 
class="ec-lmbx-10x-x-109">Compiling and linking by hand.</span></span>
If <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">gcc</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">llvm</span></span></span> is used, you should pass the following options </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 377--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">-I$HOME/pnl-xxx/include</span></span></span> for compiling
     </p></li>
     <li class="itemize">
     <!--l. 378--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">-L$HOME/pnl-xxx/lib</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;-lpnl</span></span></span> for linking</p></li></ul>
<!--l. 380--><p class="noindent" >This does not work straight away on all OS especially if the library is not installed in a standard
directory namely <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">/usr/</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">/usr/local/</span></span></span> for which you need a privileged writing access. On some
systems, you may need to add to the linker flags the dependencies of the library, which can become
very tedious. Therefore, we provide a second automatic mechanism which takes care of the
dependencies on its own.
</p>
<!--l. 387--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-8000"></a><span 
class="ec-lmbx-10x-x-109">Compiling and linking using an automatic Makefile.</span></span>
This mechanism only works under Unix (it has been tested under various Linux distributions and
Mac OS X).
</p><!--l. 392--><p class="noindent" >First, you need to create a new directory wherever you want, put in all your code and create a
Makefile as below
</p><!--l. 395--><p class="noindent" >To define your target just add the executable name, say <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">my-exec</span></span></span>, to the <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">BINS</span></span></span> list and create an
entry <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">my_exec_SRC</span></span></span> carrying the list of source files needed to create your executable. Note that if
dashes &#8217;-&#8217; may appear in an executable name, the name of the associated variable holding the list of
source files is obtained by replacing dashes with underscores &#8217;_&#8217; and adding the _SRC
suffix.
</p><!--l. 402--><p class="noindent" >Assume you want to create two binaries : <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">my-exec</span></span></span> based on mixed C and C++ code (<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">file1.c</span></span></span> and
<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">file2.cpp</span></span></span>) and <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">mybinary</span></span></span> based on <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">poo1.cxx</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">poo2.cpp</span></span></span>. You can use the following
Makefile.
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-7">
##&#x00A0;Flags&#x00A0;passed&#x00A0;to&#x00A0;the&#x00A0;linker
LDFLAGS=

##&#x00A0;Flags&#x00A0;passed&#x00A0;to&#x00A0;the&#x00A0;compiler
CFLAGS=

##&#x00A0;list&#x00A0;of&#x00A0;executables&#x00A0;to&#x00A0;create
BINS=my-exec&#x00A0;mybinary

my_exec_SRC=file1.c&#x00A0;file2.cpp
#&#x00A0;optional&#x00A0;flags&#x00A0;for&#x00A0;compiling&#x00A0;and&#x00A0;linking
my_exec_CFLAGS=
my_exec_CXXFLAGS=
my_exec_LDFLAGS=

mybinary_SRC=poo1.cxx&#x00A0;poo2.cpp
#&#x00A0;optional&#x00A0;flags&#x00A0;for&#x00A0;compiling&#x00A0;and&#x00A0;linking
mybinary_CFLAGS=
mybinary_CXXFLAGS=
mybinary_LDFLAGS=


##&#x00A0;This&#x00A0;line&#x00A0;must&#x00A0;be&#x00A0;the&#x00A0;last&#x00A0;one
include&#x00A0;full_path_to_pnl_build/CMakeuser.incl
</pre>
<!--l. 430--><p class="nopar" >Let us comment a little the different variables </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 433--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">CFLAGS</span></span></span>: global flags used for creating objects based on C code
     </p></li>
     <li class="itemize">
     <!--l. 434--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">CXXFLAGS</span></span></span>: global flags used for creating objects based on C++ code
     </p></li>
     <li class="itemize">
     <!--l. 435--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">LDFLAGS</span></span></span>: gobal linker flags.
     </p></li>
     <li class="itemize">
     <!--l. 436--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">binaryname_CFLAGS</span></span></span>: flags used when creating the objects based on C code and required
     by <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">binaryname</span></span></span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 438--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">binaryname_CXXFLAGS</span></span></span>: flags used when creating the objects based on C++ code and
     required by <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">binaryname</span></span></span>
     </p></li>
     <li class="itemize">
     <!--l. 440--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">binaryname_LDFLAGS</span></span></span>: flags used when linking objects for creating <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">binaryname</span></span></span></p></li></ul>
<!--l. 443--><p class="noindent" >An example of such a Makefile can be found in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl-xxx/perso</span></span></span>.
</p><!--l. 445--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Warning: </span>if a file appears in the source list of several binairies, the flags used to compile this file
are determined by the ones of the first binary involving this file. In the following example <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">main.cpp</span></span></span>
will always be compiled with the flag <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">-O3</span></span></span> even for generating <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">bin2</span></span></span>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-8">
BINS=bin1&#x00A0;bin2

bin1_SRC=main.cpp&#x00A0;poo1.c
my_exec_CXXFLAGS=-O3

bin2_SRC=main.cpp&#x00A0;poo2.c
mybinary_CXXFLAGS=-g&#x00A0;-O0

##&#x00A0;This&#x00A0;line&#x00A0;must&#x00A0;be&#x00A0;the&#x00A0;last&#x00A0;one
include&#x00A0;full_path_to_pnl_build/CMakeuser.incl
</pre>
<!--l. 460--><p class="nopar" >
</p>
<!--l. 462--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-9000"></a><span 
class="ec-lmbx-10x-x-109">Compiling and linking using CMake.</span></span>
If you already use CMake for your new project, just add the following to your toplevel
<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">CMakeLists.txt</span></span></span>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-9">
find_package(Pnl&#x00A0;REQUIRED)
set(LIBS&#x00A0;${LIBS}&#x00A0;${PNL_LIBRARIES})
include_directories(${PNL_INCLUDE_DIRS})
#&#x00A0;Deactivate&#x00A0;PNL&#x00A0;debugging&#x00A0;stuff&#x00A0;on&#x00A0;Release&#x00A0;builds
if(${CMAKE_BUILD_TYPE}&#x00A0;STREQUAL&#x00A0;"Release")
&#x00A0;&#x00A0;&#x00A0;&#x00A0;add_definitions(-DPNL_RANGE_CHECK_OFF)
endif()
</pre>
<!--l. 474--><p class="nopar" >Then, call cmake with the following extra flag
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-10">
-DCMAKE_PREFIX_PATH=path/to/build-dir
</pre>
<!--l. 478--><p class="nopar" >or add the variable <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">CMAKE_BUILD_TYPE</span></span></span> to the GUI. <br 
class="newline" />
</p><!--l. 481--><p class="noindent" >Just in case, we give an example of a complete although elementary <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">CMakeLists.txt</span></span></span>
</p><div class="verbatiminput"></div>
<!--l. 484--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">1.3.2   </span> <a 
 id="x1-100001.3.2"></a>Inline Functions and getters</h5>
<!--l. 487--><p class="noindent" >If it is supported by your compiler, getter and setter functions are declared as inline functions. This
is automatically detected when running CMake. By default, setter and getter functions check that
the required access is valid, basically it boils down to checking whether the index of the access is
within an acceptable range. These extra tests can become very expensive when getter and setter
functions are intensively called.
</p><!--l. 494--><p class="noindent" >Thus, it is possible to alter this default behaviour by defining the macro <span 
class="ec-lmtt-10x-x-109">PNL_RANGE_CHECK_OFF</span>.
This macro is automatically defined when the library is compiled in Release mode, ie. with
<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">-DCMAKE_BUILD_TYPE=Release</span></span></span> passed to CMake.
</p><!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-110002"></a>Objects</h3>
<!--l. 3--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-120002.1"></a>The top-level object</h4>
<!--l. 5--><p class="noindent" >The PnlObject structure is used to simulate some inheritance between the ojbects of Pnl. It must be
the first element of all the objects existing in Pnl so that casting any object to a PnlObject is
legal
<a 
 id="dx1-12001"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-11">
typedef&#x00A0;unsigned&#x00A0;int&#x00A0;PnlType;

typedef&#x00A0;void&#x00A0;(DestroyFunc)&#x00A0;(void&#x00A0;**);
typedef&#x00A0;PnlObject*&#x00A0;(CopyFunc)&#x00A0;(PnlObject&#x00A0;*);
typedef&#x00A0;PnlObject*&#x00A0;(NewFunc)&#x00A0;(PnlObject&#x00A0;*);
typedef&#x00A0;void&#x00A0;(CloneFunc)&#x00A0;(PnlObject&#x00A0;*dest,&#x00A0;const&#x00A0;PnlObject&#x00A0;*src);
struct&#x00A0;_PnlObject
{
&#x00A0;&#x00A0;PnlType&#x00A0;type;&#x00A0;/*!&#x003C;&#x00A0;a&#x00A0;unique&#x00A0;integer&#x00A0;id&#x00A0;*/
&#x00A0;&#x00A0;const&#x00A0;char&#x00A0;*label;&#x00A0;/*!&#x003C;&#x00A0;a&#x00A0;string&#x00A0;identifier&#x00A0;(for&#x00A0;the&#x00A0;moment&#x00A0;not&#x00A0;useful)&#x00A0;*/
&#x00A0;&#x00A0;PnlType&#x00A0;parent_type;&#x00A0;/*!&#x003C;&#x00A0;the&#x00A0;identifier&#x00A0;of&#x00A0;the&#x00A0;parent&#x00A0;object&#x00A0;is&#x00A0;any,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;otherwise&#x00A0;parent_type=id&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;nref;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;references&#x00A0;on&#x00A0;the&#x00A0;object&#x00A0;*/
&#x00A0;&#x00A0;DestroyFunc&#x00A0;*destroy;&#x00A0;/*!&#x003C;&#x00A0;frees&#x00A0;an&#x00A0;object&#x00A0;*/
&#x00A0;&#x00A0;NewFunc&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;*constructor;&#x00A0;/*!&#x003C;&#x00A0;New&#x00A0;function&#x00A0;*/
&#x00A0;&#x00A0;CopyFunc&#x00A0;&#x00A0;&#x00A0;&#x00A0;*copy;&#x00A0;/*!&#x003C;&#x00A0;Copy&#x00A0;function&#x00A0;*/
&#x00A0;&#x00A0;CloneFunc&#x00A0;&#x00A0;&#x00A0;*clone;&#x00A0;/*!&#x003C;&#x00A0;Clone&#x00A0;function&#x00A0;*/
};
</pre>
<!--l. 29--><p class="nopar" >
</p><!--l. 31--><p class="noindent" >Here is the list of all the types actually defined </p><div class="table">
                                                                                    

                                                                                    
<!--l. 33--><p class="noindent" ><a 
 id="x1-120021"></a></p><hr class="float" /><div class="float" 
>
                                                                                    

                                                                                    
<div class="tabular"> <table id="TBL-3" class="tabular" 
 
><colgroup id="TBL-3-1g"><col 
id="TBL-3-1" /></colgroup><colgroup id="TBL-3-2g"><col 
id="TBL-3-2" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-1-1"  
class="td11">PnlType                                                  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-1-2"  
class="td11">Description                      </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-2-1"  
class="td11">PNL_TYPE_VECTOR                              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-2-2"  
class="td11">general vectors                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-3-1"  
class="td11">PNL_TYPE_VECTOR_DOUBLE               </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-3-2"  
class="td11">real vectors                      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-4-1"  
class="td11">PNL_TYPE_VECTOR_INT                      </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-4-2"  
class="td11">integer vectors                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-5-1"  
class="td11">PNL_TYPE_VECTOR_COMPLEX            </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-5-2"  
class="td11">complex vectors                </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-6-1"  
class="td11">PNL_TYPE_MATRIX                               </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-6-2"  
class="td11">general matrices               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-7-1"  
class="td11">PNL_TYPE_MATRIX_DOUBLE                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-7-2"  
class="td11">real matrices                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-8-1"  
class="td11">PNL_TYPE_MATRIX_INT                       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-8-2"  
class="td11">integer matrices                </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-9-1"  
class="td11">PNL_TYPE_MATRIX_COMPLEX             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-9-2"  
class="td11">complex matrices              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-10-1"  
class="td11">PNL_TYPE_TRIDIAG_MATRIX               </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-10-2"  
class="td11">general tridiagonal matrices</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-11-1"  
class="td11">PNL_TYPE_TRIDIAG_MATRIX_DOUBLE</td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-11-2"  
class="td11">real tridiagonal matrices    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-12-1"  
class="td11">PNL_TYPE_BAND_MATRIX                    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-12-2"  
class="td11">general band matrices        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-13-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-13-1"  
class="td11">PNL_TYPE_BAND_MATRIX_DOUBLE    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-13-2"  
class="td11">real band matrices            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-14-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-14-1"  
class="td11">PNL_TYPE_SP_MATRIX                         </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-14-2"  
class="td11">sparse general matrices      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-15-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-15-1"  
class="td11">PNL_TYPE_SP_MATRIX_DOUBLE          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-15-2"  
class="td11">sparse real matrices           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-16-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-16-1"  
class="td11">PNL_TYPE_SP_MATRIX_INT                 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-16-2"  
class="td11">sparse integer matrices       </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-17-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-17-1"  
class="td11">PNL_TYPE_SP_MATRIX_COMPLEX       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-17-2"  
class="td11">sparse complex matrices     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-18-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-18-1"  
class="td11">PNL_TYPE_HMATRIX                             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-18-2"  
class="td11">general hyper matrices       </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-19-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-19-1"  
class="td11">PNL_TYPE_HMATRIX_DOUBLE             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-19-2"  
class="td11">real hyper matrices           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-20-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-20-1"  
class="td11">PNL_TYPE_HMATRIX_INT                     </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-20-2"  
class="td11">integer hyper matrices       </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-21-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-21-1"  
class="td11">PNL_TYPE_HMATRIX_COMPLEX           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-21-2"  
class="td11">complex hyper matrices     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-22-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-22-1"  
class="td11">PNL_TYPE_BASIS                                  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-22-2"  
class="td11">bases                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-23-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-23-1"  
class="td11">PNL_TYPE_RNG                                    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-23-2"  
class="td11">random number generators </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-24-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-24-1"  
class="td11">PNL_TYPE_LIST                                    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-24-2"  
class="td11">doubly linked list              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-25-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-25-1"  
class="td11">PNL_TYPE_ARRAY                                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-3-25-2"  
class="td11">array                              </td></tr></table>           </div>
<br /> <div class="caption" 
><span class="id">Table&#x00A0;1: </span><span  
class="content">PnlTypes</span></div><!--tex4ht:label?: x1-120021 -->
                                                                                    

                                                                                    
</div><hr class="endfloat" />
</div>
<!--l. 67--><p class="noindent" >We provide several macros for manipulating PnlObejcts. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 69--><p class="noindent" ><a 
 id="dx1-12003"></a> <span 
class="ec-lmbx-10x-x-109">PNL_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlObject
     </p></li>
     <li class="itemize">
     <!--l. 72--><p class="noindent" ><a 
 id="dx1-12004"></a> <span 
class="ec-lmbx-10x-x-109">PNL_VECT_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlVectObject
     </p></li>
     <li class="itemize">
     <!--l. 75--><p class="noindent" ><a 
 id="dx1-12005"></a> <span 
class="ec-lmbx-10x-x-109">PNL_MAT_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlMatObject
     </p></li>
     <li class="itemize">
     <!--l. 78--><p class="noindent" ><a 
 id="dx1-12006"></a> <span 
class="ec-lmbx-10x-x-109">PNL_SP_MAT_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlSpMatObject
     </p></li>
     <li class="itemize">
     <!--l. 81--><p class="noindent" ><a 
 id="dx1-12007"></a> <span 
class="ec-lmbx-10x-x-109">PNL_HMAT_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlHmatObject
     </p></li>
     <li class="itemize">
     <!--l. 84--><p class="noindent" ><a 
 id="dx1-12008"></a> <span 
class="ec-lmbx-10x-x-109">PNL_BAND_MAT_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlBandMatObject
     </p></li>
     <li class="itemize">
     <!--l. 87--><p class="noindent" ><a 
 id="dx1-12009"></a> <span 
class="ec-lmbx-10x-x-109">PNL_TRIDIAGMAT_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlTridiagMatObject
     </p></li>
     <li class="itemize">
     <!--l. 90--><p class="noindent" ><a 
 id="dx1-12010"></a> <span 
class="ec-lmbx-10x-x-109">PNL_BASIS_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlBasis
     </p></li>
     <li class="itemize">
     <!--l. 93--><p class="noindent" ><a 
 id="dx1-12011"></a> <span 
class="ec-lmbx-10x-x-109">PNL_RNG_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlRng
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 96--><p class="noindent" ><a 
 id="dx1-12012"></a> <span 
class="ec-lmbx-10x-x-109">PNL_LIST_OBJECT</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlList
     </p></li>
     <li class="itemize">
     <!--l. 99--><p class="noindent" ><a 
 id="dx1-12013"></a> <span 
class="ec-lmbx-10x-x-109">PNL_LIST_ARRAY</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cast any object into a PnlArray
     </p></li>
     <li class="itemize">
     <!--l. 102--><p class="noindent" ><a 
 id="dx1-12014"></a> <span 
class="ec-lmbx-10x-x-109">PNL_GET_TYPENAME</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the name of the type of any object inheriting from PnlObject
     </p></li>
     <li class="itemize">
     <!--l. 105--><p class="noindent" ><a 
 id="dx1-12015"></a> <span 
class="ec-lmbx-10x-x-109">PNL_GET_TYPE</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the type of any object inheriting from PnlObject
     </p></li>
     <li class="itemize">
     <!--l. 108--><p class="noindent" ><a 
 id="dx1-12016"></a> <span 
class="ec-lmbx-10x-x-109">PNL_GET_PARENT_TYPE</span>&#x00A0;(o)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the parent type of any object inheriting from PnlObject</p></li></ul>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 113--><p class="noindent" ><a 
 id="dx1-12017"></a> <span class='ret'><a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_create</span></span>&#x00A0;(<span class='args'>PnlType t</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty PnlObject of type <span class='var'>t</span> which can any of the registered
     types, see Table&#x00A0;<a 
href="#x1-120021">1<!--tex4ht:ref: types --></a>.</p></li></ul>
<h4 class="subsectionHead"><span class="titlemark">2.2   </span> <a 
 id="x1-130002.2"></a>List object</h4>
<!--l. 120--><p class="noindent" >This section describes functions for creating an manipulating lists. Lists are internally stored as
doubly linked lists.
</p><!--l. 123--><p class="noindent" >The structures and functions related to lists are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_list.h</span></span></span>.
<a 
 id="dx1-13001"></a>
<a 
 id="dx1-13002"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-12">
typedef&#x00A0;struct&#x00A0;_PnlCell&#x00A0;PnlCell;
struct&#x00A0;_PnlCell
{
&#x00A0;&#x00A0;struct&#x00A0;_PnlCell&#x00A0;*prev;&#x00A0;&#x00A0;/*!&#x003C;&#x00A0;previous&#x00A0;cell&#x00A0;or&#x00A0;0&#x00A0;*/
&#x00A0;&#x00A0;struct&#x00A0;_PnlCell&#x00A0;*next;&#x00A0;&#x00A0;/*!&#x003C;&#x00A0;next&#x00A0;cell&#x00A0;or&#x00A0;0&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;*self;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;/*!&#x003C;&#x00A0;stored&#x00A0;object&#x00A0;*/
};


typedef&#x00A0;struct&#x00A0;_PnlList&#x00A0;PnlList;
struct&#x00A0;_PnlList
{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlList&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;PnlCell&#x00A0;*first;&#x00A0;/*!&#x003C;&#x00A0;first&#x00A0;element&#x00A0;of&#x00A0;the&#x00A0;list&#x00A0;*/
&#x00A0;&#x00A0;PnlCell&#x00A0;*last;&#x00A0;/*!&#x003C;&#x00A0;last&#x00A0;element&#x00A0;of&#x00A0;the&#x00A0;list&#x00A0;*/
&#x00A0;&#x00A0;PnlCell&#x00A0;*curcell;&#x00A0;/*!&#x003C;&#x00A0;last&#x00A0;accessed&#x00A0;element,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;never&#x00A0;accessed&#x00A0;is&#x00A0;NULL&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;icurcell;&#x00A0;/*!&#x003C;&#x00A0;index&#x00A0;of&#x00A0;the&#x00A0;last&#x00A0;accessed&#x00A0;element,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;never&#x00A0;accessed&#x00A0;is&#x00A0;NULLINT&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;len;&#x00A0;/*!&#x003C;&#x00A0;length&#x00A0;of&#x00A0;the&#x00A0;list&#x00A0;*/
};
</pre>
<!--l. 153--><p class="nopar" >
</p><!--l. 155--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Important note</span>: Lists only store addresses of objects. So when an object is inserted into a
list, only its address is stored into the list. This implies that you <span 
class="ec-lmbx-10x-x-109">must not </span>free any
objects inserted into a list. The deallocation is automatically handled by the function
<a 
href="#x1-130002.2">pnl_list_free</a>.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 161--><p class="noindent" ><a 
 id="dx1-13003"></a> <span class='ret'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty list
     </p></li>
     <li class="itemize">
     <!--l. 163--><p class="noindent" ><a 
 id="dx1-13004"></a> <span class='ret'><a 
href="#x1-130002.2"><span class='struct'>PnlCell</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cell_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an cell list
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 165--><p class="noindent" ><a 
 id="dx1-13005"></a> <span class='ret'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a copy of a <a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> . Each element of the list <span class='var'>A</span> is copied by calling
     the its copy member.
     </p></li>
     <li class="itemize">
     <!--l. 168--><p class="noindent" ><a 
 id="dx1-13006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>dest, const <a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy the content of <span class='var'>src</span> into the already existing list <span class='var'>dest</span>. The list <span class='var'>dest</span>
     is automatically resized. This is a hard copy, the contents of both lists are independent
     after cloning.
     </p></li>
     <li class="itemize">
     <!--l. 173--><p class="noindent" ><a 
 id="dx1-13007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>L</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a list
     </p></li>
     <li class="itemize">
     <!--l. 175--><p class="noindent" ><a 
 id="dx1-13008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cell_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlCell</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>c</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a list
     </p></li>
     <li class="itemize">
     <!--l. 177--><p class="noindent" ><a 
 id="dx1-13009"></a> <span class='ret'><a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_get</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function returns the content of the <span class='var'>i</span>&#8211;th cell of the list <span class='var'>L</span>. This
     function is optimized for linearly accessing all the elements, so it can be used inside a
     for loop for instance.
     </p></li>
     <li class="itemize">
     <!--l. 182--><p class="noindent" ><a 
 id="dx1-13010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_insert_first</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L, <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>o</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Insert the object <span class='var'>o</span> on top of the list <span class='var'>L</span>. Note that <span class='var'>o</span> is not copied in <span class='var'>L</span>,
     so do <span 
class="ec-lmbx-10x-x-109">not </span>free <span class='var'>o</span> yourself, it will be done automatically when calling <a 
href="#x1-130002.2">pnl_list_free</a>
     </p></li>
     <li class="itemize">
     <!--l. 187--><p class="noindent" ><a 
 id="dx1-13011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_insert_last</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L, <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>o</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Insert the object <span class='var'>o</span> at the bottom of the list <span class='var'>L</span>. Note that <span class='var'>o</span> is not copied
     in <span class='var'>L</span>, so do <span 
class="ec-lmbx-10x-x-109">not </span>free <span class='var'>o</span> yourself, it will be done automatically when calling <a 
href="#x1-130002.2">pnl_list_free</a>
     </p></li>
     <li class="itemize">
     <!--l. 192--><p class="noindent" ><a 
 id="dx1-13012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_remove_last</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Remove the last element of the list <span class='var'>L</span> and frees it.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 194--><p class="noindent" ><a 
 id="dx1-13013"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_remove_first</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Remove the first element of the list <span class='var'>L</span> and frees it.
     </p></li>
     <li class="itemize">
     <!--l. 196--><p class="noindent" ><a 
 id="dx1-13014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_remove_i</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Remove the <span class='var'>i-th</span> element of the list <span class='var'>L</span> and frees it.
     </p></li>
     <li class="itemize">
     <!--l. 198--><p class="noindent" ><a 
 id="dx1-13015"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_concat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L1, <a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Concatenate the two lists <span class='var'>L1</span> and <span class='var'>L2</span>. The resulting list is store in <span class='var'>L1</span>
     on exit. Do <span 
class="ec-lmbx-10x-x-109">not </span>free <span class='var'>L2</span> since concatenation does not actually copy objects but only
     manipulates addresses.
     </p></li>
     <li class="itemize">
     <!--l. 204--><p class="noindent" ><a 
 id="dx1-13016"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Change the length of <span class='var'>L</span> to become <span class='var'>n</span>. If the length of <span class='var'>L</span> id increased, the
     extra elements are set to NULL.
     </p></li>
     <li class="itemize">
     <!--l. 207--><p class="noindent" ><a 
 id="dx1-13017"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_list_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Only prints the types of each element. When the <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> object has
     a print member, we will use it.</p></li></ul>
<!--l. 212--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">2.3   </span> <a 
 id="x1-140002.3"></a>Array object</h4>
<!--l. 214--><p class="noindent" >This section describes functions for creating and manipulating arrays of PnlObjects.
</p><!--l. 217--><p class="noindent" >The structures and functions related to arrays are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_array.h</span></span></span>.
<a 
 id="dx1-14001"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-13">
typedef&#x00A0;struct&#x00A0;_PnlArray&#x00A0;PnlArray;
struct&#x00A0;_PnlArray
{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlArray&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;size;
&#x00A0;&#x00A0;PnlObject&#x00A0;**array;
&#x00A0;&#x00A0;int&#x00A0;mem_size;
};
</pre>
<!--l. 234--><p class="nopar" >
</p><!--l. 236--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Important note</span>: Arrays only store addresses of objects. So when an object is inserted into an
array, only its address is stored into the array. This implies that you <span 
class="ec-lmbx-10x-x-109">must not </span>free any
objects inserted into a array. The deallocation is automatically handled by the function
<a 
href="#x1-140002.3">pnl_array_free</a>.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 242--><p class="noindent" ><a 
 id="dx1-14002"></a> <span class='ret'><a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_array_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty array
     </p></li>
     <li class="itemize">
     <!--l. 244--><p class="noindent" ><a 
 id="dx1-14003"></a> <span class='ret'><a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_array_create</span></span>&#x00A0;(<span class='args'>int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an array of length <span class='var'>n</span>.
     </p></li>
     <li class="itemize">
     <!--l. 246--><p class="noindent" ><a 
 id="dx1-14004"></a> <span class='ret'><a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_array_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a copy of a <a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> . Each element of the array <span class='var'>A</span> is copied by
     calling the <span class='var'>A[i].object.copy</span>.
     </p></li>
     <li class="itemize">
     <!--l. 249--><p class="noindent" ><a 
 id="dx1-14005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_array_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>dest, const <a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy the content of <span class='var'>src</span> into the already existing array <span class='var'>dest</span>. The array
     <span class='var'>dest</span>  is  automatically  resized.  This  is  a  hard  copy,  the  contents  of  both  arrays  are
     independent after cloning.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 254--><p class="noindent" ><a 
 id="dx1-14006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_array_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">**</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free an array and all the objects hold by the array.
     </p></li>
     <li class="itemize">
     <!--l. 256--><p class="noindent" ><a 
 id="dx1-14007"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_array_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T, int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize <span class='var'>T</span> to be <span class='var'>size</span> long. As much as possible of the original data is kept.
     </p></li>
     <li class="itemize">
     <!--l. 259--><p class="noindent" ><a 
 id="dx1-14008"></a> <span class='ret'><a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_array_get</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function returns the content of the <span class='var'>i</span>&#8211;th cell of the array <span class='var'>T</span>. No copy
     is made.
     </p></li>
     <li class="itemize">
     <!--l. 263--><p class="noindent" ><a 
 id="dx1-14009"></a> <span class='ret'><a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_array_set</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T, int i, <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>O</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>T[i] = O</span>. No copy is made, so the object <span class='var'>O</span> must not be freed manually.
     </p></li>
     <li class="itemize">
     <!--l. 267--><p class="noindent" ><a 
 id="dx1-14010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_array_print</span></span>&#x00A0;(<span class='args'><a 
href="#x1-140002.3"><span class='struct'>PnlArray</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Not  yet  implemented  because  it  would  require  that  the  structure
     <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> has a field copy.</p></li></ul>
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-150003"></a>Mathematical framework</h3>
<!--l. 2--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-160003.1"></a>General tools</h4>
<!--l. 4--><p class="noindent" >The macros and functions of this paragraph are defined in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_mathtools.h</span></span></span>.
</p><!--l. 6--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.1.1   </span> <a 
 id="x1-170003.1.1"></a>Constants</h5>
<!--l. 6--><p class="noindent" >A few mathematical constants are provided by the library. Most of them are actually
already defined in <span 
class="ec-lmtt-10x-x-109">math.h</span>, <span 
class="ec-lmtt-10x-x-109">values.h </span>or <span 
class="ec-lmtt-10x-x-109">limits.h </span>and a few others have been added.
                                                                                    

                                                                                    
<!--tex4ht:inline--></p><div class="tabular"> <table id="TBL-4" class="tabular" 
 
><colgroup id="TBL-4-1g"><col 
id="TBL-4-1" /><col 
id="TBL-4-2" /><col 
id="TBL-4-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-4-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-1-1"  
class="td11"><a 
 id="dx1-17001"></a><span class='struct'>M_E</span>              </td><td  style="white-space:normal; text-align:left;" id="TBL-4-1-2"  
class="td11"><!--l. 10--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-1-3"  
class="td11"><span 
class="lmmi-10x-x-109">e</span><sup><span 
class="rm-lmr-8">1</span></sup>                                                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-2-1"  
class="td11"><a 
 id="dx1-17002"></a><span class='struct'>M_LOG2E</span>       </td><td  style="white-space:normal; text-align:left;" id="TBL-4-2-2"  
class="td11"><!--l. 11--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-2-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">log</span> <sub><span 
class="rm-lmr-8">2</span></sub><span 
class="lmmi-10x-x-109">e                            </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-3-1"  
class="td11"><a 
 id="dx1-17003"></a><span class='struct'>M_LOG10E</span>      </td><td  style="white-space:normal; text-align:left;" id="TBL-4-3-2"  
class="td11"><!--l. 12--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-3-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">log</span> <sub><span 
class="rm-lmr-8">10</span></sub><span 
class="lmmi-10x-x-109">e                           </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-4-1"  
class="td11"><a 
 id="dx1-17004"></a><span class='struct'>M_LN2</span>            </td><td  style="white-space:normal; text-align:left;" id="TBL-4-4-2"  
class="td11"><!--l. 13--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-4-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">log</span> <sub><span 
class="lmmi-8">e</span></sub><span 
class="rm-lmr-10x-x-109">2                                 </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-5-1"  
class="td11"><a 
 id="dx1-17005"></a><span class='struct'>M_LN10</span>          </td><td  style="white-space:normal; text-align:left;" id="TBL-4-5-2"  
class="td11"><!--l. 14--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-5-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">log</span> <sub><span 
class="lmmi-8">e</span></sub><span 
class="rm-lmr-10x-x-109">10                                </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-6-1"  
class="td11"><a 
 id="dx1-17006"></a><span class='struct'>M_PI</span>              </td><td  style="white-space:normal; text-align:left;" id="TBL-4-6-2"  
class="td11"><!--l. 15--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-6-3"  
class="td11"><span 
class="lmmi-10x-x-109">&#x03C0;                                 </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-7-1"  
class="td11"><a 
 id="dx1-17007"></a><span class='struct'>M_2PI</span>             </td><td  style="white-space:normal; text-align:left;" id="TBL-4-7-2"  
class="td11"><!--l. 16--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-7-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">2</span><span 
class="lmmi-10x-x-109">&#x03C0;                                </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-8-1"  
class="td11"><a 
 id="dx1-17008"></a><span class='struct'>M_PI_2</span>           </td><td  style="white-space:normal; text-align:left;" id="TBL-4-8-2"  
class="td11"><!--l. 17--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-8-3"  
class="td11"><span 
class="lmmi-10x-x-109">&#x03C0;&#x2215;</span><span 
class="rm-lmr-10x-x-109">2                                    </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-9-1"  
class="td11"><a 
 id="dx1-17009"></a><span class='struct'>M_PI_4</span>           </td><td  style="white-space:normal; text-align:left;" id="TBL-4-9-2"  
class="td11"><!--l. 18--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-9-3"  
class="td11"><span 
class="lmmi-10x-x-109">&#x03C0;&#x2215;</span><span 
class="rm-lmr-10x-x-109">4                                    </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-10-1"  
class="td11"><a 
 id="dx1-17010"></a><span class='struct'>M_1_PI</span>           </td><td  style="white-space:normal; text-align:left;" id="TBL-4-10-2"  
class="td11"><!--l. 19--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-10-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">&#x2215;&#x03C0;                              </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-11-1"  
class="td11"><a 
 id="dx1-17011"></a><span class='struct'>M_2_PI</span>           </td><td  style="white-space:normal; text-align:left;" id="TBL-4-11-2"  
class="td11"><!--l. 20--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-11-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">2</span><span 
class="lmmi-10x-x-109">&#x2215;&#x03C0;                              </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-12-1"  
class="td11"><a 
 id="dx1-17012"></a><span class='struct'>M_2_SQRTPI</span>  </td><td  style="white-space:normal; text-align:left;" id="TBL-4-12-2"  
class="td11"><!--l. 21--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-12-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">2</span><span 
class="lmmi-10x-x-109">&#x2215;</span><img 
src="pnl-manual0x.png" alt="&#x221A; --
  &#x03C0;"  class="sqrt"  />                            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-13-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-13-1"  
class="td11"><a 
 id="dx1-17013"></a><span class='struct'>M_SQRT2PI</span>     </td><td  style="white-space:normal; text-align:left;" id="TBL-4-13-2"  
class="td11"><!--l. 22--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-13-3"  
class="td11"><span 
class="lmmi-10x-x-109">sqrt</span><span 
class="rm-lmr-10x-x-109">2</span><span 
class="lmmi-10x-x-109">&#x03C0;</span>                           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-14-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-14-1"  
class="td11"><a 
 id="dx1-17014"></a><span class='struct'>M_SQRT2</span>        </td><td  style="white-space:normal; text-align:left;" id="TBL-4-14-2"  
class="td11"><!--l. 23--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-14-3"  
class="td11"><img 
src="pnl-manual1x.png" alt="&#x221A; --
  2"  class="sqrt"  />                                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-15-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-15-1"  
class="td11"><a 
 id="dx1-17015"></a><span class='struct'>M_EULER</span>       </td><td  style="white-space:normal; text-align:left;" id="TBL-4-15-2"  
class="td11"><!--l. 24--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-15-3"  
class="td11"><span 
class="lmmi-10x-x-109">&#x03B3; </span><span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">lim</span> <sub><span 
class="lmmi-8">n</span><span 
class="lmsy8-">&#x2192;&#x221E;</span></sub><img 
src="pnl-manual2x.png" alt="(&#x2211;             )
   nk=1k1- ln(n)"  class="left" align="middle" /></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-16-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-16-1"  
class="td11"><a 
 id="dx1-17016"></a><span class='struct'>M_SQRT1_2</span>    </td><td  style="white-space:normal; text-align:left;" id="TBL-4-16-2"  
class="td11"><!--l. 25--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-16-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">&#x2215;</span><img 
src="pnl-manual3x.png" alt="&#x221A;2--"  class="sqrt"  />                                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-17-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-17-1"  
class="td11"><a 
 id="dx1-17017"></a><span class='struct'>M_1_SQRT2PI</span> </td><td  style="white-space:normal; text-align:left;" id="TBL-4-17-2"  
class="td11"><!--l. 26--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-17-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">&#x2215;</span><img 
src="pnl-manual4x.png" alt="&#x221A;2-&#x03C0;-"  class="sqrt"  />                           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-18-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-18-1"  
class="td11"><a 
 id="dx1-17018"></a><span class='struct'>M_SQRT2_PI</span>  </td><td  style="white-space:normal; text-align:left;" id="TBL-4-18-2"  
class="td11"><!--l. 27--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-18-3"  
class="td11"><img 
src="pnl-manual5x.png" alt="&#x2218; ----
  2&#x2215;&#x03C0;"  class="sqrt"  />                            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-19-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-19-1"  
class="td11"><a 
 id="dx1-17019"></a><span class='struct'>INT_MAX</span>       </td><td  style="white-space:normal; text-align:left;" id="TBL-4-19-2"  
class="td11"><!--l. 28--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-19-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">2147483647                         </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-20-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-20-1"  
class="td11"><a 
 id="dx1-17020"></a><span class='struct'>MAX_INT</span>       </td><td  style="white-space:normal; text-align:left;" id="TBL-4-20-2"  
class="td11"><!--l. 29--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-20-3"  
class="td11">INT_MAX                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-21-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-21-1"  
class="td11"><a 
 id="dx1-17021"></a><span class='struct'>DBL_MAX</span>       </td><td  style="white-space:normal; text-align:left;" id="TBL-4-21-2"  
class="td11"><!--l. 30--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-21-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">.</span><span 
class="rm-lmr-10x-x-109">79769313486231470</span><span 
class="lmmi-10x-x-109">e </span><span 
class="rm-lmr-10x-x-109">+ 308   </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-22-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-22-1"  
class="td11"><a 
 id="dx1-17022"></a><span class='struct'>DOUBLE_MAX</span></td><td  style="white-space:normal; text-align:left;" id="TBL-4-22-2"  
class="td11"><!--l. 31--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-22-3"  
class="td11">DBL_MAX                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-23-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-23-1"  
class="td11"><a 
 id="dx1-17023"></a><span class='struct'>DBL_EPSILON</span> </td><td  style="white-space:normal; text-align:left;" id="TBL-4-23-2"  
class="td11"><!--l. 32--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-23-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">2</span><span 
class="lmmi-10x-x-109">.</span><span 
class="rm-lmr-10x-x-109">2204460492503131</span><span 
class="lmmi-10x-x-109">e </span><span 
class="lmsy-10x-x-109">- </span><span 
class="rm-lmr-10x-x-109">16      </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-24-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-24-1"  
class="td11"><a 
 id="dx1-17024"></a><span class='struct'>PNL_NEGINF</span>  </td><td  style="white-space:normal; text-align:left;" id="TBL-4-24-2"  
class="td11"><!--l. 33--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-24-3"  
class="td11"><span 
class="lmsy-10x-x-109">-&#x221E;                    </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-25-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-25-1"  
class="td11"><a 
 id="dx1-17025"></a><span class='struct'>PNL_POSINF</span>   </td><td  style="white-space:normal; text-align:left;" id="TBL-4-25-2"  
class="td11"><!--l. 34--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-25-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">+</span><span 
class="lmsy-10x-x-109">&#x221E;                    </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-26-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-26-1"  
class="td11"><a 
 id="dx1-17026"></a><span class='struct'>PNL_INF</span>         </td><td  style="white-space:normal; text-align:left;" id="TBL-4-26-2"  
class="td11"><!--l. 35--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-26-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">+</span><span 
class="lmsy-10x-x-109">&#x221E;                    </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-27-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-27-1"  
class="td11"><a 
 id="dx1-17027"></a><span class='struct'>NAN</span>                </td><td  style="white-space:normal; text-align:left;" id="TBL-4-27-2"  
class="td11"><!--l. 36--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-4-27-3"  
class="td11">Not a Number                     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-28-"><td  style="white-space:nowrap; text-align:left;" id="TBL-4-28-1"  
class="td11">              </td></tr></table>                                                                   </div>
<!--l. 39--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.1.2   </span> <a 
 id="x1-180003.1.2"></a>A few macros</h5>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 41--><p class="noindent" ><a 
 id="dx1-18001"></a> <span 
class="ec-lmbx-10x-x-109">PNL_IS_ODD</span>&#x00A0;(int n)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span 
class="rm-lmr-10x-x-109">1 </span>if <span class='var'>n</span> is odd and <span 
class="rm-lmr-10x-x-109">0 </span>otherwise.
     </p></li>
     <li class="itemize">
     <!--l. 43--><p class="noindent" ><a 
 id="dx1-18002"></a> <span 
class="ec-lmbx-10x-x-109">PNL_IS_EVEN</span>&#x00A0;(int n)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span 
class="rm-lmr-10x-x-109">1 </span>if <span class='var'>n</span> is even and <span 
class="rm-lmr-10x-x-109">0 </span>otherwise.
     </p></li>
     <li class="itemize">
     <!--l. 45--><p class="noindent" ><a 
 id="dx1-18003"></a> <span 
class="ec-lmbx-10x-x-109">PNL_ALTERNATE</span>&#x00A0;(int n)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmsy-10x-x-109">-</span><span 
class="rm-lmr-10x-x-109">1)</span><sup><span class='var'><span 
class="lmmi-8">n</span></span></sup>.
     </p></li>
     <li class="itemize">
     <!--l. 47--><p class="noindent" ><a 
 id="dx1-18004"></a> <span 
class="ec-lmbx-10x-x-109">MIN</span>&#x00A0;(x,y)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the minimum of <span class='var'>x</span> and <span class='var'>y</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 49--><p class="noindent" ><a 
 id="dx1-18005"></a> <span 
class="ec-lmbx-10x-x-109">MAX</span>&#x00A0;(x,y)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the maximum of <span class='var'>x</span> and <span class='var'>y</span>.
     </p></li>
     <li class="itemize">
     <!--l. 51--><p class="noindent" ><a 
 id="dx1-18006"></a> <span 
class="ec-lmbx-10x-x-109">ABS</span>&#x00A0;(x)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the absolute value of <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 53--><p class="noindent" ><a 
 id="dx1-18007"></a> <span 
class="ec-lmbx-10x-x-109">PNL_SIGN</span>&#x00A0;(x)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the sign of <span class='var'>x</span> (-1 if x &#x003C; 0, 0 otheriwse).
     </p></li>
     <li class="itemize">
     <!--l. 55--><p class="noindent" ><a 
 id="dx1-18008"></a> <span 
class="ec-lmbx-10x-x-109">SQR</span>&#x00A0;(x)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'><span 
class="lmmi-10x-x-109">x</span><sup><span 
class="rm-lmr-8">2</span></sup></span>.
     </p></li>
     <li class="itemize">
     <!--l. 57--><p class="noindent" ><a 
 id="dx1-18009"></a> <span 
class="ec-lmbx-10x-x-109">CUB</span>&#x00A0;(x)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'><span 
class="lmmi-10x-x-109">x</span><sup><span 
class="rm-lmr-8">3</span></sup></span>.</p></li></ul>
<!--l. 61--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.1.3   </span> <a 
 id="x1-190003.1.3"></a>Classifying a floating&#8211;point number</h5>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 64--><p class="noindent" ><a 
 id="dx1-19001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_nan</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>NaN</span>
     </p></li>
     <li class="itemize">
     <!--l. 66--><p class="noindent" ><a 
 id="dx1-19002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_posinf</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>+ infinity</span>
     </p></li>
     <li class="itemize">
     <!--l. 68--><p class="noindent" ><a 
 id="dx1-19003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_neginf</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>- infinity</span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 70--><p class="noindent" ><a 
 id="dx1-19004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_isnan</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>+1</span> if <span class='var'>x=NaN</span>
     </p></li>
     <li class="itemize">
     <!--l. 72--><p class="noindent" ><a 
 id="dx1-19005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_isinf</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>+1</span> if <span class='var'>x=+Inf</span>, <span class='var'>-1</span> if <span class='var'>x=-Inf</span> and <span class='var'>0</span> otherwise.
     </p></li>
     <li class="itemize">
     <!--l. 75--><p class="noindent" ><a 
 id="dx1-19006"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_isfinite</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>1</span> if <span class='var'>x!=+-Inf</span></p></li></ul>
<!--l. 79--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.1.4   </span> <a 
 id="x1-200003.1.4"></a>Rouding a floating&#8211;point number</h5>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 81--><p class="noindent" ><a 
 id="dx1-20001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_itrunc</span></span>&#x00A0;(<span class='args'>double s</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function is similar to the <span class='var'>trunc</span> function (provided by the C library)
     but the result is typed as an integer instead of a double. Digits may be lost if <span class='var'>s</span> exceeds
     <span class='var'>MAX_INT</span>.
     </p></li>
     <li class="itemize">
     <!--l. 85--><p class="noindent" ><a 
 id="dx1-20002"></a> <span class='ret'>long int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ltrunc</span></span>&#x00A0;(<span class='args'>double s</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function is similar to the <span class='var'>trunc</span> function (provided by the C library)
     but the result is typed as a long integer instead of a double.
     </p></li>
     <li class="itemize">
     <!--l. 89--><p class="noindent" ><a 
 id="dx1-20003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_trunc</span></span>&#x00A0;(<span class='args'>double s</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the nearest integer not greater than the absolute value of <span class='var'>s</span>. This
     function is part of C99 as <span class='var'>trunc</span>.
     </p></li>
     <li class="itemize">
     <!--l. 92--><p class="noindent" ><a 
 id="dx1-20004"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_round</span></span>&#x00A0;(<span class='args'>double s</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the integral value nearest to x rounding half-way cases away from
     zero, regardless of the current rounding direction. This function is part of C99 as <span class='var'>round</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 96--><p class="noindent" ><a 
 id="dx1-20005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_iround</span></span>&#x00A0;(<span class='args'>double s</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function is similar to the <span class='var'>round</span> function (provided by the C library)
     but the result is typed as an integer instead of a double. Digits may be lost if <span class='var'>s</span> exceeds
     <span class='var'>MAX_INT</span>.
     </p></li>
     <li class="itemize">
     <!--l. 100--><p class="noindent" ><a 
 id="dx1-20006"></a> <span class='ret'>long int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_lround</span></span>&#x00A0;(<span class='args'>double s</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function is similar to the <span class='var'>round</span> function (provided by the C library)
     but the result is typed as a long integer instead of a double.</p></li></ul>
<!--l. 106--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.1.5   </span> <a 
 id="x1-210003.1.5"></a>Some standard mathematical functions</h5>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 108--><p class="noindent" ><a 
 id="dx1-21001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_fact</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>See <a 
href="#x1-13800014.4">pnl_sf_fact</a>
     </p></li>
     <li class="itemize">
     <!--l. 110--><p class="noindent" ><a 
 id="dx1-21002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_lgamma</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>See <a 
href="#x1-13800014.4">pnl_sf_log_gamma</a>
     </p></li>
     <li class="itemize">
     <!--l. 112--><p class="noindent" ><a 
 id="dx1-21003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tgamma</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>See <a 
href="#x1-13800014.4">pnl_sf_gamma</a>
     </p></li>
     <li class="itemize">
     <!--l. 114--><p class="noindent" ><a 
 id="dx1-21004"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_acosh</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>acosh(x)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 116--><p class="noindent" ><a 
 id="dx1-21005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_asinh</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>asinh(x)</span>.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 118--><p class="noindent" ><a 
 id="dx1-21006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_atanh</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>atanh(x)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 120--><p class="noindent" ><a 
 id="dx1-21007"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_log1p</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>log(1+x)</span> accurately for small values of <span class='var'>x</span>
     </p></li>
     <li class="itemize">
     <!--l. 122--><p class="noindent" ><a 
 id="dx1-21008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_expm1</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>exp(x)-1</span> accurately for small values of <span class='var'>x</span>
     </p></li>
     <li class="itemize">
     <!--l. 124--><p class="noindent" ><a 
 id="dx1-21009"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cosm1</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>cos(x)-1</span> accurately for small values of <span class='var'>x</span>
     </p></li>
     <li class="itemize">
     <!--l. 126--><p class="noindent" ><a 
 id="dx1-21010"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_pow_i</span></span>&#x00A0;(<span class='args'>double x, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">x^n</span></span></span> for an integer <span class='var'>n</span>.</p></li></ul>
<!--l. 130--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.1.6   </span> <a 
 id="x1-220003.1.6"></a>Comparison of floating&#8211;point numbers</h5>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 132--><p class="noindent" ><a 
 id="dx1-22001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_isequal_rel</span></span>&#x00A0;(<span class='args'>double x, double y, double relerr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compare two floating&#8211;point numbers up to a relative precision <span class='var'>relerr</span>
     </p></li>
     <li class="itemize">
     <!--l. 134--><p class="noindent" ><a 
 id="dx1-22002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_isequal_abs</span></span>&#x00A0;(<span class='args'>double x, double y, double abserr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compare two floating&#8211;point numbers up to an absolute precision <span class='var'>abserr</span>
     </p></li>
     <li class="itemize">
     <!--l. 136--><p class="noindent" ><a 
 id="dx1-22003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_isequal</span></span>&#x00A0;(<span class='args'>double x, double y, double relerr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Equivalent  to  <a 
href="#x1-220003.1.6">pnl_isequal_abs</a>  if  <span class='var'>|x|  &#x003C;  1</span>  and  to  <a 
href="#x1-220003.1.6">pnl_isequal_abs</a>
     otherwise.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 2--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">3.2   </span> <a 
 id="x1-230003.2"></a>Complex numbers</h4>
<!--l. 3--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.1   </span> <a 
 id="x1-240003.2.1"></a>Overview</h5>
<!--l. 5--><p class="noindent" >The complex type and related functions are defined in the header <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_complex.h</span></span></span>.<br 
class="newline" />
</p><!--l. 8--><p class="noindent" >The first native implementation of complex numbers in the C language appeared in C99, which is
unfortunately not available on all platforms. For this reason, we provide here an implementation of
complex numbers.
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-14">
typedef&#x00A0;struct&#x00A0;{
&#x00A0;&#x00A0;&#x00A0;&#x00A0;double&#x00A0;r;&#x00A0;/*!&#x003C;&#x00A0;real&#x00A0;part&#x00A0;*/
&#x00A0;&#x00A0;&#x00A0;&#x00A0;double&#x00A0;i;&#x00A0;/*!&#x003C;&#x00A0;imaginary&#x00A0;part&#x00A0;*/
}&#x00A0;dcomplex;
</pre>
<!--l. 18--><p class="nopar" >
</p><!--l. 21--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.2   </span> <a 
 id="x1-250003.2.2"></a>Constants</h5>
<!--l. 23--><p class="noindent" ><!--tex4ht:inline--></p><div class="tabular"> <table id="TBL-5" class="tabular" 
 
><colgroup id="TBL-5-1g"><col 
id="TBL-5-1" /><col 
id="TBL-5-2" /><col 
id="TBL-5-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-5-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-1"  
class="td11"><a 
 id="dx1-25001"></a><span class='struct'>CZERO</span></td><td  style="white-space:normal; text-align:left;" id="TBL-5-1-2"  
class="td11"><!--l. 24--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">0 </span>as a complex number     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-1"  
class="td11"><a 
 id="dx1-25002"></a><span class='struct'>CONE</span>   </td><td  style="white-space:normal; text-align:left;" id="TBL-5-2-2"  
class="td11"><!--l. 25--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-3"  
class="td11"><span 
class="rm-lmr-10x-x-109">1 </span>as a complex number     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-1"  
class="td11"><a 
 id="dx1-25003"></a><span class='struct'>CI</span>        </td><td  style="white-space:normal; text-align:left;" id="TBL-5-3-2"  
class="td11"><!--l. 26--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-3"  
class="td11"><span 
class="lmmi-10x-x-109">I </span>the unit complex number</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-5-4-1"  
class="td11">       </td></tr></table>                                                                          </div>
<!--l. 29--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.3   </span> <a 
 id="x1-260003.2.3"></a>Functions</h5>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 31--><p class="noindent" ><a 
 id="dx1-26001"></a> <span class='ret'>double, double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">CMPLX</span></span>&#x00A0;(<span class='args'>dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>z.r, z.i</span>
     </p></li>
     <li class="itemize">
     <!--l. 34--><p class="noindent" ><a 
 id="dx1-26002"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Complex</span></span>&#x00A0;(<span class='args'>double x, double y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>x + i y</span>
     </p></li>
     <li class="itemize">
     <!--l. 37--><p class="noindent" ><a 
 id="dx1-26003"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Complex_polar</span></span>&#x00A0;(<span class='args'>double r, double theta</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> r exp(i theta) </span>
     </p></li>
     <li class="itemize">
     <!--l. 40--><p class="noindent" ><a 
 id="dx1-26004"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Creal</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="rm-lmr-10x-x-109">R(</span><span 
class="lmmi-10x-x-109">z</span><span 
class="rm-lmr-10x-x-109">)</span>
     </p></li>
     <li class="itemize">
     <!--l. 43--><p class="noindent" ><a 
 id="dx1-26005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cimag</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="rm-lmr-10x-x-109">Im</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">z</span><span 
class="rm-lmr-10x-x-109">)</span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 46--><p class="noindent" ><a 
 id="dx1-26006"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cadd</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> z+b </span>
     </p></li>
     <li class="itemize">
     <!--l. 49--><p class="noindent" ><a 
 id="dx1-26007"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">CRadd</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, double b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> z+b </span>
     </p></li>
     <li class="itemize">
     <!--l. 52--><p class="noindent" ><a 
 id="dx1-26008"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">RCadd</span></span>&#x00A0;(<span class='args'>double b, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> b+z </span>
     </p></li>
     <li class="itemize">
     <!--l. 55--><p class="noindent" ><a 
 id="dx1-26009"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Csub</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> z-b </span>
     </p></li>
     <li class="itemize">
     <!--l. 58--><p class="noindent" ><a 
 id="dx1-26010"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">CRsub</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, double b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> z-b </span>
     </p></li>
     <li class="itemize">
     <!--l. 61--><p class="noindent" ><a 
 id="dx1-26011"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">RCsub</span></span>&#x00A0;(<span class='args'>double b, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> b-z </span>
     </p></li>
     <li class="itemize">
     <!--l. 64--><p class="noindent" ><a 
 id="dx1-26012"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cminus</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> -z </span>
     </p></li>
     <li class="itemize">
     <!--l. 67--><p class="noindent" ><a 
 id="dx1-26013"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cmul</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> z*b </span>
     </p></li>
     <li class="itemize">
     <!--l. 70--><p class="noindent" ><a 
 id="dx1-26014"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">RCmul</span></span>&#x00A0;(<span class='args'>double x, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> x*z </span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 73--><p class="noindent" ><a 
 id="dx1-26015"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">CRmul</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> z * x </span>
     </p></li>
     <li class="itemize">
     <!--l. 76--><p class="noindent" ><a 
 id="dx1-26016"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">CRdiv</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> z/x </span>
     </p></li>
     <li class="itemize">
     <!--l. 79--><p class="noindent" ><a 
 id="dx1-26017"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">RCdiv</span></span>&#x00A0;(<span class='args'>double x, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> x/z </span>
     </p></li>
     <li class="itemize">
     <!--l. 82--><p class="noindent" ><a 
 id="dx1-26018"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Conj</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class="overline"><span 
class="lmmi-10x-x-109">z</span></span>
     </p></li>
     <li class="itemize">
     <!--l. 85--><p class="noindent" ><a 
 id="dx1-26019"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cinv</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> 1/z </span>
     </p></li>
     <li class="itemize">
     <!--l. 88--><p class="noindent" ><a 
 id="dx1-26020"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cdiv</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> w</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> z/w </span>
     </p></li>
     <li class="itemize">
     <!--l. 91--><p class="noindent" ><a 
 id="dx1-26021"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Csqr_norm</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="rm-lmr-10x-x-109">Re</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">z</span><span 
class="rm-lmr-10x-x-109">)</span><sup><span 
class="rm-lmr-8">2</span></sup> <span 
class="rm-lmr-10x-x-109">+</span> <span 
class="rm-lmr-10x-x-109">im</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">z</span><span 
class="rm-lmr-10x-x-109">)</span><sup><span 
class="rm-lmr-8">2</span></sup>
     </p></li>
     <li class="itemize">
     <!--l. 94--><p class="noindent" ><a 
 id="dx1-26022"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cabs</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>|z|</span>
     </p></li>
     <li class="itemize">
     <!--l. 97--><p class="noindent" ><a 
 id="dx1-26023"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Csqrt</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> sqrt(z) </span>, square root (with positive real part)
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 100--><p class="noindent" ><a 
 id="dx1-26024"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Clog</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>log(z)</span>
     </p></li>
     <li class="itemize">
     <!--l. 103--><p class="noindent" ><a 
 id="dx1-26025"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cexp</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> exp(z) </span>
     </p></li>
     <li class="itemize">
     <!--l. 106--><p class="noindent" ><a 
 id="dx1-26026"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">CIexp</span></span>&#x00A0;(<span class='args'>double t</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> exp( it ) </span>
     </p></li>
     <li class="itemize">
     <!--l. 109--><p class="noindent" ><a 
 id="dx1-26027"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cpow</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> w</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">z</span><sup><span 
class="lmmi-8">w</span></sup>, power function
     </p></li>
     <li class="itemize">
     <!--l. 112--><p class="noindent" ><a 
 id="dx1-26028"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cpow_real</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">z</span><sup><span 
class="lmmi-8">x</span></sup>, power function
     </p></li>
     <li class="itemize">
     <!--l. 115--><p class="noindent" ><a 
 id="dx1-26029"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Ccos</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> cos(g)</span>
     </p></li>
     <li class="itemize">
     <!--l. 118--><p class="noindent" ><a 
 id="dx1-26030"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Csin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>sin(g)</span>
     </p></li>
     <li class="itemize">
     <!--l. 121--><p class="noindent" ><a 
 id="dx1-26031"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Ctan</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>tan(z)</span>
     </p></li>
     <li class="itemize">
     <!--l. 124--><p class="noindent" ><a 
 id="dx1-26032"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Ccotan</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>cotan(z)</span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 127--><p class="noindent" ><a 
 id="dx1-26033"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Ccosh</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> cosh(g)</span>
     </p></li>
     <li class="itemize">
     <!--l. 130--><p class="noindent" ><a 
 id="dx1-26034"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Csinh</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>sinh(g)</span>
     </p></li>
     <li class="itemize">
     <!--l. 133--><p class="noindent" ><a 
 id="dx1-26035"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Ctanh</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="rm-lmr-10x-x-109">tanh</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">z</span><span 
class="rm-lmr-10x-x-109">) =</span> <img 
src="pnl-manual6x.png" alt="   -2z
11-+ee-2z"  class="frac" align="middle" />
     </p></li>
     <li class="itemize">
     <!--l. 136--><p class="noindent" ><a 
 id="dx1-26036"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Ccotanh</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="rm-lmr-10x-x-109">cotanh</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">z</span><span 
class="rm-lmr-10x-x-109">) =</span> <img 
src="pnl-manual7x.png" alt="11+-ee--22zz"  class="frac" align="middle" />
     </p></li>
     <li class="itemize">
     <!--l. 139--><p class="noindent" ><a 
 id="dx1-26037"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Carg</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>arg(z) </span>
     </p></li>
     <li class="itemize">
     <!--l. 142--><p class="noindent" ><a 
 id="dx1-26038"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Ctgamma</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> Gamma(z)</span>, the Gamma function
     </p></li>
     <li class="itemize">
     <!--l. 145--><p class="noindent" ><a 
 id="dx1-26039"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Clgamma</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'> log(Gamma (z))</span>, the logarithm of the Gamma function
     </p></li>
     <li class="itemize">
     <!--l. 148--><p class="noindent" ><a 
 id="dx1-26040"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">Cprintf</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a complex number on the standard output
     </p></li>
     <li class="itemize">
     <!--l. 151--><p class="noindent" ><a 
 id="dx1-26041"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_isequal_abs</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> x, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> y, double abserr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two complex numbers are equal up to an absolute error <span class='var'>abserr</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 154--><p class="noindent" ><a 
 id="dx1-26042"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_isequal_rel</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> x, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> y, double relerr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two complex numbers are equal up to a relative error <span class='var'>relerr</span>.
     </p></li>
     <li class="itemize">
     <!--l. 157--><p class="noindent" ><a 
 id="dx1-26043"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_isequal</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> x, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> y, double err</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two complex numbers using one of the above functions depending
     on the magnitude of <span class='var'>|y|</span>.
</p>
     </li></ul>
<!--l. 163--><p class="noindent" >Most algebraic operations on complex numbers are implemented using the following naming for the
functions </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 166--><p class="noindent" >All these function names begin in <span 
class="ec-lmtt-10x-x-109">C_op_</span>,
     </p></li>
     <li class="itemize">
     <!--l. 167--><p class="noindent" >The small letters <span 
class="ec-lmtt-10x-x-109">a, b </span>denote two complex numbers whereas <span 
class="ec-lmtt-10x-x-109">d </span>is a real number,
     </p></li>
     <li class="itemize">
     <!--l. 168--><p class="noindent" >The letter <span 
class="ec-lmtt-10x-x-109">i </span>denotes the multiplication by the pure imagniary number <span 
class="lmmi-10x-x-109"><img 
src="lmmi10-7b.png" alt="i" class="10-109x-x-7b" /></span>,
     </p></li>
     <li class="itemize">
     <!--l. 170--><p class="noindent" >The letter <span 
class="ec-lmtt-10x-x-109">c </span>indicates that the next coming number is conjugated.
     </p></li>
     <li class="itemize">
     <!--l. 171--><p class="noindent" >The letters <span 
class="ec-lmtt-10x-x-109">p, m </span>denote the two standard operations <span 
class="ec-lmri-10x-x-109">plus </span>and <span 
class="ec-lmri-10x-x-109">minus </span>respectively.</p></li></ul>
<!--l. 174--><p class="noindent" >For example C_op_idamcb is <span 
class="lmmi-10x-x-109"><img 
src="lmmi10-7b.png" alt="i" class="10-109x-x-7b" />d</span><img 
src="pnl-manual8x.png" alt="(   -)
 a- b"  class="left" align="middle" />. So functions are : </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 177--><p class="noindent" ><a 
 id="dx1-26044"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_apib</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">a </span><span 
class="rm-lmr-10x-x-109">+ </span><span 
class="lmmi-10x-x-109"><img 
src="lmmi10-7b.png" alt="i" class="10-109x-x-7b" />b</span>.
     </p></li>
     <li class="itemize">
     <!--l. 179--><p class="noindent" ><a 
 id="dx1-26045"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_apcb</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">a </span><span 
class="rm-lmr-10x-x-109">+</span><span class="overline"> <span 
class="lmmi-10x-x-109">b</span></span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 181--><p class="noindent" ><a 
 id="dx1-26046"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_amcb</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">a </span><span 
class="lmsy-10x-x-109">-</span><span class="overline"><span 
class="lmmi-10x-x-109">b</span></span>.
     </p></li>
     <li class="itemize">
     <!--l. 183--><p class="noindent" ><a 
 id="dx1-26047"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_amib</span></span>&#x00A0;(<span class='args'><a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>a - i b</span>
     </p></li>
     <li class="itemize">
     <!--l. 186--><p class="noindent" ><a 
 id="dx1-26048"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_dapb</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">d</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a </span><span 
class="rm-lmr-10x-x-109">+ </span><span 
class="lmmi-10x-x-109">b</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 189--><p class="noindent" ><a 
 id="dx1-26049"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_damb</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">d</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">b</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 192--><p class="noindent" ><a 
 id="dx1-26050"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_dapib</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">d</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a </span><span 
class="rm-lmr-10x-x-109">+ </span><span 
class="lmmi-10x-x-109"><img 
src="lmmi10-7b.png" alt="i" class="10-109x-x-7b" />b</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 195--><p class="noindent" ><a 
 id="dx1-26051"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_damib</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">d</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109"><img 
src="lmmi10-7b.png" alt="i" class="10-109x-x-7b" />b</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 198--><p class="noindent" ><a 
 id="dx1-26052"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_dapcb</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">d</span><img 
src="pnl-manual9x.png" alt="(   -)
 a+ b"  class="left" align="middle" />.
     </p></li>
     <li class="itemize">
     <!--l. 201--><p class="noindent" ><a 
 id="dx1-26053"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_damcb</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">d</span><img 
src="pnl-manual10x.png" alt="(   -)
 a- b"  class="left" align="middle" />.
     </p></li>
     <li class="itemize">
     <!--l. 204--><p class="noindent" ><a 
 id="dx1-26054"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_idapb</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109"><img 
src="lmmi10-7b.png" alt="i" class="10-109x-x-7b" />d</span><img 
src="pnl-manual11x.png" alt="(a + b)"  class="left" align="middle" />.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 207--><p class="noindent" ><a 
 id="dx1-26055"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_idamb</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109"><img 
src="lmmi10-7b.png" alt="i" class="10-109x-x-7b" />d</span><img 
src="pnl-manual12x.png" alt="(a - b)"  class="left" align="middle" />.
     </p></li>
     <li class="itemize">
     <!--l. 210--><p class="noindent" ><a 
 id="dx1-26056"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_idapcb</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109"><img 
src="lmmi10-7b.png" alt="i" class="10-109x-x-7b" />d</span><img 
src="pnl-manual13x.png" alt="(    -)
 a + b"  class="left" align="middle" />.
     </p></li>
     <li class="itemize">
     <!--l. 213--><p class="noindent" ><a 
 id="dx1-26057"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">C_op_idamcb</span></span>&#x00A0;(<span class='args'>double d, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> a, <a 
href="#x1-240003.2.1"><span class='struct'>dcomplex</span></a> b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109"><img 
src="lmmi10-7b.png" alt="i" class="10-109x-x-7b" />d</span><img 
src="pnl-manual14x.png" alt="(     )
 a - b"  class="left" align="middle" />.</p></li></ul>
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-270004"></a>Linear Algebra</h3>
<!--l. 4--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.1   </span> <a 
 id="x1-280004.1"></a>Vectors</h4>
<!--l. 5--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.1.1   </span> <a 
 id="x1-290004.1.1"></a>Overview</h5>
<!--l. 7--><p class="noindent" >The structures and functions related to vectors are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_vector.h</span></span></span>.
</p><!--l. 11--><p class="noindent" >Vectors are declared for several basic types : double, int, and dcomplex. In the following
declarations, <span 
class="ec-lmtt-10x-x-109">BASE </span>must be replaced by one the previous types and the corresponding vector
structures are respectively named PnlVect, PnlVectInt, PnlVectComplex <a 
 id="dx1-29001"></a><a 
 id="dx1-29002"></a><a 
 id="dx1-29003"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-15">
typedef&#x00A0;struct&#x00A0;_PnlVect&#x00A0;{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVect&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;vector&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
}&#x00A0;PnlVect;

typedef&#x00A0;struct&#x00A0;_PnlVectInt&#x00A0;{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVectInt&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;vector&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
}&#x00A0;PnlVectInt;

typedef&#x00A0;struct&#x00A0;_PnlVectComplex&#x00A0;{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVectComplex&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;vector&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;&#x00A0;dcomplex&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
}&#x00A0;PnlVectComplex;
</pre>
<!--l. 53--><p class="nopar" ><span class='var'>size</span> is the size of the vector, <span class='var'>array</span> is a pointer containing the data and <span class='var'>owner</span> is an integer to know
if the vector owns its <span class='var'>array</span> pointer (<span class='var'>owner=1</span>) or shares it with another structure (<span class='var'>owner=0</span>).
<span class='var'>mem_size</span> is the number of elements the vector can hold at most.
</p><!--l. 59--><p class="noindent" >
                                                                                    

                                                                                    
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.1.2   </span> <a 
 id="x1-300004.1.2"></a>Functions</h5>
<!--l. 61--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-31000"></a><span 
class="ec-lmbx-10x-x-109">General functions</span></span>
These functions exist for all types of vector no matter what the basic type is. The following
conventions are used to name functions operating on vectors. Here is the table of prefixes used for
the different basic types.
</p>
<div class="center" 
>
<!--l. 66--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-6" class="tabular" 
 
><colgroup id="TBL-6-1g"><col 
id="TBL-6-1" /><col 
id="TBL-6-2" /><col 
id="TBL-6-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-6-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-1"  
class="td11">type      </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-2"  
class="td11">prefix                 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-3"  
class="td11">BASE    </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-1"  
class="td11">double    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-2"  
class="td11">pnl_vect             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-3"  
class="td11">double    </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-1"  
class="td11">int         </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-2"  
class="td11">pnl_vect_int       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-3"  
class="td11">int         </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-1"  
class="td11">dcomplex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-2"  
class="td11">pnl_vect_complex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-3"  
class="td11">dcomplex</td></tr></table>                                           </div></div>
<!--l. 78--><p class="noindent" >In this paragraph, we present the functions operating on <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> which exist for all types. To
deduce the prototypes of these functions for other basic types, one must replace <span 
class="ec-lmtt-10x-x-109">pnl_vect </span>and
<span 
class="ec-lmtt-10x-x-109">double </span>according the above table.
</p>
<!--l. 82--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-32000"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
There are no special functions to access the size of a vector, instead the field <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">size</span></span></span> should be
accessed directly.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 88--><p class="noindent" ><a 
 id="dx1-32001"></a><a 
 id="x1-32000doc"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> of size 0.
     </p></li>
     <li class="itemize">
     <!--l. 90--><p class="noindent" ><a 
 id="dx1-32002"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create</span></span>&#x00A0;(<span class='args'>int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> pointer.
     </p></li>
     <li class="itemize">
     <!--l. 92--><p class="noindent" ><a 
 id="dx1-32003"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_zero</span></span>&#x00A0;(<span class='args'>int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> pointer and sets it to zero.
     </p></li>
     <li class="itemize">
     <!--l. 94--><p class="noindent" ><a 
 id="dx1-32004"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_scalar</span></span>&#x00A0;(<span class='args'>int size, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> pointer and sets all elements t <span class='var'>x</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 98--><p class="noindent" ><a 
 id="dx1-32005"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_ptr</span></span>&#x00A0;(<span class='args'>int size, const double <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> pointer and copies <span class='var'>x</span> to <span class='var'>array</span>.
     </p></li>
     <li class="itemize">
     <!--l. 102--><p class="noindent" ><a 
 id="dx1-32006"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_mat</span></span>&#x00A0;(<span class='args'> const PnlMat *M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> pointer of size <span class='var'>M-&#x003E;mn</span> and copy the content of <span class='var'>M</span>
     row wise.
     </p></li>
     <li class="itemize">
     <!--l. 106--><p class="noindent" ><a 
 id="dx1-32007"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_list</span></span>&#x00A0;(<span class='args'>int size, ...</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create  a  new  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  pointer  of  length  <span class='var'>size</span>  filled  with  the  extra
     arguments  passed  to  the  function.  The  number  of  extra  arguments  passed  must
     be  equal  to  <span class='var'>size</span>  and  they  must  be  of  the  type  BASE.  Example:  To  create  a
     vector  {1.,  2.},  you  should  enter  pnl_vect_create_from_list(2,  1.0,  2.0)  and  NOT
     pnl_vect_create_from_list(2,  1.0,  2)  or  pnl_vect_create_from_list(2,  1,  2.0).  Be
     aware that this cannot be checked inside the function.
     </p></li>
     <li class="itemize">
     <!--l. 113--><p class="noindent" ><a 
 id="dx1-32008"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_file</span></span>&#x00A0;(<span class='args'>const char <span 
class="ts1-lmr10-x-x-109">*</span>file</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Read a vector from a file and creates the corresponding <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> . The
     data might be stored as a row or column vector. Entries can be separated by spaces,
     tabs, commas or semicolons. Anything after a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">#</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">%</span></span></span> is ignored up to the end of the
     line.
     </p></li>
     <li class="itemize">
     <!--l. 118--><p class="noindent" ><a 
 id="dx1-32009"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This is a copying constructor. It creates a copy of a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 121--><p class="noindent" ><a 
 id="dx1-32010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> . <span class='var'>clone</span> must be an already existing <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> . It is resized
     to match the size of <span class='var'>v</span> and the data are copied. Future modifications to <span class='var'>v</span> will not affect
     <span class='var'>clone</span>.
     </p></li>
     <li class="itemize">
     <!--l. 128--><p class="noindent" ><a 
 id="dx1-32011"></a>   <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_subvect_with_ind</span></span>&#x00A0;(<span class='args'>const   <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>V,   const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>ind</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new vector containing <span class='var'>V(ind(:))</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 132--><p class="noindent" ><a 
 id="dx1-32012"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_extract_subvect_with_ind</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>V_sub,  const  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>V, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>ind</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>V_sub = V(ind(:))</span>.
     </p></li>
     <li class="itemize">
     <!--l. 136--><p class="noindent" ><a 
 id="dx1-32013"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_subvect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int i, int len</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new vector containing <span class='var'>V(i:i+len-1)</span>. The elements are copied.
     </p></li>
     <li class="itemize">
     <!--l. 141--><p class="noindent" ><a 
 id="dx1-32014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_extract_subvect</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V_sub, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int i, int
     len</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>V_sub = V(i:i+len-1)</span>. The elements are copied.
     </p></li>
     <li class="itemize">
     <!--l. 146--><p class="noindent" ><a 
 id="dx1-32015"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_set_subblock</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>dest, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set <span class='var'>dest[i:] = src</span>.
     </p></li>
     <li class="itemize">
     <!--l. 149--><p class="noindent" ><a 
 id="dx1-32016"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> pointer and set the data pointer to NULL
     </p></li>
     <li class="itemize">
     <!--l. 151--><p class="noindent" ><a 
 id="dx1-32017"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_array</span></span>&#x00A0;(<span class='args'>const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> containing the data <span class='var'>x</span>. No copy is made. It is just a
     container.
     </p></li>
     <li class="itemize">
     <!--l. 156--><p class="noindent" ><a 
 id="dx1-32018"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_subvect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int s</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> containing <span class='var'>x(i:i+s-1)</span>. No copy is made. It is just a
     container. The returned <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> has <span class='var'>size=s</span> and <span class='var'>owner=0</span>.
     </p></li>
     <li class="itemize">
     <!--l. 162--><p class="noindent" ><a 
 id="dx1-32019"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_subvect_with_last</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> containing <span class='var'>x(i:j)</span>. No copy is made. It is just a container.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 166--><p class="noindent" ><a 
 id="dx1-32020"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> (not a pointer) whose array is the row wise array of <span class='var'>M</span>.
     The new vector shares its data with the matrix <span class='var'>M</span>, which means that any modification
     to one of them will affect the other.</p></li></ul>
<!--l. 174--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-33000"></a><span 
class="ec-lmbx-10x-x-109">Resizing vectors</span></span> </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 176--><p class="noindent" ><a 
 id="dx1-33001"></a><a 
 id="x1-33000doc"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> . It copies as much of the old data to fit in the resized
     object.
     </p></li>
     <li class="itemize">
     <!--l. 179--><p class="noindent" ><a 
 id="dx1-33002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_resize_from_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> . Copy as much of the old data as possible and fill the
     new cells with <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 182--><p class="noindent" ><a 
 id="dx1-33003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_resize_from_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size, double <span 
class="ts1-lmr10-x-x-109">*</span>t</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> and uses <span class='var'>t</span> to fill the vector. <span class='var'>t</span> must be of size <span class='var'>size</span>.</p></li></ul>
<!--l. 188--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-34000"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements</span></span>
If it is supported by the compiler, the following functions are declared inline. To speed up these
functions, you can define the macro <span 
class="ec-lmtt-10x-x-109">PNL_RANGE_CHECK_OFF</span>, see Section&#x00A0;1.3.2 for an
explanation.
</p><!--l. 194--><p class="noindent" >Accessing elements of a vector is faster using the following macros </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 196--><p class="noindent" ><a 
 id="dx1-34001"></a><a 
 id="x1-34000doc"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>v[i]</span> for reading, eg. <span class='var'>x=GET(v,i)</span>
     </p></li>
     <li class="itemize">
     <!--l. 198--><p class="noindent" ><a 
 id="dx1-34002"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET_INT</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-34000doc">GET</a> but for an integer vector.
     </p></li>
     <li class="itemize">
     <!--l. 200--><p class="noindent" ><a 
 id="dx1-34003"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET_COMPLEX</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-34000doc">GET</a> but for a complex vector.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 202--><p class="noindent" ><a 
 id="dx1-34004"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>v[i]</span> as a lvalue for writing, eg. <span class='var'>LET(v,i)=x</span>
     </p></li>
     <li class="itemize">
     <!--l. 205--><p class="noindent" ><a 
 id="dx1-34005"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET_INT</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-34000doc">LET</a> but for an integer vector.
     </p></li>
     <li class="itemize">
     <!--l. 207--><p class="noindent" ><a 
 id="dx1-34006"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET_COMPLEX</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-34000doc">LET</a> but for a complex vector.</p></li></ul>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 212--><p class="noindent" ><a 
 id="dx1-34007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_set</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set v[i]=x.
     </p></li>
     <li class="itemize">
     <!--l. 214--><p class="noindent" ><a 
 id="dx1-34008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the value of v[i].
     </p></li>
     <li class="itemize">
     <!--l. 216--><p class="noindent" ><a 
 id="dx1-34009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address of v[i].
     </p></li>
     <li class="itemize">
     <!--l. 218--><p class="noindent" ><a 
 id="dx1-34010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_set_all</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements to x.
     </p></li>
     <li class="itemize">
     <!--l. 220--><p class="noindent" ><a 
 id="dx1-34011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_set_zero</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements to zero.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 225--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-35000"></a><span 
class="ec-lmbx-10x-x-109">Printing vector</span></span> </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 227--><p class="noindent" ><a 
 id="dx1-35001"></a><a 
 id="x1-35000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> as a column vector
     </p></li>
     <li class="itemize">
     <!--l. 229--><p class="noindent" ><a 
 id="dx1-35002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> in file <span class='var'>fic</span> as a column vector. The file can be read by
     <a 
href="#x1-32000doc">pnl_vect_create_from_file</a>.
     </p></li>
     <li class="itemize">
     <!--l. 232--><p class="noindent" ><a 
 id="dx1-35003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_print_asrow</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> as a row vector
     </p></li>
     <li class="itemize">
     <!--l. 234--><p class="noindent" ><a 
 id="dx1-35004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_fprint_asrow</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print  a  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  in  file  <span class='var'>fic</span>  as  a  row  vector.  The  file  can  be  read  by
     <a 
href="#x1-32000doc">pnl_vect_create_from_file</a>.
     </p></li>
     <li class="itemize">
     <!--l. 237--><p class="noindent" ><a 
 id="dx1-35005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_print_nsp</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a vector to the standard output in a format compatible with Nsp.
     </p></li>
     <li class="itemize">
     <!--l. 240--><p class="noindent" ><a 
 id="dx1-35006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_fprint_nsp</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a vector to a file in a format compatible with Nsp.</p></li></ul>
<!--l. 245--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-36000"></a><span 
class="ec-lmbx-10x-x-109">Applying external operation to vectors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 248--><p class="noindent" ><a 
 id="dx1-36001"></a><a 
 id="x1-36000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minus</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place unary minus
     </p></li>
     <li class="itemize">
     <!--l. 250--><p class="noindent" ><a 
 id="dx1-36002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector scalar addition
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 252--><p class="noindent" ><a 
 id="dx1-36003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector scalar substraction
     </p></li>
     <li class="itemize">
     <!--l. 254--><p class="noindent" ><a 
 id="dx1-36004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector scalar multiplication
     </p></li>
     <li class="itemize">
     <!--l. 256--><p class="noindent" ><a 
 id="dx1-36005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector scalar division</p></li></ul>
<!--l. 260--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-37000"></a><span 
class="ec-lmbx-10x-x-109">Element wise operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 263--><p class="noindent" ><a 
 id="dx1-37001"></a><a 
 id="x1-37000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_plus_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector vector addition
     </p></li>
     <li class="itemize">
     <!--l. 267--><p class="noindent" ><a 
 id="dx1-37002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minus_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector vector substraction
     </p></li>
     <li class="itemize">
     <!--l. 271--><p class="noindent" ><a 
 id="dx1-37003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_inv_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term vector inversion
     </p></li>
     <li class="itemize">
     <!--l. 274--><p class="noindent" ><a 
 id="dx1-37004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_div_vect_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term vector division
     </p></li>
     <li class="itemize">
     <!--l. 278--><p class="noindent" ><a 
 id="dx1-37005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_mult_vect_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector vector term by term multiplication
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 282--><p class="noindent" ><a 
 id="dx1-37006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_map</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs)</span>
     </p></li>
     <li class="itemize">
     <!--l. 286--><p class="noindent" ><a 
 id="dx1-37007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_map_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs)</span>
     </p></li>
     <li class="itemize">
     <!--l. 289--><p class="noindent" ><a 
 id="dx1-37008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_map_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs1, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double, double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs1, rhs2)</span>
     </p></li>
     <li class="itemize">
     <!--l. 294--><p class="noindent" ><a 
 id="dx1-37009"></a>       <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_map_vect_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>       <span 
class="ts1-lmr10-x-x-109">*</span>lhs,       <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>       <span 
class="ts1-lmr10-x-x-109">*</span>rhs,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double,double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs,rhs)</span>
     </p></li>
     <li class="itemize">
     <!--l. 298--><p class="noindent" ><a 
 id="dx1-37010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_axpby</span></span>&#x00A0;(<span class='args'>double a, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double b, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>y : = a x + b y</span>. When <span class='var'>b==0</span>, the content of <span class='var'>y</span> is not used on
     input and instead <span class='var'>y</span> is resized to match <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 303--><p class="noindent" ><a 
 id="dx1-37011"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_sum</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the sum of all the elements of a vector
     </p></li>
     <li class="itemize">
     <!--l. 306--><p class="noindent" ><a 
 id="dx1-37012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_cumsum</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the cumulative sum of all the elements of a vector. The original
     vector is modified
     </p></li>
     <li class="itemize">
     <!--l. 310--><p class="noindent" ><a 
 id="dx1-37013"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_prod</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the product of all the elements of a vector
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 313--><p class="noindent" ><a 
 id="dx1-37014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_cumprod</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the cumulative product of all the elements of a vector. The
     original vector is modified</p></li></ul>
<!--l. 318--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-38000"></a><span 
class="ec-lmbx-10x-x-109">Scalar products and norms</span></span> </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 320--><p class="noindent" ><a 
 id="dx1-38001"></a><a 
 id="x1-38000doc"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_norm_two</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the two norm of a vector
     </p></li>
     <li class="itemize">
     <!--l. 323--><p class="noindent" ><a 
 id="dx1-38002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_norm_one</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the one norm of a vector
     </p></li>
     <li class="itemize">
     <!--l. 326--><p class="noindent" ><a 
 id="dx1-38003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_norm_infty</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the infinity norm of a vector
     </p></li>
     <li class="itemize">
     <!--l. 329--><p class="noindent" ><a 
 id="dx1-38004"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_scalar_prod</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs1, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the scalar product between 2 vectors
     </p></li>
     <li class="itemize">
     <!--l. 332--><p class="noindent" ><a 
 id="dx1-38005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_cross</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the cross product of <span class='var'>x</span> and <span class='var'>y</span> and store the result in <span class='var'>lhs</span>. The
     vectors <span class='var'>x</span> and <span class='var'>y</span> must be of size 3 and FAIL is returned otherwise.
     </p></li>
     <li class="itemize">
     <!--l. 338--><p class="noindent" ><a 
 id="dx1-38006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_dist</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the distance between <span class='var'>x</span> and <span class='var'>y</span>, ie <img 
src="pnl-manual15x.png" alt="&#x2218; &#x2211;---------2-
    i|xi - yi|"  class="sqrt"  />.
</p>
     </li></ul>
<!--l. 344--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-39000"></a><span 
class="ec-lmbx-10x-x-109">Comparison functions</span></span>
</p>
                                                                                    

                                                                                    
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 347--><p class="noindent" ><a 
 id="dx1-39001"></a><a 
 id="x1-39000doc"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_isequal</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V1, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V2, double err</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two vectors are equal up to <span class='var'>err</span> component&#8211;wise. The error <span class='var'>err</span>
     is either relative or absolute depending on the magnitude of the components. Return
     <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </p></li>
     <li class="itemize">
     <!--l. 349--><p class="noindent" ><a 
 id="dx1-39002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_isequal_abs</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V1, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V2, double abserr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test   if   two   vectors   are   equal   up   to   an   absolute   error   <span class='var'>abserr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </p></li>
     <li class="itemize">
     <!--l. 351--><p class="noindent" ><a 
 id="dx1-39003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_isequal_rel</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V1, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V2, double relerr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two vectors are equal up to a relative error <span class='var'>relerr</span> component&#8211;wise.
     Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </p></li>
     <li class="itemize">
     <!--l. 353--><p class="noindent" ><a 
 id="dx1-39004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_eq_all</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if all the components of <span class='var'>v</span> are equal to <span class='var'>x</span>. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.</p></li></ul>
<!--l. 358--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-40000"></a><span 
class="ec-lmbx-10x-x-109">Ordering functions</span></span> The following functions are not defined for PnlVectComplex because there is
no total ordering on Complex numbers
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 363--><p class="noindent" ><a 
 id="dx1-40001"></a><a 
 id="x1-40000doc"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_max</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the maximum of a a vector
     </p></li>
     <li class="itemize">
     <!--l. 366--><p class="noindent" ><a 
 id="dx1-40002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_min</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the minimum of a vector
     </p></li>
     <li class="itemize">
     <!--l. 369--><p class="noindent" ><a 
 id="dx1-40003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minmax</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>m, double <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the minimum and maximum of a vector which are returned in
     <span class='var'>m</span> and <span class='var'>M</span> respectively.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 373--><p class="noindent" ><a 
 id="dx1-40004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_min_index</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>m, int <span 
class="ts1-lmr10-x-x-109">*</span>im, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the minimum of a vector and its index stored in sets <span class='var'>m</span> and <span class='var'>im</span>
     respectively.
     </p></li>
     <li class="itemize">
     <!--l. 377--><p class="noindent" ><a 
 id="dx1-40005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_max_index</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>M, int <span 
class="ts1-lmr10-x-x-109">*</span>iM, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the maximum of a vector and its index stored in sets <span class='var'>m</span> and
     <span class='var'>im</span> respectively.
     </p></li>
     <li class="itemize">
     <!--l. 381--><p class="noindent" ><a 
 id="dx1-40006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minmax_index</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>m, double <span 
class="ts1-lmr10-x-x-109">*</span>M, int <span 
class="ts1-lmr10-x-x-109">*</span>im, int <span 
class="ts1-lmr10-x-x-109">*</span>iM, const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the minimum and maximum of a vector and the corresponding
     indices stored respectively in <span class='var'>m</span>, <span class='var'>M</span>, <span class='var'>im</span> and <span class='var'>iM</span>.
     </p></li>
     <li class="itemize">
     <!--l. 387--><p class="noindent" ><a 
 id="dx1-40007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_qsort</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, char order</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sort a vector using a quick sort algorithm according to <span class='var'>order</span> (<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;i&#8217;</span></span></span> for
     increasing or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;d&#8217;</span></span></span> for decreasing).
     </p></li>
     <li class="itemize">
     <!--l. 391--><p class="noindent" ><a 
 id="dx1-40008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_qsort_index</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> *index, char order</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sort a vector using a quick sort algorithm according to <span class='var'>order</span> (<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;i&#8217;</span></span></span> for
     increasing or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;d&#8217;</span></span></span> for decreasing ). On output, <span class='var'>index</span> contains the permutation used to
     sort the vector.
     </p></li>
     <li class="itemize">
     <!--l. 397--><p class="noindent" ><a 
 id="dx1-40009"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_find</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>ind, char <span 
class="ts1-lmr10-x-x-109">*</span>type, int(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double <span 
class="ts1-lmr10-x-x-109">*</span>t), &#x2026;</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>f</span> is a function taking a C array as argument and returning an integer. <span class='var'>type</span> is a
     string composed by the letters &#8217;r&#8217; and &#8217;v&#8217; and is used to describe the types of the arguments
     appearing after <span class='var'>f</span>. This function aims at simulating Scilab&#8217;s <span class='var'>find</span> function. Here are a
     few examples (capital letters are used for vectors and small letters for real values)
     </p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 406--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">ind</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;a</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;)</span></span></span>
                                                                                    

                                                                                    
</p>
          <pre class="verbatim" id="verbatim-16">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;isless&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)&#x00A0;{&#x00A0;return&#x00A0;t[0]&#x00A0;&#x003C;&#x00A0;t[1];&#x00A0;}
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_vect_find&#x00A0;(&#x00A0;ind,&#x00A0;"rv",&#x00A0;isless,&#x00A0;a,&#x00A0;X&#x00A0;);
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</pre>
          <!--l. 410--><p class="nopar" >
          </p></li>
          <li class="itemize">
          <!--l. 411--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">ind</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;Y)</span></span></span>
                                                                                    

                                                                                    
</p>
          <pre class="verbatim" id="verbatim-17">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;isless&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)&#x00A0;{&#x00A0;return&#x00A0;t[0]&#x00A0;&#x003C;=&#x00A0;t[1];&#x00A0;}
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_vect_find&#x00A0;(&#x00A0;ind,&#x00A0;"vv",&#x00A0;isless,&#x00A0;X,&#x00A0;Y&#x00A0;);
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</pre>
          <!--l. 415--><p class="nopar" >
          </p></li>
          <li class="itemize">
          <!--l. 416--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">ind</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;((a</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;X)</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&amp;&amp;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;Y))</span></span></span>
                                                                                    

                                                                                    
</p>
          <pre class="verbatim" id="verbatim-18">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;cmp&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;(t[0]&#x00A0;&#x003C;=&#x00A0;t[1])&#x00A0;&amp;&amp;&#x00A0;(t[1]&#x00A0;&#x003C;=&#x00A0;t[2]);
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_vect_find&#x00A0;(&#x00A0;ind,&#x00A0;"rvv",&#x00A0;cmp,&#x00A0;a,&#x00A0;X,&#x00A0;Y&#x00A0;);
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</pre>
          <!--l. 423--><p class="nopar" ></p></li></ul>
     <!--l. 425--><p class="noindent" ><span class='var'>ind</span> contains on exit the indices <span class='var'>i</span> for which the function <span class='var'>f</span> returned <span class='var'>1</span>. This function returns <span class='var'>OK</span>
     or <span class='var'>FAIL</span> when something went wrong (size mismatch between matrices, invalid string
     type).
</p>
     </li></ul>
<!--l. 432--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-41000"></a><span 
class="ec-lmbx-10x-x-109">Misc</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 435--><p class="noindent" ><a 
 id="dx1-41001"></a><a 
 id="x1-41000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_swap_elements</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Exchange <span class='var'>v[i]</span> and <span class='var'>v[j]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 438--><p class="noindent" ><a 
 id="dx1-41002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_reverse</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Perform a mirror operation on v. On output <span class='var'>v[i] = v[n-1-i]</span> for <span class='var'>i=0,&#x2026;,n-1</span>
     where <span class='var'>n</span> is the length of the vector.</p></li></ul>
<!--l. 444--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-42000"></a><span 
class="ec-lmbx-10x-x-109">Complex vector functions</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 447--><p class="noindent" ><a 
 id="dx1-42001"></a><a 
 id="x1-42000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_mult_double</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place multiplication by a double.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 451--><p class="noindent" ><a 
 id="dx1-42002"></a>   <span class='ret'>PnlVectComplex<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_create_from_array</span></span>&#x00A0;(<span class='args'>int   size,   const
     double <span 
class="ts1-lmr10-x-x-109">*</span>re, const double <span 
class="ts1-lmr10-x-x-109">*</span>im</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create  a  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a>  given  the  arrays  of  the  real  parts  <span class='var'>re</span>  and
     imaginary parts <span class='var'>im</span>.
     </p></li>
     <li class="itemize">
     <!--l. 455--><p class="noindent" ><a 
 id="dx1-42003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_split_in_array</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, double <span 
class="ts1-lmr10-x-x-109">*</span>re,
     double <span 
class="ts1-lmr10-x-x-109">*</span>im</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Split a complex vector into two C arrays : the real parts of the elements
     of <span class='var'>v</span> are stored into <span class='var'>re</span> and the imaginary parts into <span class='var'>im</span>.
     </p></li>
     <li class="itemize">
     <!--l. 460--><p class="noindent" ><a 
 id="dx1-42004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_split_in_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>re,
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>im</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Split a complex vector into two <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> &#8217;s : the real parts of the elements
     of <span class='var'>v</span> are stored into <span class='var'>re</span> and the imaginary parts into <span class='var'>im</span>.</p></li></ul>
<!--l. 467--><p class="noindent" >There exist functions to directly access the real or imaginary parts of an element of a complex
vector. These functions also have inlined versions that are used if the variable <span class='var'>HAVE_INLINE</span> was
declared at compilation time.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 472--><p class="noindent" ><a 
 id="dx1-42005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_get_real</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the real part of <span class='var'>v[i]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 476--><p class="noindent" ><a 
 id="dx1-42006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_get_imag</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the imaginary part of <span class='var'>v[i]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 480--><p class="noindent" ><a 
 id="dx1-42007"></a> <span class='ret'>double<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_lget_real</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the real part of <span class='var'>v[i]</span> as a lvalue.
     </p></li>
     <li class="itemize">
     <!--l. 484--><p class="noindent" ><a 
 id="dx1-42008"></a> <span class='ret'>double<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_lget_imag</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the imaginary part of <span class='var'>v[i]</span> as a lvalue.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 488--><p class="noindent" ><a 
 id="dx1-42009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_set_real</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i, double re</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the real part of <span class='var'>v[i]</span> to <span class='var'>re</span>.
     </p></li>
     <li class="itemize">
     <!--l. 492--><p class="noindent" ><a 
 id="dx1-42010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_set_imag</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i, double im</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the imaginary part of <span class='var'>v[i]</span> to <span class='var'>im</span>.</p></li></ul>
<!--l. 497--><p class="noindent" >Equivalently to these functions, there exist macros. When the compiler is able to handle inline
code, there is no gain in using macros instead of inlined functions at least in principle.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 501--><p class="noindent" ><a 
 id="dx1-42011"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET_REAL</span></span>&#x00A0;(<span class='args'>v, i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the real part of <span class='var'>v[i]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 504--><p class="noindent" ><a 
 id="dx1-42012"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET_IMAG</span></span>&#x00A0;(<span class='args'>v, i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the imaginary part of <span class='var'>v[i]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 507--><p class="noindent" ><a 
 id="dx1-42013"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET_REAL</span></span>&#x00A0;(<span class='args'>v, i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the real part of <span class='var'>v[i]</span> as a lvalue.
     </p></li>
     <li class="itemize">
     <!--l. 510--><p class="noindent" ><a 
 id="dx1-42014"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET_IMAG</span></span>&#x00A0;(<span class='args'>v, i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the imaginary part of <span class='var'>v[i]</span> as a lvalue.</p></li></ul>
<!--l. 514--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.2   </span> <a 
 id="x1-430004.2"></a>Compact Vectors</h4>
<!--l. 515--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.2.1   </span> <a 
 id="x1-440004.2.1"></a>Short description</h5>
<a 
 id="dx1-44001"></a>
                                                                                    

                                                                                    
<pre class="verbatim" id="verbatim-19">
typedef&#x00A0;struct&#x00A0;PnlVectCompact&#x00A0;{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVectCompact&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;vector&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;val;&#x00A0;/*&#x00A0;single&#x00A0;value&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*&#x00A0;Pointer&#x00A0;to&#x00A0;double&#x00A0;values&#x00A0;*/
&#x00A0;&#x00A0;char&#x00A0;convert;&#x00A0;/*&#x00A0;&#8217;a&#8217;,&#x00A0;&#8217;d&#8217;&#x00A0;:&#x00A0;array,&#x00A0;double&#x00A0;*/
}&#x00A0;PnlVectCompact;
</pre>
<!--l. 530--><p class="nopar" >
</p><!--l. 532--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.2.2   </span> <a 
 id="x1-450004.2.2"></a>Functions</h5>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 535--><p class="noindent" ><a 
 id="dx1-45001"></a> <span class='ret'><a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> of size 0.
     </p></li>
     <li class="itemize">
     <!--l. 538--><p class="noindent" ><a 
 id="dx1-45002"></a> <span class='ret'><a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_create</span></span>&#x00A0;(<span class='args'>int n, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> filled in with <span class='var'>x</span>
     </p></li>
     <li class="itemize">
     <!--l. 540--><p class="noindent" ><a 
 id="dx1-45003"></a> <span class='ret'><a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_create_from_ptr</span></span>&#x00A0;(<span class='args'>int n, double *x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> filled in with the content of <span class='var'>x</span>. Note that <span class='var'>x</span>
     must have at least <span class='var'>n</span> elements.
     </p></li>
     <li class="itemize">
     <!--l. 544--><p class="noindent" ><a 
 id="dx1-45004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 548--><p class="noindent" ><a 
 id="dx1-45005"></a> <span class='ret'><a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy a <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 552--><p class="noindent" ><a 
 id="dx1-45006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a>
     </p></li>
     <li class="itemize">
     <!--l. 555--><p class="noindent" ><a 
 id="dx1-45007"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_to_pnl_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Convert a <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> pointer to a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> pointer.
     </p></li>
     <li class="itemize">
     <!--l. 559--><p class="noindent" ><a 
 id="dx1-45008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Access function
     </p></li>
     <li class="itemize">
     <!--l. 562--><p class="noindent" ><a 
 id="dx1-45009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_set_all</span></span>&#x00A0;(<span class='args'><a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements of <span class='var'>C</span> to <span class='var'>x</span>. <span class='var'>C</span> is converted to a compact storage.
     </p></li>
     <li class="itemize">
     <!--l. 567--><p class="noindent" ><a 
 id="dx1-45010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_set_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x1-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C, double <span 
class="ts1-lmr10-x-x-109">*</span>ptr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy the array <span class='var'>ptr</span> into <span class='var'>C</span>. We assume that the sizes match. <span class='var'>C</span> is converted
     to a non compact storage.</p></li></ul>
<!--l. 575--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.3   </span> <a 
 id="x1-460004.3"></a>Matrices</h4>
<!--l. 576--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.1   </span> <a 
 id="x1-470004.3.1"></a>Overview</h5>
<!--l. 578--><p class="noindent" >The structures and functions related to matrices are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_matrix.h</span></span></span>.
<a 
 id="dx1-47001"></a>
<a 
 id="dx1-47002"></a>
<a 
 id="dx1-47003"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-20">
typedef&#x00A0;struct&#x00A0;_PnlMat{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;m*n&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;row-wise&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
}&#x00A0;PnlMat;

typedef&#x00A0;struct&#x00A0;_PnlMatInt{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlMatInt&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;m*n&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;row-wise&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
}&#x00A0;PnlMatInt;

typedef&#x00A0;struct&#x00A0;_PnlMatComplex{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlMatComplex&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;m*n&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;&#x00A0;dcomplex&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;row-wise&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
}&#x00A0;PnlMatComplex;
                                                                                    

                                                                                    
</pre>
<!--l. 625--><p class="nopar" ><span class='var'>m</span> is the number of rows, <span class='var'>n</span> is the number of columns. <span class='var'>array</span> is a pointer containing the data of
the matrix stored line wise, The element <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">(i,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;j)</span></span></span> of the matrix is <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">array[i*m+j]</span></span></span>. <span class='var'>owner</span>
is an integer to know if the matrix owns its <span class='var'>array</span> pointer (<span class='var'>owner=1</span>) or shares it with
another structure (<span class='var'>owner=0</span>). <span class='var'>mem_size</span> is the number of elements the matrix can hold at
most.
</p><!--l. 633--><p class="noindent" >The following operations are implemented on matrices and vectors. <span class='var'>alpha</span>
and <span class='var'>beta</span> are numbers, <span class='var'>A</span> and <span class='var'>B</span> are matrices and <span class='var'>x</span> and <span class='var'>y</span> are vectors.
<!--tex4ht:inline--></p><div class="tabular"> <table id="TBL-7" class="tabular" 
 
><colgroup id="TBL-7-1g"><col 
id="TBL-7-1" /><col 
id="TBL-7-2" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-7-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-1-1"  
class="td11"><a 
href="#x1-56000doc">pnl_mat_axpy</a>                                 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-1-2"  
class="td11"><span class='var'>B := alpha * A + B</span>                            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-2-1"  
class="td11"><a 
href="#x1-56000doc">pnl_mat_scalar_prod</a>                        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-2-2"  
class="td11"><span class='var'>x&#8217; A y</span>                                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-3-1"  
class="td11"><a 
href="#x1-56000doc">pnl_mat_dgemm</a>                              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-3-2"  
class="td11"><span class='var'>C := alpha * op (A) * op (B) + beta * C</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-4-1"  
class="td11"><a 
href="#x1-56000doc">pnl_mat_mult_vect_transpose_inplace</a></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-4-2"  
class="td11"><span class='var'>y = A&#8217; * x</span>                                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-5-1"  
class="td11"><a 
href="#x1-56000doc">pnl_mat_mult_vect_inplace</a>               </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-5-2"  
class="td11"><span class='var'>y = A * x</span>                                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-6-1"  
class="td11"><a 
href="#x1-56000doc">pnl_mat_lAxpby</a>                              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-6-2"  
class="td11"><span class='var'>y := lambda * A * x + beta * y</span>            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-7-1"  
class="td11"><a 
href="#x1-56000doc">pnl_mat_dgemv</a>                               </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-7-2"  
class="td11"><span class='var'>y := alpha * op (A) * x + beta * y</span>        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-8-1"  
class="td11"><a 
href="#x1-56000doc">pnl_mat_dger</a>                                  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-8-2"  
class="td11"><span class='var'>A := alpha x * y&#8217; + A</span>                         </td></tr></table>     </div>
<!--l. 648--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.2   </span> <a 
 id="x1-480004.3.2"></a>Generic Functions</h5>
<!--l. 649--><p class="noindent" >These functions exist for all types of matrices no matter what the basic type is. The following
conventions are used to name functions operating on matrices. Here is the table of prefixes used for
the different basic types.
</p>
<div class="center" 
>
<!--l. 653--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-8" class="tabular" 
 
><colgroup id="TBL-8-1g"><col 
id="TBL-8-1" /><col 
id="TBL-8-2" /><col 
id="TBL-8-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-8-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-1"  
class="td11">type      </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-2"  
class="td11">prefix                 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-3"  
class="td11">BASE    </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-1"  
class="td11">double    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-2"  
class="td11">pnl_mat             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-3"  
class="td11">double    </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-1"  
class="td11">int         </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-2"  
class="td11">pnl_mat_int       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-3"  
class="td11">int         </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-1"  
class="td11">dcomplex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-2"  
class="td11">pnl_mat_complex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-3"  
class="td11">dcomplex</td></tr></table>                                           </div></div>
<!--l. 665--><p class="noindent" >In this paragraph we present the functions operating on <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> which exist for all types. To deduce
the prototypes of these functions for other basic types, one must replace <span 
class="ec-lmtt-10x-x-109">pnl_mat </span>and <span 
class="ec-lmtt-10x-x-109">double</span>
according the above table.
</p>
<!--l. 670--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-49000"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
There are no special functions to access the sizes of a matrix, instead the fields <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">m</span></span></span>, <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">n</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">mn</span></span></span> give
direct access to the number of rows, columns and the size of the matrix.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 678--><p class="noindent" ><a 
 id="dx1-49001"></a><a 
 id="x1-49000doc"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> of size 0
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 681--><p class="noindent" ><a 
 id="dx1-49002"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create</span></span>&#x00A0;(<span class='args'>int m, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> with <span class='var'>m</span> rows and <span class='var'>n</span> columns.
     </p></li>
     <li class="itemize">
     <!--l. 684--><p class="noindent" ><a 
 id="dx1-49003"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_scalar</span></span>&#x00A0;(<span class='args'>int m, int n, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> with <span class='var'>m</span> rows and <span class='var'>n</span> columns and sets all the elements
     to <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 688--><p class="noindent" ><a 
 id="dx1-49004"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_zero</span></span>&#x00A0;(<span class='args'>int m, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> with <span class='var'>m</span> rows and <span class='var'>n</span> columns and sets all elements to 0.
     </p></li>
     <li class="itemize">
     <!--l. 692--><p class="noindent" ><a 
 id="dx1-49005"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_ptr</span></span>&#x00A0;(<span class='args'>int m, int n, const double <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> with <span class='var'>m</span> rows and <span class='var'>n</span> columns and copies the array <span class='var'>x</span> to
     the new vector. Be sure that <span class='var'>x</span> is long enough to fill all the vector because it cannot be
     checked inside the function.
     </p></li>
     <li class="itemize">
     <!--l. 697--><p class="noindent" ><a 
 id="dx1-49006"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_list</span></span>&#x00A0;(<span class='args'>int m, int n, ...</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> pointer of size <span class='var'>m x n</span> filled with the extra arguments
     passed to the function. The number of extra arguments passed must be equal to <span class='var'>m x n</span>,
     be aware that this cannot be checked inside the function.
     </p></li>
     <li class="itemize">
     <!--l. 704--><p class="noindent" ><a 
 id="dx1-49007"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> which is a copy of <span class='var'>M</span>.
     </p></li>
     <li class="itemize">
     <!--l. 707--><p class="noindent" ><a 
 id="dx1-49008"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_diag_from_ptr</span></span>&#x00A0;(<span class='args'>const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new squared <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> by specifying its size and diagonal terms
     as an array.
     </p></li>
     <li class="itemize">
     <!--l. 712--><p class="noindent" ><a 
 id="dx1-49009"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_diag</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create  a  new  squared  <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  by  specifying  its  diagonal  terms  in  a
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> .
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 717--><p class="noindent" ><a 
 id="dx1-49010"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_file</span></span>&#x00A0;(<span class='args'>const char <span 
class="ts1-lmr10-x-x-109">*</span>file</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Read a matrix from a file and creates the corresponding <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> . One
     row of the matrix corresponds to one line of the file and the elements of a row can be
     separated by spaces, tabs, commas or semicolons. Anything after a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">#</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">%</span></span></span> is ignored up
     to the end of the line.
     </p></li>
     <li class="itemize">
     <!--l. 721--><p class="noindent" ><a 
 id="dx1-49011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> and sets <span class='var'><span 
class="ts1-lmr10-x-x-109">*</span>M</span> to <span class='var'>NULL</span>
     </p></li>
     <li class="itemize">
     <!--l. 723--><p class="noindent" ><a 
 id="dx1-49012"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_wrap_array</span></span>&#x00A0;(<span class='args'>const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int m, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> of size <span class='var'>m x n</span> which contains <span class='var'>x</span>. No copy is made. It is
     just a container.
     </p></li>
     <li class="itemize">
     <!--l. 727--><p class="noindent" ><a 
 id="dx1-49013"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_wrap_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> (not a pointer) whose array is the array of <span class='var'>V</span>. The new
     matrix shares its data with the vector <span class='var'>V</span>, which means that any modification to one of
     them will affect the other.
     </p></li>
     <li class="itemize">
     <!--l. 735--><p class="noindent" ><a 
 id="dx1-49014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone <span class='var'>M</span> into <span class='var'>clone</span>. No no new <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> is created.
     </p></li>
     <li class="itemize">
     <!--l. 740--><p class="noindent" ><a 
 id="dx1-49015"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int m, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> . The new matrix is of size <span class='var'>m x n</span>. The old data are lost.
     </p></li>
     <li class="itemize">
     <!--l. 743--><p class="noindent" ><a 
 id="dx1-49016"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_submat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indi,
     const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indj</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new vector containing the values <span class='var'>M(indi(:), indj(:))</span>. <span class='var'>indi</span> and
     <span class='var'>indj</span> must be of the same size.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 749--><p class="noindent" ><a 
 id="dx1-49017"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_extract_submat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>V_sub,  const  <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>M,  const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indi, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indj</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>V_sub = M(indi(:), indj(:))</span>. <span class='var'>indi</span> and <span class='var'>indj</span> must be of the same
     size.
     </p></li>
     <li class="itemize">
     <!--l. 755--><p class="noindent" ><a 
 id="dx1-49018"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_extract_subblock</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M_sub, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int
     len_i, int j, int len_j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>M_sub = M(i:i+len_i-1, j:j+len_j-1)</span>. <span class='var'>len_i</span> (resp. <span class='var'>len_j</span>) is the number
     of rows (resp. columns) to be extracted.
     </p></li>
     <li class="itemize">
     <!--l. 761--><p class="noindent" ><a 
 id="dx1-49019"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_subblock</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>block, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>If <span class='var'>block</span> is a matrix of size <span class='var'>m_block x n_block</span>, the dimensions of <span class='var'>M</span>
     must satisfy that <span class='var'>M-&#x003E;m &#x003E;= i + m_block</span> and <span class='var'>M-&#x003E;n &#x003E;= j + n_block</span>. On output
     <span class='var'>M(i:i+m_block-1, j:j+n_block-1) = block</span>.</p></li></ul>
<!--l. 770--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-50000"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements.</span></span>
If it is supported by the compiler, the following functions are declared inline. To speed up these
functions, you can define the macro <span 
class="ec-lmtt-10x-x-109">PNL_RANGE_CHECK_OFF</span>, see Section&#x00A0;1.3.2 for an
explanation.
</p><!--l. 776--><p class="noindent" >Accessing elements of a matrix is faster using the following macros </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 778--><p class="noindent" ><a 
 id="dx1-50001"></a><a 
 id="x1-50000doc"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MGET</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>M[i,j]</span> for reading, eg. <span class='var'>x=MGET(M,i,j)</span>
     </p></li>
     <li class="itemize">
     <!--l. 780--><p class="noindent" ><a 
 id="dx1-50002"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MGET_INT</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMatInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-50000doc">MGET</a> but for an integer matrix.
     </p></li>
     <li class="itemize">
     <!--l. 782--><p class="noindent" ><a 
 id="dx1-50003"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MGET_COMPLEX</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-50000doc">MGET</a> but for a complex matrix.
     </p></li>
     <li class="itemize">
     <!--l. 784--><p class="noindent" ><a 
 id="dx1-50004"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MLET</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>M[i,j]</span> as a lvalue for writing, eg. <span class='var'>MLET(M,i,j)=x</span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 787--><p class="noindent" ><a 
 id="dx1-50005"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MLET_INT</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMatInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-50000doc">MLET</a> but for an integer matrix.
     </p></li>
     <li class="itemize">
     <!--l. 789--><p class="noindent" ><a 
 id="dx1-50006"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MLET_COMPLEX</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-50000doc">MLET</a> but for a complex matrix.</p></li></ul>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 794--><p class="noindent" ><a 
 id="dx1-50007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the value of M[i, j]=x
     </p></li>
     <li class="itemize">
     <!--l. 797--><p class="noindent" ><a 
 id="dx1-50008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Get the value of M[i, j]
     </p></li>
     <li class="itemize">
     <!--l. 800--><p class="noindent" ><a 
 id="dx1-50009"></a> <span class='ret'>double <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address of M[i, j] for use as a lvalue.
     </p></li>
     <li class="itemize">
     <!--l. 803--><p class="noindent" ><a 
 id="dx1-50010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_all</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements of <span class='var'>M</span> to <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 805--><p class="noindent" ><a 
 id="dx1-50011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_zero</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements of <span class='var'>M</span> to <span class='var'>0</span>.
     </p></li>
     <li class="itemize">
     <!--l. 808--><p class="noindent" ><a 
 id="dx1-50012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_id</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the matrix <span class='var'>M</span> to the identity matrix. <span class='var'>M</span> must be a square matrix.
     </p></li>
     <li class="itemize">
     <!--l. 812--><p class="noindent" ><a 
 id="dx1-50013"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_diag</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x, int d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'><span 
class="lmmi-10x-x-109">d</span></span><sup>th</sup> diagonal terms of the matrix <span class='var'>M</span> to the value <span class='var'>x</span>. <span class='var'>M</span> must be a
     square matrix.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 816--><p class="noindent" ><a 
 id="dx1-50014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_from_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const double <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set <span class='var'>M</span> row&#8211;wise with the values given by <span class='var'>x</span>. The array <span class='var'>x</span> must be at least
     M-&#x003E;mn long.
     </p></li>
     <li class="itemize">
     <!--l. 820--><p class="noindent" ><a 
 id="dx1-50015"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_get_row</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Extract and copies the <span class='var'>i</span>-th row of <span class='var'>M</span> into <span class='var'>V</span>.
     </p></li>
     <li class="itemize">
     <!--l. 825--><p class="noindent" ><a 
 id="dx1-50016"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_get_col</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Extract and copies the <span class='var'>j</span>-th column of <span class='var'>M</span> into <span class='var'>V</span>.
     </p></li>
     <li class="itemize">
     <!--l. 829--><p class="noindent" ><a 
 id="dx1-50017"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_mat_row</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> (not a pointer) whose array is the <span class='var'>i</span>-th row of <span class='var'>M</span>. The
     new vector shares its data with the matrix <span class='var'>M</span>, which means that any modification to
     one of them will affect the other.
     </p></li>
     <li class="itemize">
     <!--l. 835--><p class="noindent" ><a 
 id="dx1-50018"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_wrap_mat_rows</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i_start, int i_end</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> (not a pointer) holding rows from <span class='var'>i_start</span> to <span class='var'>i_end</span>
     (included) of <span class='var'>M</span>. The new matrix shares its data with the matrix <span class='var'>M</span>, which means that
     any modification to one of them will affect the other.
     </p></li>
     <li class="itemize">
     <!--l. 843--><p class="noindent" ><a 
 id="dx1-50019"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_swap_rows</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Swap two rows of a matrix.
     </p></li>
     <li class="itemize">
     <!--l. 846--><p class="noindent" ><a 
 id="dx1-50020"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_col</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'>i</span>-th column of a matrix <span class='var'>M</span> with the content of <span class='var'>V</span>
     </p></li>
     <li class="itemize">
     <!--l. 849--><p class="noindent" ><a 
 id="dx1-50021"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_col_from_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'>i</span>-th column of <span class='var'>M</span> with the content of <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 853--><p class="noindent" ><a 
 id="dx1-50022"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_row</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'>i</span>-th row of <span class='var'>M</span> with the content of <span class='var'>V</span>
     </p></li>
     <li class="itemize">
     <!--l. 856--><p class="noindent" ><a 
 id="dx1-50023"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_row_from_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'>i</span>-th row of <span class='var'>M</span> with the content of <span class='var'>x</span>
     </p></li>
     <li class="itemize">
     <!--l. 860--><p class="noindent" ><a 
 id="dx1-50024"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_add_row</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>r</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Add a row in matrix <span class='var'>M</span> before position <span class='var'>i</span> and fill it with the content of <span class='var'>r</span>.
     If <span class='var'>r == NULL</span>, row <span class='var'>i</span> is left uninitialized. The index <span class='var'>i</span> may vary between <span class='var'>0</span> &#8212; add a row
     at the top of the matrix &#8212; and <span class='var'>M-&#x003E;m</span> &#8212; add a row after all rows.
     </p></li>
     <li class="itemize">
     <!--l. 866--><p class="noindent" ><a 
 id="dx1-50025"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_del_row</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Delete the row with index <span class='var'>i</span> (between <span class='var'>0</span> and <span class='var'>M-&#x003E;m-1</span>) of the matrix <span class='var'>M</span>.
</p>
     </li></ul>
<!--l. 872--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-51000"></a><span 
class="ec-lmbx-10x-x-109">Printing Matrices</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 875--><p class="noindent" ><a 
 id="dx1-51001"></a><a 
 id="x1-51000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a matrix to the standard output.
     </p></li>
     <li class="itemize">
     <!--l. 878--><p class="noindent" ><a 
 id="dx1-51002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a matrix to a file. The saved matrix can be reloaded by the function
     <a 
href="#x1-49000doc">pnl_mat_create_from_file</a>.
     </p></li>
     <li class="itemize">
     <!--l. 883--><p class="noindent" ><a 
 id="dx1-51003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_print_nsp</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a matrix to the standard output in a format compatible with Nsp.
     </p></li>
     <li class="itemize">
     <!--l. 887--><p class="noindent" ><a 
 id="dx1-51004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_fprint_nsp</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a matrix to a file in a format compatible with Nsp.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 892--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-52000"></a><span 
class="ec-lmbx-10x-x-109">Applying external operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 894--><p class="noindent" ><a 
 id="dx1-52001"></a><a 
 id="x1-52000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar addition
     </p></li>
     <li class="itemize">
     <!--l. 897--><p class="noindent" ><a 
 id="dx1-52002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar substraction
     </p></li>
     <li class="itemize">
     <!--l. 900--><p class="noindent" ><a 
 id="dx1-52003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar multiplication
     </p></li>
     <li class="itemize">
     <!--l. 903--><p class="noindent" ><a 
 id="dx1-52004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar division
</p>
     </li></ul>
<!--l. 908--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-53000"></a><span 
class="ec-lmbx-10x-x-109">Element wise operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 911--><p class="noindent" ><a 
 id="dx1-53001"></a><a 
 id="x1-53000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix term by term product
     </p></li>
     <li class="itemize">
     <!--l. 915--><p class="noindent" ><a 
 id="dx1-53002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_div_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix term by term division
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 919--><p class="noindent" ><a 
 id="dx1-53003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_kron_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>res, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place Kroenecker product of <span class='var'>A</span> and <span class='var'>B</span>
     </p></li>
     <li class="itemize">
     <!--l. 922--><p class="noindent" ><a 
 id="dx1-53004"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_kron_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the Kroenecker product of <span class='var'>A</span> and <span class='var'>B</span>
     </p></li>
     <li class="itemize">
     <!--l. 925--><p class="noindent" ><a 
 id="dx1-53005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_map_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 930--><p class="noindent" ><a 
 id="dx1-53006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_map</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 934--><p class="noindent" ><a 
 id="dx1-53007"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_map_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>lhs,    const    <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>rhs,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double, double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs, rhs)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 938--><p class="noindent" ><a 
 id="dx1-53008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_map_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs1, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double, double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs1, rhs2)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 944--><p class="noindent" ><a 
 id="dx1-53009"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_sum</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sum matrix component-wise
     </p></li>
     <li class="itemize">
     <!--l. 947--><p class="noindent" ><a 
 id="dx1-53010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_sum_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char c</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sum matrix column or row wise. Argument <span class='var'>c</span> can be either &#8217;r&#8217; (to get a
     row vector) or &#8217;c&#8217; (to get a column vector). When <span class='var'>c=&#8217;r&#8217;</span>, <span 
class="lmmi-10x-x-109">y</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="lmex-10">&#x2211;</span>
  <sub><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> and when <span class='var'>c=&#8217;rc</span>,
     <span 
class="lmmi-10x-x-109">y</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="lmex-10">&#x2211;</span>
  <sub><span 
class="lmmi-8">j</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub>.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 954--><p class="noindent" ><a 
 id="dx1-53011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_cumsum</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char c</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative sum over the rows or columns. Argument <span class='var'>c</span> can be either &#8217;r&#8217;
     to sum over the rows or &#8217;c&#8217; to sum over the columns. When <span class='var'>c=&#8217;r&#8217;</span>, <span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="lmex-10">&#x2211;</span>
  <sub><span 
class="rm-lmr-8">1</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">k</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">kj</span></sub>
     and when <span class='var'>c=&#8217;rc</span>, <span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="lmex-10">&#x2211;</span>
  <sub><span 
class="rm-lmr-8">1</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">k</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">j</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ik</span></sub>.
     </p></li>
     <li class="itemize">
     <!--l. 960--><p class="noindent" ><a 
 id="dx1-53012"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_prod</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Product matrix component-wise
     </p></li>
     <li class="itemize">
     <!--l. 963--><p class="noindent" ><a 
 id="dx1-53013"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_prod_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char c</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Prod matrix column or row wise. Argument <span class='var'>c</span> can be either &#8217;r&#8217; (to get a
     row vector) or &#8217;c&#8217; (to get a column vector). When <span class='var'>c=&#8217;r&#8217;</span>, <span 
class="lmmi-10x-x-109">y</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> and when <span class='var'>c=&#8217;rc</span>,
     <span 
class="lmmi-10x-x-109">y</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="lmmi-8">j</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub>.
     </p></li>
     <li class="itemize">
     <!--l. 970--><p class="noindent" ><a 
 id="dx1-53014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_cumprod</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char c</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative prod over the rows or columns. Argument <span class='var'>c</span> can be either &#8217;r&#8217;
     to prod over the rows or &#8217;c&#8217; to prod over the columns. When <span class='var'>c=&#8217;r&#8217;</span>, <span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="rm-lmr-8">1</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">k</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">kj</span></sub>
     and when <span class='var'>c=&#8217;rc</span>, <span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="rm-lmr-8">1</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">k</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">j</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ik</span></sub>.</p></li></ul>
<!--l. 977--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-54000"></a><span 
class="ec-lmbx-10x-x-109">Comparison functions</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 980--><p class="noindent" ><a 
 id="dx1-54001"></a><a 
 id="x1-54000doc"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_isequal</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, double err</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two matrices are equal up to <span class='var'>err</span> component&#8211;wise. The error <span class='var'>err</span>
     is either relative or absolute depending on the magnitude of the components. Return
     <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </p></li>
     <li class="itemize">
     <!--l. 982--><p class="noindent" ><a 
 id="dx1-54002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_isequal_abs</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, double abserr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test  if  two  matrices  are  equal  up  to  an  absolute  error  <span class='var'>abserr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </p></li>
     <li class="itemize">
     <!--l. 984--><p class="noindent" ><a 
 id="dx1-54003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_isequal_rel</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, double relerr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test   if   two   matrices   are   equal   up   to   a   relative   error   <span class='var'>relerr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 988--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-55000"></a><span 
class="ec-lmbx-10x-x-109">Ordering operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 991--><p class="noindent" ><a 
 id="dx1-55001"></a><a 
 id="x1-55000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_max</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'><span 
class="lmmi-10x-x-109">M</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">)) </span>when <span class='var'>d=&#8217;c&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">M</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j,i</span><span 
class="rm-lmr-10x-x-109">))</span>
     when <span class='var'>d=&#8217;r&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">M</span><span 
class="rm-lmr-10x-x-109">(0)</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">=</span><span class='var'> <span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">) </span>when <span class='var'>d=&#8217;*&#8217;</span>.
     </p></li>
     <li class="itemize">
     <!--l. 997--><p class="noindent" ><a 
 id="dx1-55002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_min</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>m,const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'><span 
class="lmmi-10x-x-109">m</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">)  =</span>  <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">)) </span>when <span class='var'>d=&#8217;c&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">m</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">)  =</span>  <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j,i</span><span 
class="rm-lmr-10x-x-109">))</span>
     when <span class='var'>d=&#8217;r&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">M</span><span 
class="rm-lmr-10x-x-109">(0)</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">=</span><span class='var'> <span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">) </span>when <span class='var'>d=&#8217;*&#8217;</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1003--><p class="noindent" ><a 
 id="dx1-55003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_minmax</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>m, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'><span 
class="lmmi-10x-x-109">m</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">)) </span>and <span class='var'><span 
class="lmmi-10x-x-109">M</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">)) </span>when <span class='var'>d=&#8217;c&#8217;</span>
     and <span class='var'><span 
class="lmmi-10x-x-109">m</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j,i</span><span 
class="rm-lmr-10x-x-109">)) </span>and <span class='var'><span 
class="lmmi-10x-x-109">M</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j,i</span><span 
class="rm-lmr-10x-x-109">)) </span>when <span class='var'>d=&#8217;r&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">M</span><span 
class="rm-lmr-10x-x-109">(0)</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">=</span>
     <span class='var'> <span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">) </span>and <span class='var'><span 
class="lmmi-10x-x-109">m</span><span 
class="rm-lmr-10x-x-109">(0)</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">=</span><span class='var'> <span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">) </span>when <span class='var'>d=&#8217;*&#8217;</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1010--><p class="noindent" ><a 
 id="dx1-55004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_min_index</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>m, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>im, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char
     d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Idem as <a 
href="#x1-55000doc">pnl_mat_min</a> and <span class='var'>index</span> contains the indices of the minima. If
     <span class='var'>index==NULL</span>, the indices are not computed.
     </p></li>
     <li class="itemize">
     <!--l. 1015--><p class="noindent" ><a 
 id="dx1-55005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_max_index</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>iM, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char
     d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Idem as <a 
href="#x1-55000doc">pnl_mat_max</a> and <span class='var'>index</span> contains the indices of the maxima. If
     <span class='var'>index==NULL</span>, the indices are not computed.
     </p></li>
     <li class="itemize">
     <!--l. 1020--><p class="noindent" ><a 
 id="dx1-55006"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_minmax_index</span></span>&#x00A0;(<span class='args'>  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>m,  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>M,  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>im,
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>iM, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Idem as <a 
href="#x1-55000doc">pnl_mat_minmax</a> and <span class='var'>im</span> contains the indices of the minima
     and <span class='var'>iM</span> contains the indices of the minima. If <span class='var'>im==NULL</span> (resp. <span class='var'>iM==NULL</span>, the
     indices of the minima (resp. maxima) are not computed.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1028--><p class="noindent" ><a 
 id="dx1-55007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_qsort</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, char dir, char order</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sort a matrix using a quick sort algorithm according to <span class='var'>order</span> (<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;i&#8217;</span></span></span> for
     increasing or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;d&#8217;</span></span></span> for decreasing). The parameter <span class='var'>dir</span> determines whether the matrix is
     sorted by rows or columns. If <span class='var'>dir=&#8217;c&#8217;</span>, each row is sorted independently of the others
     whereas if <span class='var'>dir=&#8217;r&#8217;</span>, each column is sorted independently of the others.
     </p></li>
     <li class="itemize">
     <!--l. 1035--><p class="noindent" ><a 
 id="dx1-55008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_qsort_index</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatInt</span></a> *index, char dir, char order</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sort a matrix using a quick sort algorithm according to <span class='var'>order</span> (<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;i&#8217;</span></span></span> for
     increasing or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;d&#8217;</span></span></span> for decreasing). The parameter <span class='var'>dir</span> determines whether the matrix is
     sorted by rows or columns. If <span class='var'>dir=&#8217;c&#8217;</span>, each row is sorted independently of the others
     whereas if <span class='var'>dir=&#8217;r&#8217;</span>, each column is sorted independently of the others. In addition to the
     function <a 
href="#x1-55000doc">pnl_mat_qsort</a>, the permutation index is computed and stored into <span class='var'>index</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1045--><p class="noindent" ><a 
 id="dx1-55009"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_find</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indi, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> indj, char <span 
class="ts1-lmr10-x-x-109">*</span>type, int(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double <span 
class="ts1-lmr10-x-x-109">*</span>t),
     &#x2026;</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>f</span> is a function taking a C array as argument and returning an integer. <span class='var'>type</span> is a
     string composed by the letters &#8217;r&#8217; and &#8217;m&#8217; and is used to describe the types of the arguments
     appearing after <span class='var'>f</span> : &#8217;r&#8217; for real numbers and &#8217;m&#8217; for matrices. This function aims at simulating
     Scilab&#8217;s <span class='var'>find</span> function. Here are a few examples (capital letters are used for matrices and small
     letters for real values) </p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 1055--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">[indi,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;indj]</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;a</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;)</span></span></span>
                                                                                    

                                                                                    
</p>
          <pre class="verbatim" id="verbatim-21">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;isless&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)&#x00A0;{&#x00A0;return&#x00A0;t[0]&#x00A0;&#x003C;&#x00A0;t[1];&#x00A0;}
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_mat_find&#x00A0;(&#x00A0;indi,&#x00A0;indj,&#x00A0;"rm",&#x00A0;isless,&#x00A0;a,&#x00A0;X&#x00A0;);
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</pre>
          <!--l. 1059--><p class="nopar" >
          </p></li>
          <li class="itemize">
          <!--l. 1060--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">ind</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;Y)</span></span></span>
                                                                                    

                                                                                    
</p>
          <pre class="verbatim" id="verbatim-22">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;isless&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)&#x00A0;{&#x00A0;return&#x00A0;t[0]&#x00A0;&#x003C;=&#x00A0;t[1];&#x00A0;}
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_mat_find&#x00A0;(&#x00A0;ind,&#x00A0;"mm",&#x00A0;isless,&#x00A0;X,&#x00A0;Y&#x00A0;);
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</pre>
          <!--l. 1064--><p class="nopar" >
          </p></li>
          <li class="itemize">
          <!--l. 1065--><p class="noindent" ><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">[indi,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;indj]</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;((a</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;X)</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&amp;&amp;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;Y))</span></span></span>
                                                                                    

                                                                                    
</p>
          <pre class="verbatim" id="verbatim-23">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;cmp&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;(t[0]&#x00A0;&#x003C;=&#x00A0;t[1])&#x00A0;&amp;&amp;&#x00A0;(t[1]&#x00A0;&#x003C;=&#x00A0;t[2]);
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_mat_find&#x00A0;(&#x00A0;indi,&#x00A0;indj,&#x00A0;"rmm",&#x00A0;cmp,&#x00A0;a,&#x00A0;X,&#x00A0;Y&#x00A0;);
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</pre>
          <!--l. 1072--><p class="nopar" ></p></li></ul>
     <!--l. 1074--><p class="noindent" ><span class='var'>(indi, indj)</span> contains on exit the indices <span class='var'>(i,j)</span> for which the function <span class='var'>f</span> returned <span class='var'>1</span>. Note that if
     <span class='var'>indj == NULL</span> on entry, a linear indexing is used for matrices, which means that matrices
     are seen as large vectors built up be stacking rows. This function returns <span class='var'>OK</span> or
     <span class='var'>FAIL</span> if something went wrong (size mismatch between matrices, invalid string
     type).</p></li></ul>
<!--l. 1082--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-56000"></a><span 
class="ec-lmbx-10x-x-109">Standard matrix operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1086--><p class="noindent" ><a 
 id="dx1-56001"></a><a 
 id="x1-56000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_plus_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix addition
     </p></li>
     <li class="itemize">
     <!--l. 1090--><p class="noindent" ><a 
 id="dx1-56002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_minus_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix substraction
     </p></li>
     <li class="itemize">
     <!--l. 1094--><p class="noindent" ><a 
 id="dx1-56003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_sq_transpose</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>M</span> is transposed
     </p></li>
     <li class="itemize">
     <!--l. 1097--><p class="noindent" ><a 
 id="dx1-56004"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_transpose</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new matrix which is the transposition of <span class='var'>M</span>
     </p></li>
     <li class="itemize">
     <!--l. 1101--><p class="noindent" ><a 
 id="dx1-56005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_tr</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>tM, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>tM = M&#8217;</span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1105--><p class="noindent" ><a 
 id="dx1-56006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_trace</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the trace of a square matrix.
     </p></li>
     <li class="itemize">
     <!--l. 1108--><p class="noindent" ><a 
 id="dx1-56007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_axpy</span></span>&#x00A0;(<span class='args'>double alpha, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>B := alpha * A + B</span>
     </p></li>
     <li class="itemize">
     <!--l. 1112--><p class="noindent" ><a 
 id="dx1-56008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_dger</span></span>&#x00A0;(<span class='args'>double alpha, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>A := alpha x * y&#8217; + A</span>
     </p></li>
     <li class="itemize">
     <!--l. 1116--><p class="noindent" ><a 
 id="dx1-56009"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Matrix vector multiplication <span class='var'>A * x</span>
     </p></li>
     <li class="itemize">
     <!--l. 1120--><p class="noindent" ><a 
 id="dx1-56010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_vect_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In place matrix vector multiplication <span class='var'>y = A * x</span>. You cannot use the
     same vector for <span class='var'>x</span> and <span class='var'>y</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1126--><p class="noindent" ><a 
 id="dx1-56011"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_vect_transpose</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Matrix vector multiplication <span class='var'>A&#8217; * x</span>
     </p></li>
     <li class="itemize">
     <!--l. 1130--><p class="noindent" ><a 
 id="dx1-56012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_vect_transpose_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A,
     const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In place matrix vector multiplication <span class='var'>y = A&#8217; * x</span>. You cannot use the
     same vector for <span class='var'>x</span> and <span class='var'>y</span>. The vectors <span class='var'>x</span> and <span class='var'>y</span> must be different.
     </p></li>
     <li class="itemize">
     <!--l. 1137--><p class="noindent" ><a 
 id="dx1-56013"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_cross</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the cross products of the vectors given in matrices <span class='var'>A</span> and <span class='var'>B</span>
     which must have either 3 rows or 3 columns. A row wise computation is first tried, then
     a column wise approach is tested. <span class='var'>FAIL</span> is returned in case no dimension equals 3.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1145--><p class="noindent" ><a 
 id="dx1-56014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lAxpby</span></span>&#x00A0;(<span class='args'>double lambda, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double
     b, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>y := lambda A x + b y</span>. When <span class='var'>b=0</span>, the content of <span class='var'>y</span> is not
     used on input and instead <span class='var'>y</span> is resized to match <span class='var'>A*x</span>. The vectors <span class='var'>x</span> and <span class='var'>y</span> must be
     different.
     </p></li>
     <li class="itemize">
     <!--l. 1152--><p class="noindent" ><a 
 id="dx1-56015"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_dgemv</span></span>&#x00A0;(<span class='args'>char trans, double lambda, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x, double mu, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>b := lambda op(A) x + mu b</span>, where <span class='var'>op (X) = X</span> or <span class='var'>op (X) =
     X&#8217;</span>. If <span class='var'>trans=&#8217;N&#8217;</span> or <span class='var'>trans=&#8217;n&#8217;</span>, <span class='var'>op (A) = A</span>, whereas if <span class='var'>trans=&#8217;T&#8217;</span> or <span class='var'>trans=&#8217;t&#8217;</span>, <span class='var'>op (A)
     = A&#8217;</span>.When <span class='var'>mu==0</span>, the content of <span class='var'>b</span> is not used and instead <span class='var'>b</span> is resized to match
     <span class='var'>op(A)*x</span>. The vectors <span class='var'>x</span> and <span class='var'>b</span> must be different.
     </p></li>
     <li class="itemize">
     <!--l. 1161--><p class="noindent" ><a 
 id="dx1-56016"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_dgemm</span></span>&#x00A0;(<span class='args'>char transA, char transB, double alpha, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A,
     const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, double beta, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>C := alpha * op(A) * op (B) + beta * C</span>. When beta=0, the
     content of <span class='var'>C</span> is unused and instead <span class='var'>C</span> is resized to store <span class='var'>alpha A <span 
class="ts1-lmr10-x-x-109">*</span>B</span>. If <span class='var'>transA=&#8217;N&#8217;</span> or
     <span class='var'>transA=&#8217;n&#8217;</span>, <span class='var'>op (A) = A</span>, whereas if <span class='var'>transA=&#8217;T&#8217;</span> or <span class='var'>transA=&#8217;t&#8217;</span>, <span class='var'>op (A) = A&#8217;</span>. The same
     holds for <span class='var'>transB</span>. The matrix <span class='var'>C</span> must be different from <span class='var'>A</span> and <span class='var'>B</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1171--><p class="noindent" ><a 
 id="dx1-56017"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs1, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Matrix multiplication <span class='var'>rhs1 * rhs2</span>
     </p></li>
     <li class="itemize">
     <!--l. 1175--><p class="noindent" ><a 
 id="dx1-56018"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>lhs,  const  <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>rhs1,  const
     <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix multiplication <span class='var'>lhs = rhs1 * rhs2</span>. The matrix <span class='var'>lhs</span> must be
     different from <span class='var'>rhs1</span> and <span class='var'>rhs2</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1181--><p class="noindent" ><a 
 id="dx1-56019"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_scalar_prod</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>x&#8217; * A * y</span>
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 1184--><p class="noindent" ><a 
 id="dx1-56020"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_exp</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the matrix exponential <span class='var'>B = exp(A)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1188--><p class="noindent" ><a 
 id="dx1-56021"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_log</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the matrix logarithm <span class='var'>B = log(A)</span>. For the moment, this function
     only works if <span class='var'>A</span> is diagonalizable.
     </p></li>
     <li class="itemize">
     <!--l. 1193--><p class="noindent" ><a 
 id="dx1-56022"></a>   <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_eigen</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>   *v,   <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>P,   const   <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>A,   int
     with_eigenvector</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the eigenvalues (stored in <span class='var'>v</span>) and optionally the eigenvectors
     stored  column  wise  in  <span class='var'>P</span>  when  <span class='var'>with_eigenvector==TRUE</span>.  If  <span class='var'>A</span>  is  symmetric  or
     Hermitian in the complex case, <span class='var'>P</span> is orthonormal. When <span class='var'>with_eigenvector=FALSE</span>, <span class='var'>P</span>
     can be <span class='var'>NULL</span>.</p></li></ul>
<!--l. 1203--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-57000"></a><span 
class="ec-lmbx-10x-x-109">Linear systems and matrix decompositions</span></span>
The following functions are designed to solve linear system of the from <span class='var'>A x = b</span> where <span class='var'>A</span> is a matrix
and <span class='var'>b</span> is a vector except in the functions <a 
href="#x1-57000doc">pnl_mat_syslin_mat</a>, <a 
href="#x1-57000doc">pnl_mat_lu_syslin_mat</a> and
<a 
href="#x1-57000doc">pnl_mat_chol_syslin_mat</a> which expect the right hand side member to be a matrix too. Whenever
the vector <span class='var'>b</span> is not needed once the system is solved, you should consider using &#8220;inplace&#8221;
functions.
</p><!--l. 1213--><p class="noindent" >All the functions described in this paragraph return <span class='var'>OK</span> if the computations have been carried out
successfully and <span class='var'>FAIL</span> otherwise.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1217--><p class="noindent" ><a 
 id="dx1-57001"></a><a 
 id="x1-57000doc"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_chol</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the Cholesky decomposition of <span class='var'>M</span>. <span class='var'>M</span> must be symmetric, the
     positivity is tested in the algorithm. <span class='var'>M = L * L&#8217;</span>. On exit, the lower part of <span class='var'>M</span> contains
     the Cholesky decomposition L and the upper part is set to zero.
     </p></li>
     <li class="itemize">
     <!--l. 1223--><p class="noindent" ><a 
 id="dx1-57002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_pchol</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double tol, int <span 
class="ts1-lmr10-x-x-109">*</span>rank, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the Cholesky decomposition of <span class='var'>M</span> with complete pivoting. <span class='var'>P&#8217;
     * A * P = L * L&#8217;</span>. <span class='var'>M</span> must be symmetric positive semi-definite. On exit, the lower part
     of <span class='var'>M</span> contains the Cholesky decomposition <span class='var'>L</span> and the upper part is set to zero. The
     permutation matrix is stored in an integer vector <span class='var'>p</span> : the only non zero elements of <span class='var'>P</span>
     are <span class='var'>P(p(k),k) = 1</span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1234--><p class="noindent" ><a 
 id="dx1-57003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lu</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute a P A = LU factorization. <span class='var'>P</span> must be an already allocated
     <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> . On exit the decomposition is stored in <span class='var'>A</span>, the lower part of <span class='var'>A</span> contains
     L while the upper part (including the diagonal terms) contains U. Remember that the
     diagonal elements of <span class='var'>L</span> are all 1. Row <span class='var'>i</span> of <span class='var'>A</span> was interchanged with row <span class='var'>p(i)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1243--><p class="noindent" ><a 
 id="dx1-57004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_upper_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>U, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve an upper triangular linear system <span class='var'>U x = b</span>
     </p></li>
     <li class="itemize">
     <!--l. 1247--><p class="noindent" ><a 
 id="dx1-57005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lower_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a lower triangular linear system <span class='var'>L x = b</span>
     </p></li>
     <li class="itemize">
     <!--l. 1251--><p class="noindent" ><a 
 id="dx1-57006"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_chol_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>chol, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a symmetric definite positive linear system A x = b, in which <span class='var'>chol</span>
     is assumed to be the Cholesky decomposition of A computed by <a 
href="#x1-57000doc">pnl_mat_chol</a>
     </p></li>
     <li class="itemize">
     <!--l. 1257--><p class="noindent" ><a 
 id="dx1-57007"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_chol_syslin_inplace</span></span>&#x00A0;(<span class='args'> const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>chol, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a symmetric definite positive linear system A x = b, in which <span class='var'>chol</span>
     is assumed to be the Cholesky decomposition of A computed by <a 
href="#x1-57000doc">pnl_mat_chol</a>. The
     solution of the system is stored in <span class='var'>b</span> on exit.
     </p></li>
     <li class="itemize">
     <!--l. 1264--><p class="noindent" ><a 
 id="dx1-57008"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lu_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>LU, const <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p,
     const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A x = b using a LU decomposition. <span class='var'>LU</span> and <span class='var'>P</span> are
     assumed to be the PA = LU decomposition as computed by <a 
href="#x1-57000doc">pnl_mat_lu</a>. In particular,
     the structure of the matrix <span class='var'>LU</span> is the following : the lower part of <span class='var'>A</span> contains L while
     the upper part (including the diagonal terms) contains U. Remember that the diagonal
     elements of <span class='var'>L</span> are all 1.
     </p></li>
     <li class="itemize">
     <!--l. 1274--><p class="noindent" ><a 
 id="dx1-57009"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lu_syslin_inplace</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>LU, const <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p,
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A x = b using a LU decomposition. <span class='var'>LU</span> and <span class='var'>P</span> are
     assumed to be the PA = LU decomposition as computed by <a 
href="#x1-57000doc">pnl_mat_lu</a>. In particular,
                                                                                    

                                                                                    
     the structure of the matrix <span class='var'>LU</span> is the following : the lower part of <span class='var'>A</span> contains L while
     the upper part (including the diagonal terms) contains U. Remember that the diagonal
     elements of <span class='var'>L</span> are all 1. The solution of the system is stored in <span class='var'>b</span> on exit.
     </p></li>
     <li class="itemize">
     <!--l. 1285--><p class="noindent" ><a 
 id="dx1-57010"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A x = b using a LU factorization which is computed
     inside this function.
     </p></li>
     <li class="itemize">
     <!--l. 1290--><p class="noindent" ><a 
 id="dx1-57011"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_syslin_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A x = b using a LU factorization which is computed
     inside this function. The solution of the system is stored in <span class='var'>b</span> and <span class='var'>A</span> is overwritten by
     its LU decomposition.
     </p></li>
     <li class="itemize">
     <!--l. 1296--><p class="noindent" ><a 
 id="dx1-57012"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_syslin_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  a  linear  system  A  X  =  B  using  a  LU  factorization  which  is
     computed inside this function. <span class='var'>A</span> and <span class='var'>B</span> are matrices. <span class='var'>A</span> must be square. The solution
     of the system is stored in <span class='var'>B</span> on exit. On exit, <span class='var'>A</span> contains the LU decomposition of the
     input matrix which is lost.
     </p></li>
     <li class="itemize">
     <!--l. 1304--><p class="noindent" ><a 
 id="dx1-57013"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_chol_syslin_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  a  linear  system  A  X  =  B  using  a  Cholesky  factorization  of
     the symmetric positive defnite matrix <span class='var'>A</span>. <span class='var'>A</span> contains the Cholesky decomposition as
     computed by <a 
href="#x1-57000doc">pnl_mat_chol</a>. <span class='var'>B</span> is matrix with the same number of rows as <span class='var'>A</span>. The
     solution of the system is stored in <span class='var'>B</span> on exit.
     </p></li>
     <li class="itemize">
     <!--l. 1311--><p class="noindent" ><a 
 id="dx1-57014"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lu_syslin_mat</span></span>&#x00A0;(<span class='args'>const  <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>A,  const  <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>p,
     <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A X = B using a <span class='var'>P A = L U</span> factorization. <span class='var'>A</span>
     contains the <span class='var'>L U</span> factors and <span class='var'>p</span> the associated permutation. <span class='var'>A</span> and <span class='var'>p</span> must have been
     computed by <a 
href="#x1-57000doc">pnl_mat_lu</a>. <span class='var'>B</span> is matrix with the same number of rows as <span class='var'>A</span>. The solution
     of the system is stored in <span class='var'>B</span> on exit.
</p>
     </li></ul>
<!--l. 1322--><p class="noindent" >The following functions are designed to invert matrices. The authors provide these functions
although they cannot find good reasons to use them. Note that to solve a linear system, one must
used the <span class='var'>syslin</span> functions and not invert the system matrix because it is much longer.
</p>
                                                                                    

                                                                                    
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1327--><p class="noindent" ><a 
 id="dx1-57015"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_upper_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Inversion of an upper triangular matrix
     </p></li>
     <li class="itemize">
     <!--l. 1331--><p class="noindent" ><a 
 id="dx1-57016"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lower_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Inversion of a lower triangular matrix
     </p></li>
     <li class="itemize">
     <!--l. 1335--><p class="noindent" ><a 
 id="dx1-57017"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>inverse, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse of a matrix A and stores the result into <span class='var'>inverse</span>. A
     LU factorisation of the matrix <span class='var'>A</span> is computed inside this function.
     </p></li>
     <li class="itemize">
     <!--l. 1340--><p class="noindent" ><a 
 id="dx1-57018"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_inverse_with_chol</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>inverse, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse of a symmetric positive definite matrix A and stores
     the result into <span class='var'>inverse</span>. The Cholesky factorisation of the matrix <span class='var'>A</span> is computed inside
     this function.</p></li></ul>
<!--l. 1347--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.3   </span> <a 
 id="x1-580004.3.3"></a>Functions specific to base type <span 
class="ec-lmtt-10x-x-109">double</span></h5>
<!--l. 1350--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-59000"></a><span 
class="ec-lmbx-10x-x-109">Linear systems and matrix decompositions</span></span>
The following functions are designed to solve linear system of the from <span class='var'>A x = b</span> where <span class='var'>A</span> is a matrix
and <span class='var'>b</span> is a vector except in the functions <a 
href="#x1-57000doc">pnl_mat_syslin_mat</a>, <a 
href="#x1-57000doc">pnl_mat_lu_syslin_mat</a> and
<a 
href="#x1-57000doc">pnl_mat_chol_syslin_mat</a> which expect the right hand side member to be a matrix too. Whenever
the vector <span class='var'>b</span> is not needed once the system is solved, you should consider using &#8220;inplace&#8221;
functions.
</p><!--l. 1360--><p class="noindent" >All the functions described in this paragraph return <span class='var'>OK</span> if the computations have been carried out
successfully and <span class='var'>FAIL</span> otherwise.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1364--><p class="noindent" ><a 
 id="dx1-59001"></a><a 
 id="x1-59000doc"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_qr</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Q, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>R, <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute a <span class='var'>A P = QR</span> decomposition. If on entry <span class='var'>P=NULL</span>, then the
     decomposition is computed without pivoting, i.e <span class='var'>A = QR</span>. When <span 
class="lmmi-10x-x-109">P</span><span 
class="lmmi-10x-x-109">&#x2260;</span><span 
class="lmmi-10x-x-109">NULL</span>, <span class='var'>P</span> must be
     an already allocated <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> . <span class='var'>Q</span> is an orthogonal matrix, i.e <span class='var'><span 
class="lmmi-10x-x-109">Q</span></span><sup><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sup> <span 
class="rm-lmr-10x-x-109">=</span><span class='var'> <span 
class="lmmi-10x-x-109">Q</span></span><sup><span 
class="lmmi-8">T</span> </sup> and
                                                                                    

                                                                                    
     <span class='var'>R</span> is an upper triangular matrix. The use of pivoting improves the numerical stability
     when <span class='var'>A</span> is almost rank deficient, i.e when the smallest eigenvalue of <span class='var'>A</span> is very close to
     <span 
class="rm-lmr-10x-x-109">0</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1375--><p class="noindent" ><a 
 id="dx1-59002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_qr_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Q, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>R, const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system <span class='var'>A x = b</span> where <span class='var'>A</span> is given by its QR decomposition
     with column pivoting as computed by the function <a 
href="#x1-59000doc">pnl_mat_qr</a>.
     </p></li>
     <li class="itemize">
     <!--l. 1381--><p class="noindent" ><a 
 id="dx1-59003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_ls</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  a  linear  system  A  x  =  b  in  the  least  square  sense,  i.e.  <span class='var'><span 
class="lmmi-10x-x-109">x</span></span>  <span 
class="rm-lmr-10x-x-109">=</span>
     <span 
class="rm-lmr-10x-x-109">arg</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">U</span></sub><span 
class="lmsy-10x-x-109">&#x2225;</span><span 
class="lmmi-10x-x-109">A </span><span 
class="lmsy-10x-x-109">* </span><span 
class="lmmi-10x-x-109">u </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">b</span><span 
class="lmsy-10x-x-109">&#x2225;</span><sup><span 
class="rm-lmr-8">2</span></sup>. The solution is stored into <span class='var'>b</span> on exit. It internally uses a <span class='var'>AP =
     QR</span> decomposition.
     </p></li>
     <li class="itemize">
     <!--l. 1386--><p class="noindent" ><a 
 id="dx1-59004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_ls_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A X = B with <span class='var'>A</span> and <span class='var'>B</span> two matrices in the least
     square sense, i.e. <span class='var'><span 
class="lmmi-10x-x-109">X</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">arg</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">U</span></sub><span 
class="lmsy-10x-x-109">&#x2225;</span><span 
class="lmmi-10x-x-109">A </span><span 
class="lmsy-10x-x-109">* </span><span 
class="lmmi-10x-x-109">U </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">B</span><span 
class="lmsy-10x-x-109">&#x2225;</span><sup><span 
class="rm-lmr-8">2</span></sup>. The solution is stored into <span class='var'>B</span> on exit. It
     internally uses a <span class='var'>AP = QR</span> decomposition. Same function as <a 
href="#x1-59000doc">pnl_mat_ls</a> but handles
     several r.h.s.
</p>
     </li></ul>
<!--l. 1396--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.4   </span> <a 
 id="x1-600004.3.4"></a>Functions specific to base type <span 
class="ec-lmtt-10x-x-109">dcomplex</span></h5>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1399--><p class="noindent" ><a 
 id="dx1-60001"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_complex_create_from_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>R</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a complex matrix using a real one. The complex parts of the
     entries of the returned matrix are all set to zero.</p></li></ul>
<!--l. 1404--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.5   </span> <a 
 id="x1-610004.3.5"></a>Permutations</h5>
<a 
 id="dx1-61001"></a>
                                                                                    

                                                                                    
<pre class="verbatim" id="verbatim-24">
typedef&#x00A0;PnlVectInt&#x00A0;PnlPermutation;
</pre>
<!--l. 1409--><p class="nopar" >
</p><!--l. 1411--><p class="noindent" >The <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlPermutation</span></span></span> type is actually nothing else than a vector of integers, i.e. a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlVectInt</span></span></span>. It is
used to store the partial pivoting with row interchanges transformation needed in the LU
decomposition. We use the <span 
class="ec-lmri-10x-x-109">Blas </span>convention for storing permutations. Consider a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlPermutation</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;p</span></span></span>
generated by a LU decomposition of a matrix <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">A</span></span></span> : to compute the decomposition, row <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">i</span></span></span> of <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">A</span></span></span> was
interchanged with row <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">p(i)</span></span></span>.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1420--><p class="noindent" ><a 
 id="dx1-61002"></a> <span class='ret'><a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 1423--><p class="noindent" ><a 
 id="dx1-61003"></a> <span class='ret'><a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_create</span></span>&#x00A0;(<span class='args'>int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> of size <span class='var'>n</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1426--><p class="noindent" ><a 
 id="dx1-61004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 1429--><p class="noindent" ><a 
 id="dx1-61005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>inv, const <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute in <span class='var'>inv</span> the inverse of the permutation <span class='var'>p</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1432--><p class="noindent" ><a 
 id="dx1-61006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_permute</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>px, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply a <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> to a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 1436--><p class="noindent" ><a 
 id="dx1-61007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_permute_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply a <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> to a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> in-place.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 1441--><p class="noindent" ><a 
 id="dx1-61008"></a>   <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_permute_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>px,   const   <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>x,   const
     <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply the inverse of <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> to a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 1445--><p class="noindent" ><a 
 id="dx1-61009"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_permute_inverse_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>x,  const  <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply the inverse of a <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> to a <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> in-place.
     </p></li>
     <li class="itemize">
     <!--l. 1450--><p class="noindent" ><a 
 id="dx1-61010"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_col_permute</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>pX,    const    <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>X,    const
     <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply a <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> to the columns of a matrix. <span class='var'>pX</span> contains the
     result of the permutation applied to <span class='var'>X</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1455--><p class="noindent" ><a 
 id="dx1-61011"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_row_permute</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>pX,    const    <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>X,    const
     <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply a <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> to the rows of a matrix. <span class='var'>pX</span> contains the result
     of the permutation applied to <span class='var'>X</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1460--><p class="noindent" ><a 
 id="dx1-61012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a permutation to a file.
     </p></li>
     <li class="itemize">
     <!--l. 1463--><p class="noindent" ><a 
 id="dx1-61013"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a permutation to the standard output.</p></li></ul>
<!--l. 1470--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.4   </span> <a 
 id="x1-620004.4"></a>Tridiagonal Matrices</h4>
<!--l. 1471--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.4.1   </span> <a 
 id="x1-630004.4.1"></a>Overview</h5>
<!--l. 1473--><p class="noindent" >The structures and functions related to tridiagonal matrices are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_tridiag_matrix.h</span></span></span>.
</p><!--l. 1476--><p class="noindent" >We only store the three main diagonals as three vectors.
<a 
 id="dx1-63001"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-25">
typedef&#x00A0;struct&#x00A0;PnlTridiagMat{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlTridiagMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows,&#x00A0;the&#x00A0;matrix&#x00A0;must&#x00A0;be&#x00A0;square&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*D;&#x00A0;/*!&#x003C;&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*DU;&#x00A0;/*!&#x003C;&#x00A0;upper&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*DL;&#x00A0;/*!&#x003C;&#x00A0;lower&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
}&#x00A0;PnlTridiagMat;
</pre>
<!--l. 1491--><p class="nopar" ><span class='var'>size</span> is the size of the matrix, <span class='var'>D</span> is an array of size <span class='var'>size</span> containing the diagonal terms. <span class='var'>DU</span>, <span class='var'>DL</span> are
two arrays of size <span class='var'>size-1</span> containing respectively the upper diagonal (<span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i,i</span><span 
class="rm-lmr-8">+1</span></sub>) and the lower diagonal
(<span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i</span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span><span 
class="lmmi-8">,i</span></sub>).
<a 
 id="dx1-63002"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-26">
typedef&#x00A0;struct&#x00A0;PnlTridiagMatLU{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlTridiagMatLU&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows,&#x00A0;the&#x00A0;matrix&#x00A0;must&#x00A0;be&#x00A0;square&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*D;&#x00A0;/*!&#x003C;&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*DU;&#x00A0;/*!&#x003C;&#x00A0;upper&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*DU2;&#x00A0;/*!&#x003C;&#x00A0;second&#x00A0;upper&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*DL;&#x00A0;/*!&#x003C;&#x00A0;lower&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*ipiv;&#x00A0;/*!&#x003C;&#x00A0;Permutation:&#x00A0;row&#x00A0;i&#x00A0;has&#x00A0;been&#x00A0;interchanged&#x00A0;with&#x00A0;row&#x00A0;ipiv(i)&#x00A0;*/
};
</pre>
<!--l. 1512--><p class="nopar" >This type is used to store the LU decomposition of a tridiagonal matrix.
</p><!--l. 1515--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.4.2   </span> <a 
 id="x1-640004.4.2"></a>Functions</h5>
<!--l. 1516--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-65000"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1518--><p class="noindent" ><a 
 id="dx1-65001"></a><a 
 id="x1-65000doc"></a> <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> with size 0
     </p></li>
     <li class="itemize">
     <!--l. 1520--><p class="noindent" ><a 
 id="dx1-65002"></a> <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create</span></span>&#x00A0;(<span class='args'>int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> with size <span class='var'>size</span>
     </p></li>
     <li class="itemize">
     <!--l. 1522--><p class="noindent" ><a 
 id="dx1-65003"></a> <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create_from_scalar</span></span>&#x00A0;(<span class='args'>int size, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> with the 3 diagonals filled with <span class='var'>x</span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1525--><p class="noindent" ><a 
 id="dx1-65004"></a> <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create_from_two_scalar</span></span>&#x00A0;(<span class='args'>int size, double
     x, double y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> with the diagonal filled with <span class='var'>x</span> and the upper
     and lower diagonals filled with <span class='var'>y</span>
     </p></li>
     <li class="itemize">
     <!--l. 1528--><p class="noindent" ><a 
 id="dx1-65005"></a>  <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create_from_ptr</span></span>&#x00A0;(<span class='args'>int  size,  const  double
     <span 
class="ts1-lmr10-x-x-109">*</span>lower_D, const double <span 
class="ts1-lmr10-x-x-109">*</span>D, const double <span 
class="ts1-lmr10-x-x-109">*</span>upper_D</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     </p></li>
     <li class="itemize">
     <!--l. 1532--><p class="noindent" ><a 
 id="dx1-65006"></a> <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create_from_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>mat</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a tridiagonal matrix from a full matrix (all the elements but the
     3 diagonal ones are ignored).
     </p></li>
     <li class="itemize">
     <!--l. 1536--><p class="noindent" ><a 
 id="dx1-65007"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_to_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a full matrix from a tridiagonal one.
     </p></li>
     <li class="itemize">
     <!--l. 1539--><p class="noindent" ><a 
 id="dx1-65008"></a> <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy a tridiagonal matrix.
     </p></li>
     <li class="itemize">
     <!--l. 1542--><p class="noindent" ><a 
 id="dx1-65009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy the content of <span class='var'>T</span> into <span class='var'>clone</span>
     </p></li>
     <li class="itemize">
     <!--l. 1545--><p class="noindent" ><a 
 id="dx1-65010"></a> <span class='ret'>void </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     </p></li>
     <li class="itemize">
     <!--l. 1547--><p class="noindent" ><a 
 id="dx1-65011"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> .</p></li></ul>
                                                                                    

                                                                                    
<!--l. 1552--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-66000"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements.</span></span>
If it is supported by the compiler, the following functions are declared inline. To speed up these
functions, you can use the macro constant <span 
class="ec-lmtt-10x-x-109">PNL_RANGE_CHECK_OFF</span>, see Section&#x00A0;1.3.2 for an
explanation. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1558--><p class="noindent" ><a 
 id="dx1-66001"></a><a 
 id="x1-66000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int d, int up, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set <span class='var'>self[d, d+up] = x</span>, <span class='var'>up</span> can be <span 
class="lmsy-10x-x-109">{-</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmsy-10x-x-109">}</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1560--><p class="noindent" ><a 
 id="dx1-66002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int d, int up</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Get <span class='var'>self[d, d+up]</span>, <span class='var'>up</span> can be <span 
class="lmsy-10x-x-109">{-</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmsy-10x-x-109">}</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1562--><p class="noindent" ><a 
 id="dx1-66003"></a> <span class='ret'>double <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int d, int up</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address <span class='var'>self[d, d+up] = x</span>, <span class='var'>up</span> can be <span 
class="lmsy-10x-x-109">{-</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmsy-10x-x-109">}</span>.</p></li></ul>
<!--l. 1566--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-67000"></a><span 
class="ec-lmbx-10x-x-109">Printing Matrix</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1568--><p class="noindent" ><a 
 id="dx1-67001"></a><a 
 id="x1-67000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a tri-diagonal matrix to a file.
     </p></li>
     <li class="itemize">
     <!--l. 1570--><p class="noindent" ><a 
 id="dx1-67002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a tridiagonal matrix to the standard output.</p></li></ul>
<!--l. 1574--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-68000"></a><span 
class="ec-lmbx-10x-x-109">Algebra operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1576--><p class="noindent" ><a 
 id="dx1-68001"></a><a 
 id="x1-68000doc"></a>     <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_plus_tridiag_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>     <span 
class="ts1-lmr10-x-x-109">*</span>lhs,     const
     <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix addition
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1578--><p class="noindent" ><a 
 id="dx1-68002"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_minus_tridiag_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>lhs,    const
     <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix substraction
     </p></li>
     <li class="itemize">
     <!--l. 1580--><p class="noindent" ><a 
 id="dx1-68003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar addition
     </p></li>
     <li class="itemize">
     <!--l. 1582--><p class="noindent" ><a 
 id="dx1-68004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar substraction
     </p></li>
     <li class="itemize">
     <!--l. 1584--><p class="noindent" ><a 
 id="dx1-68005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar multiplication
     </p></li>
     <li class="itemize">
     <!--l. 1586--><p class="noindent" ><a 
 id="dx1-68006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar division</p></li></ul>
<!--l. 1590--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-69000"></a><span 
class="ec-lmbx-10x-x-109">Element-wise operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1592--><p class="noindent" ><a 
 id="dx1-69001"></a><a 
 id="x1-69000doc"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_mult_tridiag_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>lhs,  const
     <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix term by term product
     </p></li>
     <li class="itemize">
     <!--l. 1594--><p class="noindent" ><a 
 id="dx1-69002"></a>   <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_div_tridiag_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>lhs,   const
     <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix term by term division
     </p></li>
     <li class="itemize">
     <!--l. 1596--><p class="noindent" ><a 
 id="dx1-69003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_map_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs)</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1601--><p class="noindent" ><a 
 id="dx1-69004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_map_tridiag_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const
     <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double, double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs, rhs)</span>.</p></li></ul>
<!--l. 1606--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-70000"></a><span 
class="ec-lmbx-10x-x-109">Standard matrix operations &amp; Linear systems</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1608--><p class="noindent" ><a 
 id="dx1-70001"></a><a 
 id="x1-70000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_mult_vect_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>mat, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In place matrix multiplication. The vector <span class='var'>lhs</span> must be different from <span class='var'>rhs</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1613--><p class="noindent" ><a 
 id="dx1-70002"></a>   <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_mult_vect</span></span>&#x00A0;(<span class='args'>const   <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>mat,   const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>vec</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Matrix multiplication
     </p></li>
     <li class="itemize">
     <!--l. 1616--><p class="noindent" ><a 
 id="dx1-70003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lAxpby</span></span>&#x00A0;(<span class='args'>double lambda, const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double mu, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>b := lambda A x + mu b</span>. When <span class='var'>mu==0</span>, the content of <span class='var'>b</span> is
     not used on input and instead <span class='var'>b</span> is resized to match <span class='var'>A*x</span>. Note that the vectors <span class='var'>x</span> and
     <span class='var'>b</span> must be different.
     </p></li>
     <li class="itemize">
     <!--l. 1621--><p class="noindent" ><a 
 id="dx1-70004"></a>  <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_scalar_prod</span></span>&#x00A0;(<span class='args'>const  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>x,const  <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>x&#8217; * A * y</span>
     </p></li>
     <li class="itemize">
     <!--l. 1624--><p class="noindent" ><a 
 id="dx1-70005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_syslin_inplace</span></span>&#x00A0;(<span class='args'> <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system M x = b. The solution is written into <span class='var'>b</span> on exit.
     On exit, <span class='var'>M</span> is modified and becomes unusable.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 1628--><p class="noindent" ><a 
 id="dx1-70006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system M x = b. On exit, <span class='var'>M</span> is modified and becomes
     unusable.
     </p></li>
     <li class="itemize">
     <!--l. 1631--><p class="noindent" ><a 
 id="dx1-70007"></a> <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>
     </p></li>
     <li class="itemize">
     <!--l. 1633--><p class="noindent" ><a 
 id="dx1-70008"></a> <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_create</span></span>&#x00A0;(<span class='args'>int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> with size <span class='var'>size</span>
     </p></li>
     <li class="itemize">
     <!--l. 1635--><p class="noindent" ><a 
 id="dx1-70009"></a> <span class='ret'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>mat</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> which is a copy of <span class='var'>mat</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1638--><p class="noindent" ><a 
 id="dx1-70010"></a>        <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>        <span 
class="ts1-lmr10-x-x-109">*</span>clone,        const
     <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>mat</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone  a  <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>  .  <span class='var'>clone</span>  must  already  exist,  no  memory  is
     allocated for the envelope.
     </p></li>
     <li class="itemize">
     <!--l. 1641--><p class="noindent" ><a 
 id="dx1-70011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>m</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>
     </p></li>
     <li class="itemize">
     <!--l. 1643--><p class="noindent" ><a 
 id="dx1-70012"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>
     </p></li>
     <li class="itemize">
     <!--l. 1645--><p class="noindent" ><a 
 id="dx1-70013"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_compute</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>LU, const <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  LU  factorisation  of  a  tridiagonal  matrix  <span class='var'>A</span>.  <span class='var'>LU</span>  must
     have already been created using <a 
href="#x1-70000doc">pnl_tridiag_mat_lu_new</a>. On exit, <span class='var'>LU</span> contains the
     decomposition which is suitable for use in <a 
href="#x1-70000doc">pnl_tridiag_mat_lu_syslin</a>.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 1650--><p class="noindent" ><a 
 id="dx1-70014"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_syslin_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>LU, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system <span class='var'>A x = b</span> where the matrix <span class='var'>LU</span> is given the LU
     decomposition of A previously computed by <a 
href="#x1-70000doc">pnl_tridiag_mat_lu_compute</a>. On exit, <span class='var'>b</span>
     is overwritten by the solution <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1655--><p class="noindent" ><a 
 id="dx1-70015"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>x,  <a 
href="#x1-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>LU,  const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system <span class='var'>A x = b</span> where the matrix <span class='var'>LU</span> is given the LU
     decomposition of A previously computed by <a 
href="#x1-70000doc">pnl_tridiag_mat_lu_compute</a>.</p></li></ul>
<!--l. 1663--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.5   </span> <a 
 id="x1-710004.5"></a>Band Matrices</h4>
<!--l. 1664--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.5.1   </span> <a 
 id="x1-720004.5.1"></a>Overview</h5>
<a 
 id="dx1-72001"></a>
                                                                                    

                                                                                    
<pre class="verbatim" id="verbatim-27">
typedef&#x00A0;struct
{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlBandMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;nu;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;of&#x00A0;upperdiagonals&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;nl;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;of&#x00A0;lowerdiagonals&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;m_band;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;of&#x00A0;the&#x00A0;band&#x00A0;storage&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;n_band;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;of&#x00A0;the&#x00A0;band&#x00A0;storage&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;&#x00A0;/*!&#x003C;&#x00A0;a&#x00A0;block&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;bands&#x00A0;*/
}&#x00A0;PnlBandMat;
</pre>
<!--l. 1683--><p class="nopar" >
</p><!--l. 1686--><p class="noindent" >The structures and functions related to band matrices are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_band_matrix.h</span></span></span>.
</p><!--l. 1690--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.5.2   </span> <a 
 id="x1-730004.5.2"></a>Functions</h5>
<!--l. 1691--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-74000"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1693--><p class="noindent" ><a 
 id="dx1-74001"></a><a 
 id="x1-74000doc"></a> <span class='ret'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a band matrix of size 0.
     </p></li>
     <li class="itemize">
     <!--l. 1696--><p class="noindent" ><a 
 id="dx1-74002"></a> <span class='ret'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_create</span></span>&#x00A0;(<span class='args'>int m, int n, int nl, int nu</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a band matrix of size <span class='var'>m x n</span> with <span class='var'>nl</span> lower diagonals and <span class='var'>nu</span> upper
     diagonals.
     </p></li>
     <li class="itemize">
     <!--l. 1701--><p class="noindent" ><a 
 id="dx1-74003"></a> <span class='ret'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_create_from_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM, int nl,
     int nu</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Extract a band matrix from a <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> .
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1705--><p class="noindent" ><a 
 id="dx1-74004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a band matrix.
     </p></li>
     <li class="itemize">
     <!--l. 1708--><p class="noindent" ><a 
 id="dx1-74005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy the band matrix <span class='var'>M</span> into <span class='var'>clone</span>. No new <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> is created.
     </p></li>
     <li class="itemize">
     <!--l. 1713--><p class="noindent" ><a 
 id="dx1-74006"></a> <span class='ret'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_copy</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new band matrix which is a copy of <span class='var'>BM</span>. Each band matrix
     owns its data array.
     </p></li>
     <li class="itemize">
     <!--l. 1717--><p class="noindent" ><a 
 id="dx1-74007"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_to_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a full matrix from a band matrix.
     </p></li>
     <li class="itemize">
     <!--l. 1720--><p class="noindent" ><a 
 id="dx1-74008"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM, int m, int n, int nl, int nu</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize <span class='var'>BM</span> to store a <span class='var'>m x n</span> band matrix with <span class='var'>nu</span> upper diagonals and
     <span class='var'>nl</span> lower diagonals.</p></li></ul>
<!--l. 1726--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-75000"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements.</span></span>
If it is supported by the compiler, the following functions are declared inline. To speed up these
functions, you can use the macro constant <span 
class="ec-lmtt-10x-x-109">PNL_RANGE_CHECK_OFF</span>, see Section&#x00A0;1.3.2 for an
explanation. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1732--><p class="noindent" ><a 
 id="dx1-75001"></a><a 
 id="x1-75000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1736--><p class="noindent" ><a 
 id="dx1-75002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_get</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i,j</span></sub>.
     </p></li>
     <li class="itemize">
     <!--l. 1740--><p class="noindent" ><a 
 id="dx1-75003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address <span 
class="rm-lmr-10x-x-109">&amp;(</span><span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i,j</span></sub><span 
class="rm-lmr-10x-x-109">)</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1743--><p class="noindent" ><a 
 id="dx1-75004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_set_all</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all the elements of <span class='var'>M</span> to <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1747--><p class="noindent" ><a 
 id="dx1-75005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_print_as_full</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a band matrix in a full format.</p></li></ul>
<!--l. 1752--><p class="noindent" ><span class="subparagraphHead"><a 
 id="x1-76000"></a><span 
class="ec-lmbx-10x-x-109">Element wise operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1755--><p class="noindent" ><a 
 id="dx1-76001"></a><a 
 id="x1-76000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place addition, <span class='var'>lhs += x</span>
     </p></li>
     <li class="itemize">
     <!--l. 1759--><p class="noindent" ><a 
 id="dx1-76002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place substraction <span class='var'>lhs -= x</span>
     </p></li>
     <li class="itemize">
     <!--l. 1763--><p class="noindent" ><a 
 id="dx1-76003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = lhs ./ x</span>
     </p></li>
     <li class="itemize">
     <!--l. 1767--><p class="noindent" ><a 
 id="dx1-76004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = lhs * x</span>
     </p></li>
     <li class="itemize">
     <!--l. 1771--><p class="noindent" ><a 
 id="dx1-76005"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_plus_band_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>lhs,  const  <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place addition, <span class='var'>lhs += rhs</span>
     </p></li>
     <li class="itemize">
     <!--l. 1775--><p class="noindent" ><a 
 id="dx1-76006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_minus_band_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place substraction <span class='var'>lhs -= rhs</span>
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1779--><p class="noindent" ><a 
 id="dx1-76007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_inv_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term inversion <span class='var'>lhs = 1 ./ rhs</span>
     </p></li>
     <li class="itemize">
     <!--l. 1782--><p class="noindent" ><a 
 id="dx1-76008"></a>     <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_div_band_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a>     <span 
class="ts1-lmr10-x-x-109">*</span>lhs,     const
     <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term division <span class='var'>lhs = lhs ./ rhs</span>
     </p></li>
     <li class="itemize">
     <!--l. 1786--><p class="noindent" ><a 
 id="dx1-76009"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_mult_band_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>lhs,    const
     <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term multiplication <span class='var'>lhs = lhs .* rhs</span>
     </p></li>
     <li class="itemize">
     <!--l. 1790--><p class="noindent" ><a 
 id="dx1-76010"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_map</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>lhs,    const    <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>rhs,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs)</span>
     </p></li>
     <li class="itemize">
     <!--l. 1794--><p class="noindent" ><a 
 id="dx1-76011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_map_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs)</span>
     </p></li>
     <li class="itemize">
     <!--l. 1797--><p class="noindent" ><a 
 id="dx1-76012"></a>   <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_map_band_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>lhs,   const
     <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double,double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs,rhs)</span></p></li></ul>
<!--l. 1803--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-77000"></a><span 
class="ec-lmbx-10x-x-109">Standard matrix operations &amp; Linear system</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1805--><p class="noindent" ><a 
 id="dx1-77001"></a><a 
 id="x1-77000doc"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lAxpby</span></span>&#x00A0;(<span class='args'>double  lambda,  const  <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>A,  const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double mu, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>b := lambda A x + mu b</span>. When <span class='var'>mu==0</span>, the content of <span class='var'>b</span> is
     not used on input and instead <span class='var'>b</span> is resized to match the size of <span class='var'>A*x</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1810--><p class="noindent" ><a 
 id="dx1-77002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_mult_vect_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM,
     const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>y = BM * x</span>
     </p></li>
     <li class="itemize">
     <!--l. 1814--><p class="noindent" ><a 
 id="dx1-77003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_syslin_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with <span class='var'>M</span> a <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> . <span 
class="ec-lmbx-10x-x-109">Note </span>that M
     is modified on output and becomes unusable. On exit, the solution <span class='var'>x</span> is stored in <span class='var'>b</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1820--><p class="noindent" ><a 
 id="dx1-77004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x,<a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with <span class='var'>M</span> a <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> . <span 
class="ec-lmbx-10x-x-109">Note </span>that M
     is modified on output and becomes unusable.
     </p></li>
     <li class="itemize">
     <!--l. 1824--><p class="noindent" ><a 
 id="dx1-77005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lu</span></span>&#x00A0;(<span class='args'><a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  LU  decomposition  with  partial  pivoting  with  row
     interchanges. On exit, <span class='var'>BM</span> is enlarged to store the LU decomposition. On exit, <span class='var'>p</span> stores
     the permutation applied to the rows. Note that the Lapack format is used to store <span class='var'>p</span>,
     this format differs from the one used by <a 
href="#x1-610004.3.5"><span class='struct'>PnlPermutation</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 1831--><p class="noindent" ><a 
 id="dx1-77006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lu_syslin_inplace</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p,
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the band linear system <span class='var'>M x = b</span> where <span class='var'>M</span> is the LU decomposition
     computed by <a 
href="#x1-77000doc">pnl_band_mat_lu</a> and <span class='var'>p</span> the associated permutation. On exit, the solution
     <span class='var'>x</span> is stored in <span class='var'>b</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1836--><p class="noindent" ><a 
 id="dx1-77007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lu_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>p, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the band linear system <span class='var'>M x = b</span> where <span class='var'>M</span> is the LU decomposition
     computed by <a 
href="#x1-77000doc">pnl_band_mat_lu</a> and <span class='var'>p</span> the associated permutation.</p></li></ul>
<!--l. 1843--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.6   </span> <a 
 id="x1-780004.6"></a>Sparse Matrices</h4>
                                                                                    

                                                                                    
<!--l. 1844--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.6.1   </span> <a 
 id="x1-790004.6.1"></a>Short description</h5>
<!--l. 1845--><p class="noindent" >The structures and functions related to matrices are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_sp_matrix.h</span></span></span>.
<a 
 id="dx1-79001"></a>
<a 
 id="dx1-79002"></a>
<a 
 id="dx1-79003"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-28">
typedef&#x00A0;struct&#x00A0;_PnlSpMat
{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;a&#x00A0;PnlSpMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;columns&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;nz;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;non-zero&#x00A0;elements&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*J;&#x00A0;/*!&#x003C;&#x00A0;column&#x00A0;indices,&#x00A0;vector&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*I;&#x00A0;/*!&#x003C;&#x00A0;row&#x00A0;offset&#x00A0;integer&#x00A0;vector,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;array[I[i]]&#x00A0;is&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;of&#x00A0;row&#x00A0;i.
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Vector&#x00A0;of&#x00A0;size&#x00A0;(m+1)&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;of&#x00A0;size&#x00A0;nzmax*/
&#x00A0;&#x00A0;int&#x00A0;nzmax;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
}&#x00A0;PnlSpMat;

typedef&#x00A0;struct&#x00A0;_PnlSpMatInt
{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;a&#x00A0;PnlSpMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;columns&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;nz;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;non-zero&#x00A0;elements&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*J;&#x00A0;/*!&#x003C;&#x00A0;column&#x00A0;indices,&#x00A0;vector&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*I;&#x00A0;/*!&#x003C;&#x00A0;row&#x00A0;offset&#x00A0;integer&#x00A0;vector,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;array[I[i]]&#x00A0;is&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;of&#x00A0;row&#x00A0;i.
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Vector&#x00A0;of&#x00A0;size&#x00A0;(m+1)&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;nzmax;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
}&#x00A0;PnlSpMatInt;

typedef&#x00A0;struct&#x00A0;_PnlSpMatComplex
{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;a&#x00A0;PnlSpMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
                                                                                    

                                                                                    
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;columns&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;nz;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;non-zero&#x00A0;elements&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*J;&#x00A0;/*!&#x003C;&#x00A0;column&#x00A0;indices,&#x00A0;vector&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*I;&#x00A0;/*!&#x003C;&#x00A0;row&#x00A0;offset&#x00A0;integer&#x00A0;vector,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;array[I[i]]&#x00A0;is&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;of&#x00A0;row&#x00A0;i.
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Vector&#x00A0;of&#x00A0;size&#x00A0;(m+1)&#x00A0;*/
&#x00A0;&#x00A0;dcomplex&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;nzmax;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
}&#x00A0;PnlSpMatComplex;
</pre>
<!--l. 1903--><p class="nopar" >
</p><!--l. 1905--><p class="noindent" >The non zero elements of row <span class='var'>i</span> are stored in <span class='var'>array</span> between the indices <span class='var'>I[i]</span> and <span class='var'>I[i+1]-1</span>. The array <span class='var'>J</span>
contains the column indices of every element of <span class='var'>array</span>. <br 
class="newline" />
</p><!--l. 1910--><p class="noindent" >Sparse matrices are defined using the internal template approach and can be used for integer, float
or complex base data according to the following table </p>
<div class="center" 
>
<!--l. 1912--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-9" class="tabular" 
 
><colgroup id="TBL-9-1g"><col 
id="TBL-9-1" /><col 
id="TBL-9-2" /><col 
id="TBL-9-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-9-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-1-1"  
class="td11">base type</td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-1-2"  
class="td11">prefix                      </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-1-3"  
class="td11">type                   </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-2-1"  
class="td11">double     </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-2-2"  
class="td11">pnl_sp_mat             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-2-3"  
class="td11">PnlSpMat            </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-3-1"  
class="td11">int          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-3-2"  
class="td11">pnl_sp_mat_int       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-3-3"  
class="td11">PnlSpMatInt        </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-4-1"  
class="td11">dcomplex </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-4-2"  
class="td11">pnl_sp_mat_complex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-4-3"  
class="td11">PnlSpMatComplex</td></tr></table>                              </div></div>
<!--l. 1924--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.6.2   </span> <a 
 id="x1-800004.6.2"></a>Functions</h5>
<!--l. 1926--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-81000"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1929--><p class="noindent" ><a 
 id="dx1-81001"></a><a 
 id="x1-81000doc"></a> <span class='ret'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty sparse matrix.
     </p></li>
     <li class="itemize">
     <!--l. 1931--><p class="noindent" ><a 
 id="dx1-81002"></a> <span class='ret'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_create</span></span>&#x00A0;(<span class='args'>int m, int n, int nzmax</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a sparse matrix with size <span class='var'>m x n</span> designed to hold at most <span class='var'>nzmax</span>
     non zero elements.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 1934--><p class="noindent" ><a 
 id="dx1-81003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>dest, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone <span class='var'>src</span> into <span class='var'>dest</span>, which is automatically resized. On output, <span class='var'>dest</span> and
     <span class='var'>src</span> are equal but independent.
     </p></li>
     <li class="itemize">
     <!--l. 1937--><p class="noindent" ><a 
 id="dx1-81004"></a> <span class='ret'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_copy</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an independent copy of <span class='var'>src</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1939--><p class="noindent" ><a 
 id="dx1-81005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Delete a sparse matrix.
     </p></li>
     <li class="itemize">
     <!--l. 1941--><p class="noindent" ><a 
 id="dx1-81006"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int m, int n, int nzmax</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize an existing <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> to become a <span class='var'>m x n</span> sparse matrices holding
     at most <span class='var'>nzmax</span>. Note that no old data are kept except if <span class='var'>M-&#x003E;m</span> is left unchanged and
     we only call this function to increase <span class='var'>M-&#x003E;nzmax</span>. Return <span class='var'>OK</span> or <span class='var'>FAIL</span>.
     </p></li>
     <li class="itemize">
     <!--l. 1946--><p class="noindent" ><a 
 id="dx1-81007"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_sp_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a dense <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> from a spare one.
     </p></li>
     <li class="itemize">
     <!--l. 1948--><p class="noindent" ><a 
 id="dx1-81008"></a> <span class='ret'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_create_from_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a sparse matrix from a dense one.
     </p></li>
     <li class="itemize">
     <!--l. 1950--><p class="noindent" ><a 
 id="dx1-81009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_create_from_file</span></span>&#x00A0;(<span class='args'>char *file</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Read a sparse matrix from the file with name <span class='var'>file</span>. We use the Matrix Market
     Exchange Format
                                                                                    

                                                                                    
</p>
     <pre class="verbatim" id="verbatim-29">
     M&#x00A0;&#x00A0;N&#x00A0;&#x00A0;L&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x003C;---&#x00A0;rows,&#x00A0;columns,&#x00A0;entries
     I1&#x00A0;&#x00A0;J1&#x00A0;&#x00A0;A(I1,&#x00A0;J1)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x003C;--+
     I2&#x00A0;&#x00A0;J2&#x00A0;&#x00A0;A(I2,&#x00A0;J2)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x00A0;&#x00A0;&#x00A0;|
     I3&#x00A0;&#x00A0;J3&#x00A0;&#x00A0;A(I3,&#x00A0;J3)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x00A0;&#x00A0;&#x00A0;|--&#x00A0;L&#x00A0;lines
     &#x00A0;&#x00A0;&#x00A0;&#x00A0;.&#x00A0;.&#x00A0;.&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x00A0;&#x00A0;&#x00A0;|
     IL&#x00A0;JL&#x00A0;&#x00A0;A(IL,&#x00A0;JL)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x003C;--+
     &#x00A0;&#x00A0;
</pre>
     <!--l. 1959--><p class="nopar" >The format <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">(I1,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;J1)</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;A(I1,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;J1)</span></span></span> is also accepted. Anything after a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">#</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">%</span></span></span> is ignored up to the
     end of the line.</p></li></ul>
<!--l. 1963--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-82000"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1966--><p class="noindent" ><a 
 id="dx1-82001"></a><a 
 id="x1-82000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set <span class='var'>M[i,j] = x</span>. This function increases <span class='var'>M-&#x003E;nzmax</span> if necessary.
     </p></li>
     <li class="itemize">
     <!--l. 1969--><p class="noindent" ><a 
 id="dx1-82002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>M[i,j]</span>. If <span class='var'>M</span> has no entry with such an index, zero is returned.</p></li></ul>
<!--l. 1974--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-83000"></a><span 
class="ec-lmbx-10x-x-109">Applying external operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1977--><p class="noindent" ><a 
 id="dx1-83001"></a><a 
 id="x1-83000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Add <span class='var'>x</span> to all non zero entries of <span class='var'>M</span>. To apply the operation to all entries
     including the zero ones, first convert <span class='var'>M</span> to a dense matrix and use <a 
href="#x1-52000doc">pnl_mat_plus_scalar</a>.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 1981--><p class="noindent" ><a 
 id="dx1-83002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Substract  <span class='var'>x</span>  to  all  non  zero  entries  of  <span class='var'>M</span>.  To  apply  the  operation
     to  all  entries  including  the  zero  ones,  first  convert  <span class='var'>M</span>  to  a  dense  matrix  and  use
     <a 
href="#x1-52000doc">pnl_mat_minus_scalar</a>.
     </p></li>
     <li class="itemize">
     <!--l. 1985--><p class="noindent" ><a 
 id="dx1-83003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar multiplication
     </p></li>
     <li class="itemize">
     <!--l. 1987--><p class="noindent" ><a 
 id="dx1-83004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar division</p></li></ul>
<!--l. 1992--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-84000"></a><span 
class="ec-lmbx-10x-x-109">Standard matrix operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 1995--><p class="noindent" ><a 
 id="dx1-84001"></a><a 
 id="x1-84000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a sparse matrix to a file descriptor using the format <span class='var'>(row, col) &#8211;&#x003E;
     val</span>. The file can be read by <a 
href="#x1-81000doc">pnl_sp_mat_create_from_file</a>.
     </p></li>
     <li class="itemize">
     <!--l. 1998--><p class="noindent" ><a 
 id="dx1-84002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-84000doc">pnl_sp_mat_fprint</a> but print to standard output.
     </p></li>
     <li class="itemize">
     <!--l. 2001--><p class="noindent" ><a 
 id="dx1-84003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_mult_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>y = A x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 2004--><p class="noindent" ><a 
 id="dx1-84004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_lAxpby</span></span>&#x00A0;(<span class='args'>double lambda, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x,
     double b, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>y := lambda A x + b y</span>. When <span class='var'>b=0</span>, the content of <span class='var'>y</span> is not
     used on input and instead <span class='var'>y</span> is resized to match <span class='var'>A*x</span>. The vectors <span class='var'>x</span> and <span class='var'>y</span> must be
     different.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 2009--><p class="noindent" ><a 
 id="dx1-84005"></a> <span class='ret'>void </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_plus_sp_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>res, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A,
     const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place addition: <span class='var'>res = A + B</span>.
     </p></li>
     <li class="itemize">
     <!--l. 2011--><p class="noindent" ><a 
 id="dx1-84006"></a> <span class='ret'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_sp_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the sum of <span class='var'>A</span> and <span class='var'>B</span>.
     </p></li>
     <li class="itemize">
     <!--l. 2013--><p class="noindent" ><a 
 id="dx1-84007"></a> <span class='ret'>void </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_kron_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>result, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const
     <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place Kroenecker product of <span class='var'>A</span> and <span class='var'>B</span>.
     </p></li>
     <li class="itemize">
     <!--l. 2015--><p class="noindent" ><a 
 id="dx1-84008"></a> <span class='ret'><a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_kron</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the Kroenecker product of <span class='var'>A</span> and <span class='var'>B</span>.</p></li></ul>
<!--l. 2019--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-85000"></a><span 
class="ec-lmbx-10x-x-109">Comparison functions</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2022--><p class="noindent" ><a 
 id="dx1-85001"></a><a 
 id="x1-85000doc"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_isequal</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, double abserr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two sparse matrices are equal up to <span class='var'>err</span> component&#8211;wise. The
     error <span class='var'>err</span> is either relative or absolute depending on the magnitude of the components.
     Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </p></li>
     <li class="itemize">
     <!--l. 2024--><p class="noindent" ><a 
 id="dx1-85002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_isequal_abs</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, double
     relerr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two sparse matrices are equal up to an absolute error <span class='var'>abserr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </p></li>
     <li class="itemize">
     <!--l. 2026--><p class="noindent" ><a 
 id="dx1-85003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_isequal_rel</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, double err</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test  if  two  sparse  matrices  are  equal  up  to  a  relative  error  <span class='var'>relerr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 2031--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.7   </span> <a 
 id="x1-860004.7"></a>Hyper Matrices</h4>
<!--l. 2032--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.7.1   </span> <a 
 id="x1-870004.7.1"></a>Short description</h5>
<!--l. 2034--><p class="noindent" >The Hyper matrix types and related functions are defined in the header <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_matrix.h</span></span></span>.
<a 
 id="dx1-87001"></a>
<a 
 id="dx1-87002"></a>
<a 
 id="dx1-87003"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-30">
typedef&#x00A0;struct&#x00A0;PnlHmat{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlHmat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;ndim;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;dimensions&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*dims;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;values&#x00A0;of&#x00A0;the&#x00A0;ndim&#x00A0;dimensions&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;dim_1&#x00A0;*...*dim_ndim&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*pdims;&#x00A0;/*!&#x003C;&#x00A0;array&#x00A0;of&#x00A0;size&#x00A0;ndim,&#x00A0;s.t.&#x00A0;pdims[i]&#x00A0;=&#x00A0;dims[ndim-1]&#x00A0;x&#x00A0;...&#x00A0;dims[i+1]
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;with&#x00A0;pdims[ndim&#x00A0;-&#x00A0;1]&#x00A0;=&#x00A0;1&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;*/
}&#x00A0;PnlHmat;

typedef&#x00A0;struct&#x00A0;PnlHmatInt{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlHmatInt&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;ndim;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;dimensions&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*dims;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;value&#x00A0;of&#x00A0;the&#x00A0;ndim&#x00A0;dimensions&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;dim_1&#x00A0;*...*dim_ndim&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*pdims;&#x00A0;/*!&#x003C;&#x00A0;array&#x00A0;of&#x00A0;size&#x00A0;ndim,&#x00A0;s.t.&#x00A0;pdims[i]&#x00A0;=&#x00A0;dims[ndim-1]&#x00A0;x&#x00A0;...&#x00A0;dims[i+1]
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;with&#x00A0;pdims[ndim&#x00A0;-&#x00A0;1]&#x00A0;=&#x00A0;1&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;*/
}&#x00A0;PnlHmatInt;

typedef&#x00A0;struct&#x00A0;PnlHmatComplex{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlHmatComplex&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;ndim;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;dimensions&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*dims;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;value&#x00A0;of&#x00A0;the&#x00A0;ndim&#x00A0;dimensions&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;dim_1&#x00A0;*...*dim_ndim&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;*pdims;&#x00A0;/*!&#x003C;&#x00A0;array&#x00A0;of&#x00A0;size&#x00A0;ndim,&#x00A0;s.t.&#x00A0;pdims[i]&#x00A0;=&#x00A0;dims[ndim-1]&#x00A0;x&#x00A0;...&#x00A0;dims[i+1]
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;with&#x00A0;pdims[ndim&#x00A0;-&#x00A0;1]&#x00A0;=&#x00A0;1&#x00A0;*/
&#x00A0;&#x00A0;dcomplex&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;*/
}&#x00A0;PnlHmatComplex;
</pre>
                                                                                    

                                                                                    
<!--l. 2079--><p class="nopar" ><span class='var'>ndim</span> is the number of dimensions, <span class='var'>dim</span> is an array to store the size of each dimension and <span class='var'>nm</span>
contains the product of the sizes of each dimension. <span class='var'>array</span> is an array of size <span class='var'>mn</span> containing the data.
The integer array <span class='var'>pdims</span> is used to create the one&#8211;to&#8211;one map between the natural indexing and the
linear indexing used in <span class='var'>array</span>.
</p><!--l. 2087--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.7.2   </span> <a 
 id="x1-880004.7.2"></a>Functions</h5>
<!--l. 2088--><p class="noindent" >These functions exist for all types of hypermatrices no matter what the basic type is. The following
conventions are used to name functions operating on hypermatrices. Here is the table of prefixes
used for the different basic types.
</p>
<div class="center" 
>
<!--l. 2092--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-10" class="tabular" 
 
><colgroup id="TBL-10-1g"><col 
id="TBL-10-1" /><col 
id="TBL-10-2" /><col 
id="TBL-10-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-10-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-1-1"  
class="td11">base type</td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-1-2"  
class="td11">prefix                   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-1-3"  
class="td11">type                  </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-2-1"  
class="td11">double     </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-2-2"  
class="td11">pnl_hmat             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-2-3"  
class="td11">PnlHmat            </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-3-1"  
class="td11">int          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-3-2"  
class="td11">pnl_hmat_int       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-3-3"  
class="td11">PnlHmatInt        </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-4-1"  
class="td11">dcomplex </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-4-2"  
class="td11">pnl_hmat_complex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-4-3"  
class="td11">PnlHmatComplex</td></tr></table>                                  </div></div>
<!--l. 2104--><p class="noindent" >In this paragraph, we present the functions operating on <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> which exist for all types. To
deduce the prototypes of these functions for other basic types, one must replace <span 
class="ec-lmtt-10x-x-109">pnl_hmat </span>and
<span 
class="ec-lmtt-10x-x-109">double </span>according the above table.
</p>
<!--l. 2110--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-89000"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2112--><p class="noindent" ><a 
 id="dx1-89001"></a><a 
 id="x1-89000doc"></a> <span class='ret'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 2115--><p class="noindent" ><a 
 id="dx1-89002"></a> <span class='ret'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_create</span></span>&#x00A0;(<span class='args'>int ndim, const int <span 
class="ts1-lmr10-x-x-109">*</span>dims</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> with <span class='var'>ndim</span> dimensions and the size of each dimension
     is given by the entries of the integer array <span class='var'>dims</span>
     </p></li>
     <li class="itemize">
     <!--l. 2121--><p class="noindent" ><a 
 id="dx1-89003"></a> <span class='ret'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_create_from_scalar</span></span>&#x00A0;(<span class='args'>int ndim, const int <span 
class="ts1-lmr10-x-x-109">*</span>dims, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> with <span class='var'>ndim</span> dimensions given by <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="lmmi-8">i</span></sub><span class='var'><span 
class="lmmi-10x-x-109">dims</span><span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">]</span></span> filled with
     <span class='var'>x</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 2126--><p class="noindent" ><a 
 id="dx1-89004"></a> <span class='ret'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_create_from_ptr</span></span>&#x00A0;(<span class='args'>int ndim, const int <span 
class="ts1-lmr10-x-x-109">*</span>dims, const double
     <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)
     </p></li>
     <li class="itemize">
     <!--l. 2128--><p class="noindent" ><a 
 id="dx1-89005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>H</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a>
     </p></li>
     <li class="itemize">
     <!--l. 2131--><p class="noindent" ><a 
 id="dx1-89006"></a> <span class='ret'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy a <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 2134--><p class="noindent" ><a 
 id="dx1-89007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone a <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 2137--><p class="noindent" ><a 
 id="dx1-89008"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H, int ndim, const int <span 
class="ts1-lmr10-x-x-109">*</span>dims</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> .</p></li></ul>
<!--l. 2141--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-90000"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2144--><p class="noindent" ><a 
 id="dx1-90001"></a><a 
 id="x1-90000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int <span 
class="ts1-lmr10-x-x-109">*</span>tab, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the element of index <span class='var'>tab</span> to <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 2147--><p class="noindent" ><a 
 id="dx1-90002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int <span 
class="ts1-lmr10-x-x-109">*</span>tab</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the value of the element of index <span class='var'>tab</span>
     </p></li>
     <li class="itemize">
     <!--l. 2150--><p class="noindent" ><a 
 id="dx1-90003"></a> <span class='ret'>double<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int <span 
class="ts1-lmr10-x-x-109">*</span>tab</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address of self[tab] for use as a lvalue.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 2153--><p class="noindent" ><a 
 id="dx1-90004"></a> <span class='ret'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_wrap_hmat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H, int <span 
class="ts1-lmr10-x-x-109">*</span>t</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a true <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> not a pointer holding the data <span class='var'>H(t,:,:)</span>. Note that <span class='var'>t</span>
     must be of size <span class='var'>ndim-2</span> and that it cannot be checked within the function. The returned
     matrix shares its data with <span class='var'>H</span>, it is only a view not a true copy.
     </p></li>
     <li class="itemize">
     <!--l. 2159--><p class="noindent" ><a 
 id="dx1-90005"></a> <span class='ret'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_hmat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H, int <span 
class="ts1-lmr10-x-x-109">*</span>t</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a true <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> not a pointer holding the data <span class='var'>H(t,:)</span>. Note that <span class='var'>t</span>
     must be of size <span class='var'>ndim-1</span> and that it cannot be checked within the function. The returned
     vector shares its data with <span class='var'>H</span>, it is only a view not a true copy.
</p>
     </li></ul>
<!--l. 2168--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-91000"></a><span 
class="ec-lmbx-10x-x-109">Printing hypermatrices</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2171--><p class="noindent" ><a 
 id="dx1-91001"></a><a 
 id="x1-91000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print an hypermatrix.</p></li></ul>
<!--l. 2175--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-92000"></a><span 
class="ec-lmbx-10x-x-109">Term by term operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2178--><p class="noindent" ><a 
 id="dx1-92001"></a><a 
 id="x1-92000doc"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_plus_hmat</span></span>&#x00A0;(<span class='args'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>lhs += rhs</span>.
     </p></li>
     <li class="itemize">
     <!--l. 2181--><p class="noindent" ><a 
 id="dx1-92002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x1-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>lhs *= x</span> where x is a real number.</p></li></ul>
<!--l. 2401--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.8   </span> <a 
 id="x1-930004.8"></a>Iterative Solvers</h4>
                                                                                    

                                                                                    
<!--l. 2402--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.8.1   </span> <a 
 id="x1-940004.8.1"></a>Overview</h5>
<!--l. 2404--><p class="noindent" >The structures and functions related to solvers are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_linalgsolver.h</span></span></span>.
<a 
 id="dx1-94001"></a>
<a 
 id="dx1-94002"></a>
<a 
 id="dx1-94003"></a>
<a 
 id="dx1-94004"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-31">
typedef&#x00A0;struct&#x00A0;_PnlIterationBase&#x00A0;PnlIterationBase;
typedef&#x00A0;struct&#x00A0;_PnlCgSolver&#x00A0;PnlCgSolver;
typedef&#x00A0;struct&#x00A0;_PnlBicgSolver&#x00A0;PnlBicgSolver;
typedef&#x00A0;struct&#x00A0;_PnlGmresSolver&#x00A0;PnlGmresSolver;

struct&#x00A0;_PnlIterationBase
{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVectXXX&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;iteration;
&#x00A0;&#x00A0;int&#x00A0;max_iter;
&#x00A0;&#x00A0;double&#x00A0;normb;
&#x00A0;&#x00A0;double&#x00A0;tol_;
&#x00A0;&#x00A0;double&#x00A0;resid;
&#x00A0;&#x00A0;int&#x00A0;error;
&#x00A0;&#x00A0;/*&#x00A0;char&#x00A0;*&#x00A0;&#x00A0;err_msg;&#x00A0;*/
};

/*&#x00A0;When&#x00A0;you&#x00A0;repeatedly&#x00A0;use&#x00A0;iterative&#x00A0;solvers,&#x00A0;do&#x00A0;not&#x00A0;malloc&#x00A0;each&#x00A0;time&#x00A0;*/
struct&#x00A0;_PnlCgSolver
{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlCgSolver&#x00A0;&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;r;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;z;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;p;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;q;
&#x00A0;&#x00A0;double&#x00A0;rho;
&#x00A0;&#x00A0;double&#x00A0;oldrho;
&#x00A0;&#x00A0;double&#x00A0;beta;
&#x00A0;&#x00A0;double&#x00A0;alpha;
&#x00A0;&#x00A0;PnlIterationBase&#x00A0;*&#x00A0;iter;
}&#x00A0;;

struct&#x00A0;_PnlBicgSolver
{
                                                                                    

                                                                                    
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlBicgSolver&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;double&#x00A0;rho_1,&#x00A0;rho_2,&#x00A0;alpha,&#x00A0;beta,&#x00A0;omega;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;p;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;phat;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;s;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;shat;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;t;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;v;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;r;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;&#x00A0;rtilde;
&#x00A0;&#x00A0;PnlIterationBase&#x00A0;*&#x00A0;iter;
}&#x00A0;;

struct&#x00A0;_PnlGmresSolver
{
&#x00A0;&#x00A0;/**
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlGmresSolver&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;restart;
&#x00A0;&#x00A0;double&#x00A0;beta;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;s;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;cs;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;sn;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;w;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;r;
&#x00A0;&#x00A0;PnlMat&#x00A0;*&#x00A0;H;
&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;v[MAX_RESTART];
&#x00A0;&#x00A0;PnlIterationBase&#x00A0;*iter;
&#x00A0;&#x00A0;PnlIterationBase&#x00A0;*iter_inner;
}&#x00A0;;
</pre>
<!--l. 2490--><p class="nopar" >
</p><!--l. 2492--><p class="noindent" >A Left preconditioner solves the problem :
</p>
<div class="math-display" >
<img 
src="pnl-manual16x.png" alt="PM x = P b,
" class="math-display"  /></div>
<!--l. 2494--><p class="noindent" >and whereas right preconditioner solves
</p>
<div class="math-display" >
<img 
src="pnl-manual17x.png" alt="M  Py = b,    P y = x.
" class="math-display"  /></div>
<!--l. 2505--><p class="noindent" >More information is given in <span 
class="ec-lmri-10x-x-109">Saad, Yousef (2003). Iterative methods for sparse linear systems (2nd</span>
<span 
class="ec-lmri-10x-x-109">ed. ed.). SIAM. ISBN 0898715342. OCLC 51266114</span>. The reader will find in this book
some discussion about right or/and left preconditioner and a description of the following
algorithms.
</p><!--l. 2510--><p class="noindent" >These algorithms, we implemented with a left preconditioner. Right preconditioner can be easily
computed changing matrix vector multiplication operator from <span 
class="lmmi-10x-x-109">M</span><span 
class="lmmi-10x-x-109">&#x00A0;x </span>to <span 
class="lmmi-10x-x-109">M</span><span 
class="lmmi-10x-x-109">&#x00A0;P</span><sub><span 
class="lmmi-8">R</span></sub><span 
class="lmmi-10x-x-109">&#x00A0;x </span>and solving
<span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">R</span></sub><span 
class="lmmi-10x-x-109">y </span><span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">x </span>at the end of algorithm.
</p><!--l. 2515--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.8.2   </span> <a 
 id="x1-950004.8.2"></a>Functions</h5>
<!--l. 2517--><p class="noindent" >Three methods are implemented : Conjugate Gradient, BICGstab and GMRES with restart. For
each of them a structure is created to store temporary vectors used in the algorithm. In some cases,
we have to apply iterative methods more than once : for example to solve at each time step a
discrete form of an elliptic problem come from parabolic problem. In the cases, do not call the
constructor and destructor at each time, but instead use the initialization and solve
procedures.
</p><!--l. 2524--><p class="noindent" >Formally we have,
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-32">
Create&#x00A0;iterative&#x00A0;method
For&#x00A0;each&#x00A0;time&#x00A0;step
&#x00A0;&#x00A0;Initialisation&#x00A0;of&#x00A0;iterative&#x00A0;method
&#x00A0;&#x00A0;Solve&#x00A0;linear&#x00A0;system&#x00A0;link&#x00A0;to&#x00A0;elliptic&#x00A0;problem
end&#x00A0;for
free&#x00A0;iterative&#x00A0;method
</pre>
<!--l. 2532--><p class="nopar" >
</p><!--l. 2534--><p class="noindent" >In these functions, we don&#8217;t use any particular matrix structure. We give the matrix vector
multiplication as a parameter of the solver.
</p>
<!--l. 2537--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-96000"></a><span 
class="ec-lmbx-10x-x-109">Conjugate Gradient method</span></span>
Only available for symmetric and positive matrices. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2541--><p class="noindent" ><a 
 id="dx1-96001"></a><a 
 id="x1-96000doc"></a> <span class='ret'><a 
href="#x1-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x1-940004.8.1"><span class='struct'>PnlCgSolver</span></a>
     </p></li>
     <li class="itemize">
     <!--l. 2543--><p class="noindent" ><a 
 id="dx1-96002"></a> <span class='ret'><a 
href="#x1-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_create</span></span>&#x00A0;(<span class='args'>int Size, int max-iter, double tolerance</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-940004.8.1"><span class='struct'>PnlCgSolver</span></a> pointer.
     </p></li>
     <li class="itemize">
     <!--l. 2545--><p class="noindent" ><a 
 id="dx1-96003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_initialisation</span></span>&#x00A0;(<span class='args'><a 
href="#x1-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Initialisation of the solver at the beginning of iterative method.
     </p></li>
     <li class="itemize">
     <!--l. 2547--><p class="noindent" ><a 
 id="dx1-96004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Destructor of iterative solver
     </p></li>
     <li class="itemize">
     <!--l. 2549--><p class="noindent" ><a 
 id="dx1-96005"></a>   <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_solve</span></span>&#x00A0;(<span class='args'>void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix   vector-product)(const   void   <span 
class="ts1-lmr10-x-x-109">*</span>,   const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>,  const  double,  const  double,  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>),  const  void  <span 
class="ts1-lmr10-x-x-109">*</span>Matrix-Data,
     void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix vector-product-PC)(const void <span 
class="ts1-lmr10-x-x-109">*</span>, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, const double, const
     double, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>), const void <span 
class="ts1-lmr10-x-x-109">*</span>PC-Data, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x1-940004.8.1"><span class='struct'>PnlCgSolver</span></a>
                                                                                    

                                                                                    
     <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  the  linear  system  matrix  vector-product  is  the  matrix  vector
     multiplication  function  matrix  vector-product-PC  is  the  preconditionner  function
     Matrix-Data &amp; PC-Data is data to compute matrix vector multiplication.</p></li></ul>
<!--l. 2552--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-97000"></a><span 
class="ec-lmbx-10x-x-109">BICG stab</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2554--><p class="noindent" ><a 
 id="dx1-97001"></a><a 
 id="x1-97000doc"></a> <span class='ret'><a 
href="#x1-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x1-940004.8.1"><span class='struct'>PnlBicgSolver</span></a>.
     </p></li>
     <li class="itemize">
     <!--l. 2556--><p class="noindent" ><a 
 id="dx1-97002"></a> <span class='ret'><a 
href="#x1-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_create</span></span>&#x00A0;(<span class='args'>int Size, int max-iter, double tolerance</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> pointer.
     </p></li>
     <li class="itemize">
     <!--l. 2558--><p class="noindent" ><a 
 id="dx1-97003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_initialisation</span></span>&#x00A0;(<span class='args'><a 
href="#x1-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Initialisation of the solver at the beginning of iterative method.
     </p></li>
     <li class="itemize">
     <!--l. 2560--><p class="noindent" ><a 
 id="dx1-97004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Destructor of iterative solver
     </p></li>
     <li class="itemize">
     <!--l. 2562--><p class="noindent" ><a 
 id="dx1-97005"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_solve</span></span>&#x00A0;(<span class='args'>void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix  vector-product)(const  void  <span 
class="ts1-lmr10-x-x-109">*</span>,  const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>,  const  double,  const  double,  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>),  const  void  <span 
class="ts1-lmr10-x-x-109">*</span>Matrix-Data,
     void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix vector-product-PC)(const void <span 
class="ts1-lmr10-x-x-109">*</span>, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, const double, const
     double, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>), const void <span 
class="ts1-lmr10-x-x-109">*</span>PC-Data, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x1-940004.8.1"><span class='struct'>PnlBicgSolver</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  the  linear  system  matrix  vector-product  is  the  matrix  vector
     multiplication  function  matrix  vector-product-PC  is  the  preconditioner  function
     Matrix-Data &amp; PC-Data is data to compute matrix vector multiplication.</p></li></ul>
<!--l. 2566--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-98000"></a><span 
class="ec-lmbx-10x-x-109">GMRES with restart</span></span>
See <span 
class="ec-lmri-10x-x-109">Saad, Yousef (2003) </span>for a discussion about the restart parameter. For GMRES we need to
store at the p-th iteration <span 
class="lmmi-10x-x-109">p </span>vectors of the same size of the right and side. It could be
very expensive in term of memory allocation. So GMRES with restart algorithm stop if
<span 
class="lmmi-10x-x-109">p </span><span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">restart </span>and restarts the algorithm with the previously computed solution as initial
guess.
                                                                                    

                                                                                    
</p><!--l. 2573--><p class="noindent" >Note that if restart equals <span 
class="lmmi-10x-x-109">m</span>, we have a classical GMRES algorithm.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2576--><p class="noindent" ><a 
 id="dx1-98001"></a><a 
 id="x1-98000doc"></a> <span class='ret'><a 
href="#x1-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x1-940004.8.1"><span class='struct'>PnlGmresSolver</span></a>
     </p></li>
     <li class="itemize">
     <!--l. 2578--><p class="noindent" ><a 
 id="dx1-98002"></a> <span class='ret'><a 
href="#x1-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_create</span></span>&#x00A0;(<span class='args'>int Size, int max-iter, int restart,
     double tolerance</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x1-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> pointer.
     </p></li>
     <li class="itemize">
     <!--l. 2580--><p class="noindent" ><a 
 id="dx1-98003"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_initialisation</span></span>&#x00A0;(<span class='args'><a 
href="#x1-940004.8.1"><span class='struct'>PnlGmresSolver</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>Solver,  const  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Initialisation of the solver at the beginning of iterative method.
     </p></li>
     <li class="itemize">
     <!--l. 2582--><p class="noindent" ><a 
 id="dx1-98004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Destructor of iterative solver
     </p></li>
     <li class="itemize">
     <!--l. 2584--><p class="noindent" ><a 
 id="dx1-98005"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_solve</span></span>&#x00A0;(<span class='args'>void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix  vector-product)(const  void  <span 
class="ts1-lmr10-x-x-109">*</span>,  const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>,  const  double,  const  double,  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>),  const  void  <span 
class="ts1-lmr10-x-x-109">*</span>Matrix-Data,
     void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix vector-product-PC)(const void <span 
class="ts1-lmr10-x-x-109">*</span>, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, const double, const
     double, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>), const void <span 
class="ts1-lmr10-x-x-109">*</span>PC-Data, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x1-940004.8.1"><span class='struct'>PnlGmresSolver</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  the  linear  system  matrix  vector-product  is  the  matrix  vector
     multiplication  function  matrix  vector-product-PC  is  the  preconditionner  function
     Matrix-Data &amp; PC-Data is data to compute matrix vector multiplication.</p></li></ul>
<!--l. 2589--><p class="noindent" >In the next paragraph, we write all the solvers for <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> . This will be done as follows: construct
an application matrix vector.
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-33">
static&#x00A0;void&#x00A0;pnl_mat_mult_vect_applied(const&#x00A0;void&#x00A0;*mat,&#x00A0;const&#x00A0;PnlVect&#x00A0;*vec,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;double&#x00A0;a&#x00A0;,&#x00A0;const&#x00A0;double&#x00A0;b,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVect&#x00A0;*lhs)
{pnl_mat_lAxpby(a,&#x00A0;(PnlMat*)mat,&#x00A0;vec,&#x00A0;b,&#x00A0;lhs);}
</pre>
<!--l. 2596--><p class="nopar" >and give it as the parameter of the iterative method
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-34">
int&#x00A0;pnl_mat_cg_solver_solve(const&#x00A0;PnlMat&#x00A0;*&#x00A0;Matrix,&#x00A0;const&#x00A0;PnlMat&#x00A0;*&#x00A0;PC,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;x,&#x00A0;const&#x00A0;PnlVect&#x00A0;*b,&#x00A0;PnlCgSolver&#x00A0;*&#x00A0;Solver)
{&#x00A0;return&#x00A0;pnl_cg_solver_solve(pnl_mat_mult_vect_applied,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Matrix,&#x00A0;pnl_mat_mult_vect_applied,
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;PC,&#x00A0;x,&#x00A0;b,&#x00A0;Solver);}
</pre>
<!--l. 2604--><p class="nopar" >
</p><!--l. 2606--><p class="noindent" >In practice, we cannot define all iterative methods for all structures. With this implementation, the
user can easily : </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2609--><p class="noindent" >implement right precondioner,
     </p></li>
     <li class="itemize">
     <!--l. 2610--><p class="noindent" >implement  method  with  sparse  matrix  and  diagonal  preconditioner,  or  special
     combination of this form <span 
class="lmmi-10x-x-109">&#x2026;</span></p></li></ul>
<!--l. 2615--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-99000"></a><span 
class="ec-lmbx-10x-x-109">Iterative algorithms for </span><a 
href="#x1-470004.3.1"><span class='struct'><span 
class="ec-lmbx-10x-x-109">PnlMat</span></span></a> </span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 2619--><p class="noindent" ><a 
 id="dx1-99001"></a><a 
 id="x1-99000doc"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_cg_solver_solve</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>PC, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x1-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with preconditionner PC.
     </p></li>
     <li class="itemize">
     <!--l. 2621--><p class="noindent" ><a 
 id="dx1-99002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_bicg_solver_solve</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>PC, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x1-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with preconditionner PC.
     </p></li>
     <li class="itemize">
     <!--l. 2623--><p class="noindent" ><a 
 id="dx1-99003"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_gmres_solver_solve</span></span>&#x00A0;(<span class='args'>const  <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>M,  const  <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>PC,
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x1-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with preconditionner PC.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-1000005"></a>Cumulative distribution Functions</h3>
<!--l. 3--><p class="noindent" >The functions related to this chapter are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_cdf.h</span></span></span>.
</p><!--l. 5--><p class="noindent" >For various distribution functions, we provide functions named <span class='var'>pnl_cdf_xxx</span> where <span class='var'>xxx</span> is
the abbreviation of the distribution name. All these functions are based on the same
prototype
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual18x.png" alt="               &#x222B; x
p = 1- q;  p =    density(u)du
" class="math-display"  /></div>
</td></tr></table>
<!--l. 10--><p class="nopar" >
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 13--><p class="noindent" ><span class='var'>which</span> If <span class='var'>which=1</span>, it computes <span class='var'>p</span> and <span class='var'>q</span>. If <span class='var'>which=2</span>, it computes <span class='var'>x</span>. For higher values
     of <span class='var'>which</span> it computes one the parameters characterizing the distribution using all the
     others, <span class='var'>p, q, x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 17--><p class="noindent" ><span class='var'>p</span> the probability <span 
class="lmex-10">&#x222B;</span>
  <sup><span 
class="lmmi-8">x</span></sup><span 
class="lmmi-10x-x-109">density</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">u</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">du</span>
     </p></li>
     <li class="itemize">
     <!--l. 18--><p class="noindent" ><span class='var'>q</span> <span 
class="rm-lmr-10x-x-109">= 1 </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">p</span>
     </p></li>
     <li class="itemize">
     <!--l. 19--><p class="noindent" ><span class='var'>x</span> the upper bound of the integral
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 20--><p class="noindent" ><span class='var'>status</span> an integer which indicates on exit the success of the computation. (0) if calculation
     completed correctly. (-I) if the input parameter number I was out of range. (1) if the
     answer appears to be lower than the lowest search bound. (2) if the answer appears to
     be higher than the greatest search bound. (3) if <span 
class="lmmi-10x-x-109">p </span><span 
class="rm-lmr-10x-x-109">+ </span><span 
class="lmmi-10x-x-109">q</span><span 
class="lmmi-10x-x-109">&#x2260;</span><span 
class="rm-lmr-10x-x-109">1</span>.
     </p></li>
     <li class="itemize">
     <!--l. 25--><p class="noindent" ><span class='var'>bound</span> is undefined if STATUS is 0. Bound exceeded by parameter number I if STATUS
     is negative. Lower search bound if STATUS is 1. Upper search bound if STATUS is 2.</p></li></ul>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 31--><p class="noindent" ><a 
 id="dx1-100001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_bet</span></span>&#x00A0;(<span class='args'>int <span 
class="ts1-lmr10-x-x-109">*</span>which, double <span 
class="ts1-lmr10-x-x-109">*</span>p, double <span 
class="ts1-lmr10-x-x-109">*</span>q, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>y, double
     <span 
class="ts1-lmr10-x-x-109">*</span>a, double <span 
class="ts1-lmr10-x-x-109">*</span>b, int <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function BETA distribution.
     </p></li>
     <li class="itemize">
     <!--l. 36--><p class="noindent" ><a 
 id="dx1-100002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_bin</span></span>&#x00A0;(<span class='args'>int <span 
class="ts1-lmr10-x-x-109">*</span>which, double <span 
class="ts1-lmr10-x-x-109">*</span>p, double <span 
class="ts1-lmr10-x-x-109">*</span>q, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>xn, double
     <span 
class="ts1-lmr10-x-x-109">*</span>pr, double <span 
class="ts1-lmr10-x-x-109">*</span>ompr, int <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function BINa distribution.
     </p></li>
     <li class="itemize">
     <!--l. 41--><p class="noindent" ><a 
 id="dx1-100003"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_chi</span></span>&#x00A0;(<span class='args'>int  <span 
class="ts1-lmr10-x-x-109">*</span>which,  double  <span 
class="ts1-lmr10-x-x-109">*</span>p,  double  <span 
class="ts1-lmr10-x-x-109">*</span>q,  double  <span 
class="ts1-lmr10-x-x-109">*</span>x,  double  <span 
class="ts1-lmr10-x-x-109">*</span>df,  int
     <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function CHI-Square distribution.
     </p></li>
     <li class="itemize">
     <!--l. 46--><p class="noindent" ><a 
 id="dx1-100004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_chn</span></span>&#x00A0;(<span class='args'>int <span 
class="ts1-lmr10-x-x-109">*</span>which, double <span 
class="ts1-lmr10-x-x-109">*</span>p, double <span 
class="ts1-lmr10-x-x-109">*</span>q, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>df, double
     <span 
class="ts1-lmr10-x-x-109">*</span>pnonc, int <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function Non-central Chi-Square distribution.
     </p></li>
     <li class="itemize">
     <!--l. 51--><p class="noindent" ><a 
 id="dx1-100005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_f</span></span>&#x00A0;(<span class='args'>int <span 
class="ts1-lmr10-x-x-109">*</span>which, double <span 
class="ts1-lmr10-x-x-109">*</span>p, double <span 
class="ts1-lmr10-x-x-109">*</span>q, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>dfn, double
     <span 
class="ts1-lmr10-x-x-109">*</span>dfd, int <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function F distribution.
     </p></li>
     <li class="itemize">
     <!--l. 56--><p class="noindent" ><a 
 id="dx1-100006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_fnc</span></span>&#x00A0;(<span class='args'>int <span 
class="ts1-lmr10-x-x-109">*</span>which, double <span 
class="ts1-lmr10-x-x-109">*</span>p, double <span 
class="ts1-lmr10-x-x-109">*</span>q, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>dfn, double
     <span 
class="ts1-lmr10-x-x-109">*</span>dfd, double <span 
class="ts1-lmr10-x-x-109">*</span>pnonc, int <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function Non-central F distribution.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 61--><p class="noindent" ><a 
 id="dx1-100007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_gam</span></span>&#x00A0;(<span class='args'>int <span 
class="ts1-lmr10-x-x-109">*</span>which, double <span 
class="ts1-lmr10-x-x-109">*</span>p, double <span 
class="ts1-lmr10-x-x-109">*</span>q, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>shape,
     double <span 
class="ts1-lmr10-x-x-109">*</span>rate, int <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function GAMma distribution. Note that the
     parameter <span class='var'>rate</span> is <span class='var'>1/scale</span>. The density writes <span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">) = 1</span><span 
class="lmmi-10x-x-109">&#x2215;</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">s</span><sup><span 
class="lmmi-8">a</span></sup><span 
class="rm-lmr-10x-x-109">&#x0393;(</span><span 
class="lmmi-10x-x-109">a</span><span 
class="rm-lmr-10x-x-109">))</span><span 
class="lmmi-10x-x-109">x</span><sup><span 
class="lmmi-8">a</span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sup><span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmsy8-">-</span><span 
class="lmmi-8">x&#x2215;s</span></sup> with <span class='var'>scale=s</span>
     and <span class='var'>shape=1/rate=a</span>.
     </p></li>
     <li class="itemize">
     <!--l. 68--><p class="noindent" ><a 
 id="dx1-100008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_nbn</span></span>&#x00A0;(<span class='args'>int <span 
class="ts1-lmr10-x-x-109">*</span>which, double <span 
class="ts1-lmr10-x-x-109">*</span>p, double <span 
class="ts1-lmr10-x-x-109">*</span>q, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>xn, double
     <span 
class="ts1-lmr10-x-x-109">*</span>pr, double <span 
class="ts1-lmr10-x-x-109">*</span>ompr, int <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function Negative BiNomial distribution.
     </p></li>
     <li class="itemize">
     <!--l. 73--><p class="noindent" ><a 
 id="dx1-100009"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_nor</span></span>&#x00A0;(<span class='args'>int  <span 
class="ts1-lmr10-x-x-109">*</span>which,  double  <span 
class="ts1-lmr10-x-x-109">*</span>p,  double  <span 
class="ts1-lmr10-x-x-109">*</span>q,  double  <span 
class="ts1-lmr10-x-x-109">*</span>x,  double  <span 
class="ts1-lmr10-x-x-109">*</span>mean,
     double <span 
class="ts1-lmr10-x-x-109">*</span>sd, int <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function NORmal distribution.
     </p></li>
     <li class="itemize">
     <!--l. 78--><p class="noindent" ><a 
 id="dx1-100010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_poi</span></span>&#x00A0;(<span class='args'>int <span 
class="ts1-lmr10-x-x-109">*</span>which, double <span 
class="ts1-lmr10-x-x-109">*</span>p, double <span 
class="ts1-lmr10-x-x-109">*</span>q, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>xlam, int
     <span 
class="ts1-lmr10-x-x-109">*</span>status, double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function POIsson distribution.
     </p></li>
     <li class="itemize">
     <!--l. 83--><p class="noindent" ><a 
 id="dx1-100011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf_t</span></span>&#x00A0;(<span class='args'>int <span 
class="ts1-lmr10-x-x-109">*</span>which, double <span 
class="ts1-lmr10-x-x-109">*</span>p, double <span 
class="ts1-lmr10-x-x-109">*</span>q, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>df, int <span 
class="ts1-lmr10-x-x-109">*</span>status,
     double <span 
class="ts1-lmr10-x-x-109">*</span>bound</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative Distribution Function T distribution.
     </p></li>
     <li class="itemize">
     <!--l. 88--><p class="noindent" ><a 
 id="dx1-100012"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdfchi2n</span></span>&#x00A0;(<span class='args'>double x, double df, double ncparam</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the cumulative density function at <span class='var'>x</span> of the non central <span 
class="lmmi-10x-x-109">&#x03C7;</span><sup><span 
class="rm-lmr-8">2</span></sup>
     distribution with <span class='var'>df</span> degrees of freedom and non centrality parameter <span class='var'>ncparam</span>.
     </p></li>
     <li class="itemize">
     <!--l. 93--><p class="noindent" ><a 
 id="dx1-100013"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdfbchi2n</span></span>&#x00A0;(<span class='args'>double x, double df, double ncparam, double beta, double <span 
class="ts1-lmr10-x-x-109">*</span>P</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Store in <span class='var'>P</span> the cumulative density function at <span class='var'>x</span> of the random variable
     <span class='var'>beta <span 
class="ts1-lmr10-x-x-109">*</span>X</span> where <span class='var'>X</span> is non central <span 
class="lmmi-10x-x-109">&#x03C7;</span><sup><span 
class="rm-lmr-8">2</span></sup> random variable with <span class='var'>df</span> degrees of freedom and non
     centrality parameter <span class='var'>ncparam</span>.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 101--><p class="noindent" ><a 
 id="dx1-100014"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_normal_density</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Normal density function.
     </p></li>
     <li class="itemize">
     <!--l. 104--><p class="noindent" ><a 
 id="dx1-100015"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdfnor</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative normal distribution function.
     </p></li>
     <li class="itemize">
     <!--l. 107--><p class="noindent" ><a 
 id="dx1-100016"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cdf2nor</span></span>&#x00A0;(<span class='args'>double a, double b, double r</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative    bivariate    normal    distribution    function,    returns
     <img 
src="pnl-manual19x.png" alt="-&#x221A;-1--2
2&#x03C0; 1-r"  class="frac" align="middle" /> <span 
class="lmex-10">&#x222B;</span>
              <sub><span 
class="lmsy8-">-&#x221E;</span></sub><sup><span 
class="lmmi-8">a</span></sup> <span 
class="lmex-10">&#x222B;</span>
 <sub><span 
class="lmsy8-">-&#x221E;</span></sub><sup><span 
class="lmmi-8">b</span></sup><span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmsy8-">-</span><img 
src="pnl-manual20x.png" alt="x2-2rxy+y2-
 2(1-r2)"  class="frac" align="middle" />
                     </sup><span 
class="lmmi-10x-x-109">dxdy.</span>
     </p></li>
     <li class="itemize">
     <!--l. 112--><p class="noindent" ><a 
 id="dx1-100017"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_inv_cdfnor</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Inverse of the cumulative normal distribution function.</p></li></ul>
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">6   </span> <a 
 id="x1-1010006"></a>Random Number Generators</h3>
<!--l. 3--><p class="noindent" >The functionalities described in this chapter are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_random.h</span></span></span>.
</p><!--l. 6--><p class="noindent" >Random number generators should be called through the new <span 
class="ec-lmri-10x-x-109">rng </span>interface based on the
<a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> object. This interface uses reentrant functions and is suitable for multi-threaded
applications.
</p><!--l. 10--><p class="noindent" >The older <span 
class="ec-lmri-10x-x-109">rand </span>interface is kept for compatibility purposes only and should not be used in new code.
</p><div class="table">
                                                                                    

                                                                                    
<!--l. 12--><p class="noindent" ><a 
 id="x1-1010012"></a></p><hr class="float" /><div class="float" 
>
                                                                                    

                                                                                    
<div class="tabular"> <table id="TBL-11" class="tabular" 
 
><colgroup id="TBL-11-1g"><col 
id="TBL-11-1" /></colgroup><colgroup id="TBL-11-2g"><col 
id="TBL-11-2" /></colgroup><colgroup id="TBL-11-3g"><col 
id="TBL-11-3" /></colgroup><colgroup id="TBL-11-4g"><col 
id="TBL-11-4" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-11-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-1-1"  
class="td11">Random generator</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-1-2"  
class="td11">index                                  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-1-3"  
class="td11">Type  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-1-4"  
class="td11">Info                     </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-11-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-2-1"  
class="td11">KNUTH              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-2-2"  
class="td11">PNL_RNG_KNUTH            </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-2-3"  
class="td11">pseudo</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-2-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-3-1"  
class="td11">MRGK3              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-3-2"  
class="td11">PNL_RNG_MRGK3             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-3-3"  
class="td11">pseudo</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-3-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-4-1"  
class="td11">MRGK5              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-4-2"  
class="td11">PNL_RNG_MRGK5             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-4-3"  
class="td11">pseudo</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-4-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-5-1"  
class="td11">SHUFL               </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-5-2"  
class="td11">PNL_RNG_SHUFL              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-5-3"  
class="td11">pseudo</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-5-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-6-1"  
class="td11">L&#8217;ECUYER          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-6-2"  
class="td11">PNL_RNG_L_ECUYER       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-6-3"  
class="td11">pseudo</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-6-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-7-1"  
class="td11">TAUSWORTHE    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-7-2"  
class="td11">PNL_RNG_TAUSWORTHE  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-7-3"  
class="td11">pseudo</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-7-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-8-1"  
class="td11">MERSENNE        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-8-2"  
class="td11">PNL_RNG_MERSENNE      </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-8-3"  
class="td11">pseudo</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-8-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-9-1"  
class="td11">SQRT                 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-9-2"  
class="td11">PNL_RNG_SQRT                </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-9-3"  
class="td11">quasi  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-9-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-10-1"  
class="td11">HALTON             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-10-2"  
class="td11">PNL_RNG_HALTON           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-10-3"  
class="td11">quasi  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-10-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-11-1"  
class="td11">FAURE               </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-11-2"  
class="td11">PNL_RNG_FAURE             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-11-3"  
class="td11">quasi  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-11-4"  
class="td11">                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-12-1"  
class="td11">SOBOL_I4          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-12-2"  
class="td11">PNL_RNG_SOBOL_I4        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-12-3"  
class="td11">quasi  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-12-4"  
class="td11">uses 32 bit intergers</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-13-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-13-1"  
class="td11">SOBOL_I8          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-13-2"  
class="td11">PNL_RNG_SOBOL2_I8       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-13-3"  
class="td11">quasi  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-13-4"  
class="td11">uses 64 bit intergers</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-11-14-"><td  style="white-space:nowrap; text-align:left;" id="TBL-11-14-1"  
class="td11">NIEDERREITER  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-14-2"  
class="td11">PNL_RNG_NIEDERREITER</td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-14-3"  
class="td11">quasi  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-11-14-4"  
class="td11">                 </td></tr></table>     </div>
<br /> <div class="caption" 
><span class="id">Table&#x00A0;2: </span><span  
class="content">Indices of the random generators</span></div><!--tex4ht:label?: x1-1010012 -->
                                                                                    

                                                                                    
</div><hr class="endfloat" />
</div>
<h4 class="subsectionHead"><span class="titlemark">6.1   </span> <a 
 id="x1-1020006.1"></a>The rng interface</h4>
<!--l. 38--><p class="noindent" >It is possible to create several random number generators each with its own state variable so that
they can evolve independently in a shared memory environment. These generators are suitable for
use in multi-threaded programs.
<a 
 id="dx1-102001"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-35">
typedef&#x00A0;struct&#x00A0;_PnlRng&#x00A0;PnlRng;
struct&#x00A0;_PnlRng
{
&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;&#x00A0;int&#x00A0;type;&#x00A0;/*!&#x003C;&#x00A0;generator&#x00A0;type&#x00A0;*
&#x00A0;&#x00A0;void&#x00A0;(*Compute)(PnlRng&#x00A0;*g,&#x00A0;double&#x00A0;*sample);&#x00A0;/*!&#x003C;&#x00A0;the&#x00A0;function&#x00A0;to&#x00A0;compute&#x00A0;the
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;next&#x00A0;number&#x00A0;in&#x00A0;the&#x00A0;sequence&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;rand_or_quasi;&#x00A0;/*!&#x003C;&#x00A0;can&#x00A0;be&#x00A0;PNL_MC&#x00A0;or&#x00A0;PNL_QMC&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;dimension;&#x00A0;/*!&#x003C;&#x00A0;dimension&#x00A0;of&#x00A0;the&#x00A0;space&#x00A0;in&#x00A0;which&#x00A0;we&#x00A0;draw&#x00A0;the&#x00A0;samples&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;counter;&#x00A0;/*!&#x003C;&#x00A0;counter&#x00A0;=&#x00A0;number&#x00A0;of&#x00A0;samples&#x00A0;already&#x00A0;drawn&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;has_gauss;&#x00A0;/*!&#x003C;&#x00A0;Is&#x00A0;a&#x00A0;gaussian&#x00A0;deviate&#x00A0;available?&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;gauss;&#x00A0;/*!&#x003C;&#x00A0;If&#x00A0;has_gauss==1,&#x00A0;gauss&#x00A0;a&#x00A0;gaussian&#x00A0;sample&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;size_state;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;in&#x00A0;bytes&#x00A0;of&#x00A0;the&#x00A0;state&#x00A0;variable&#x00A0;*/
&#x00A0;&#x00A0;void&#x00A0;*state;&#x00A0;/*!&#x003C;&#x00A0;state&#x00A0;of&#x00A0;the&#x00A0;random&#x00A0;generator&#x00A0;*/
};
</pre>
<!--l. 59--><p class="nopar" >
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 63--><p class="noindent" ><a 
 id="dx1-102002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">**</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 65--><p class="noindent" ><a 
 id="dx1-102003"></a> <span class='ret'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_create</span></span>&#x00A0;(<span class='args'>int type</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> corresponding to <span class='var'>type</span> which can be any of the values
     <span class='var'>PNL_RNG_XXX</span>  listed  in  Table&#x00A0;2  which  correspond  to  <span 
class="ec-lmbx-10x-x-109">pseudo </span>random  number
     generators. Once a generator has been created, you <span 
class="ec-lmbx-10x-x-109">must </span>call <a 
href="#x1-1020006.1">pnl_rng_sseed</a> before
     using it.
     </p></li>
     <li class="itemize">
     <!--l. 71--><p class="noindent" ><a 
 id="dx1-102004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_sseed</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng, unsigned long int s</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the seed of the genrator <span class='var'>rng</span> using <span class='var'>s</span>. If <span class='var'>s=0</span>, then a default seed
     (depending on the generator) is used.
     </p></li>
     <li class="itemize">
     <!--l. 75--><p class="noindent" ><a 
 id="dx1-102005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_sdim</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng, int dim</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the dimension of the state space for a QMC generator and initializes
                                                                                    

                                                                                    
     it accordingly. Returns OK if the generator has been initialized properly and FAIL
     otherwise.
     </p></li>
     <li class="itemize">
     <!--l. 79--><p class="noindent" ><a 
 id="dx1-102006"></a> <span class='ret'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a copy of <span class='var'>rng</span>.
     </p></li>
     <li class="itemize">
     <!--l. 82--><p class="noindent" ><a 
 id="dx1-102007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>dest, const <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy the content of <span class='var'>src</span> into the already existing basis <span class='var'>dest</span>. On exit, <span class='var'>src</span>
     and <span class='var'>dest</span> are identical but independent.
     </p></li>
     <li class="itemize">
     <!--l. 87--><p class="noindent" ><a 
 id="dx1-102008"></a> <span class='ret'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_dcmt_create_id</span></span>&#x00A0;(<span class='args'>int id, ulong seed</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a generator with type <span class='var'>PNL_RNG_DCMT</span> and identifier <span class='var'>id</span>. Two
     generators with different <span class='var'>id</span>s are independent. Note that the returned generator must
     be  initialized  with  <a 
href="#x1-1020006.1">pnl_rng_sseed</a>  before  usage.  The  identifier  <span class='var'>id</span>  can  for  instance
     correspond to the thread number or the processor rank in parallel computing.
     </p></li>
     <li class="itemize">
     <!--l. 94--><p class="noindent" ><a 
 id="dx1-102009"></a> <span class='ret'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">**</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_dcmt_create_array_id</span></span>&#x00A0;(<span class='args'>int start_id, int max_id, ulong
     seed, int <span 
class="ts1-lmr10-x-x-109">*</span>count</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create  an  array  of  generators  with  types  <span class='var'>PNL_RNG_DCMT</span>  and
     identifiers linearly varying between <span class='var'>start_id</span> and <span class='var'>max_id</span>. The number of generators
     created is <span class='var'>max_id - start_id + 1</span>. All the generators are independent. Note that each
     generator of the returned array must be initialized with <a 
href="#x1-1020006.1">pnl_rng_sseed</a> before usage.
     </p></li>
     <li class="itemize">
     <!--l. 102--><p class="noindent" ><a 
 id="dx1-102010"></a> <span class='ret'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">**</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_dcmt_create_array</span></span>&#x00A0;(<span class='args'>int n, ulong seed, int <span 
class="ts1-lmr10-x-x-109">*</span>count</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create  an  array  of  <span class='var'>n</span>  independent  DCMT.  <span class='var'>seed</span>  is  the  seed  used  to
     initialize the Mersenne Twister generator internally used to find new DCMT. On exit,
     <span class='var'>count</span> contains the number of generators actually created. Before using the generators,
     you must initialize each of them by calling the function <a 
href="#x1-1020006.1">pnl_rng_sseed</a> <span class='var'>count</span> times.</p></li></ul>
<!--l. 111--><p class="noindent" >Some auxiliary functions internally used (to be used with caution) </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 113--><p class="noindent" ><a 
 id="dx1-102011"></a> <span class='ret'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> .
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 115--><p class="noindent" ><a 
 id="dx1-102012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_init</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng, int type</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Initialize  an  empty  <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a>  as  returned  by  <a 
href="#x1-1020006.1">pnl_rng_new</a>  to  become
     a  generator  of  type  <span class='var'>type</span>  which  can  be  any  of  the  values  <span class='var'>PNL_RNG_XXX</span>
     listed  in  Table&#x00A0;2  which  correspond  to  <span 
class="ec-lmbx-10x-x-109">pseudo </span>random  number  generators.  Calling
     <a 
href="#x1-1020006.1">pnl_rng_create</a> is equivalent to calling first <a 
href="#x1-1020006.1">pnl_rng_new</a> and then <a 
href="#x1-1020006.1">pnl_rng_init</a>.
     </p></li>
     <li class="itemize">
     <!--l. 122--><p class="noindent" ><a 
 id="dx1-102013"></a> <span class='ret'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_get_from_id</span></span>&#x00A0;(<span class='args'>int id</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the global generator described by its macro name. The variable
     <span class='var'>id</span> can be any of the values <span class='var'>PNL_RNG_XXX</span> listed in Table&#x00A0;2.</p></li></ul>
<!--l. 129--><p class="noindent" >The following functions return one sample from the specified distribution. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 131--><p class="noindent" ><a 
 id="dx1-102014"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_bernoulli</span></span>&#x00A0;(<span class='args'>double p, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Bernouilli law on <span 
class="lmsy-10x-x-109">{</span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmsy-10x-x-109">} </span>with parameter <span class='var'>p</span>.
     </p></li>
     <li class="itemize">
     <!--l. 135--><p class="noindent" ><a 
 id="dx1-102015"></a> <span class='ret'>long</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_poisson</span></span>&#x00A0;(<span class='args'>double lambda, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Poisson law with parameter <span class='var'>lambda</span>.
     </p></li>
     <li class="itemize">
     <!--l. 139--><p class="noindent" ><a 
 id="dx1-102016"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_exp</span></span>&#x00A0;(<span class='args'>double lambda, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Exponential law with parameter <span class='var'>lambda</span>.
     </p></li>
     <li class="itemize">
     <!--l. 143--><p class="noindent" ><a 
 id="dx1-102017"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_dblexp</span></span>&#x00A0;(<span class='args'>double lambda_p, double lambda_m, double p, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the asymmetric exponential distribution with
     density
</p>
     <table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual21x.png" alt="p&#x03BB;pe-&#x03BB;py1{y&#x003E;0} + (1 - p)&#x03BB;m e-&#x03BB;m|y|1{y&#x003C;0}
" class="math-display"  /></div>
                                                                                    

                                                                                    
     </td></tr></table>
     <!--l. 149--><p class="nopar" >where <span 
class="lmmi-10x-x-109">&#x03BB;</span><sub><span 
class="lmmi-8">p</span></sub> <span 
class="lmmi-10x-x-109">&#x003E; </span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,&#x03BB;</span><sub><span 
class="lmmi-8">m</span></sub> <span 
class="lmmi-10x-x-109">&#x003E; </span><span 
class="rm-lmr-10x-x-109">0 </span>and <span 
class="lmmi-10x-x-109">p </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="rm-lmr-10x-x-109">[0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 152--><p class="noindent" ><a 
 id="dx1-102018"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_uni</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Uniform law on <span 
class="rm-lmr-10x-x-109">]0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 155--><p class="noindent" ><a 
 id="dx1-102019"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_uni_ab</span></span>&#x00A0;(<span class='args'>double a, double b, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Uniform law on <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 159--><p class="noindent" ><a 
 id="dx1-102020"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_normal</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the standard normal distribution.
     </p></li>
     <li class="itemize">
     <!--l. 162--><p class="noindent" ><a 
 id="dx1-102021"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_lognormal</span></span>&#x00A0;(<span class='args'>double m, double sigma2, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the log-normal distribution. The underlying normal
     distribution has mean <span class='var'>m</span> and variance <span class='var'>sigma2</span>.
     </p></li>
     <li class="itemize">
     <!--l. 166--><p class="noindent" ><a 
 id="dx1-102022"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_invgauss</span></span>&#x00A0;(<span class='args'>double mu, double lambda, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the inverse Gaussian distribution with mean <span class='var'>mu</span> and
     shape parameter <span class='var'>lambda</span>.
     </p></li>
     <li class="itemize">
     <!--l. 170--><p class="noindent" ><a 
 id="dx1-102023"></a> <span class='ret'>long</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_poisson1</span></span>&#x00A0;(<span class='args'>double lambda, double t,<a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from a Poisson process with intensity <span class='var'>lambda</span> at time
     <span class='var'>t</span>.
     </p></li>
     <li class="itemize">
     <!--l. 175--><p class="noindent" ><a 
 id="dx1-102024"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_gamma</span></span>&#x00A0;(<span class='args'>double a, double b, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the <span 
class="rm-lmr-10x-x-109">&#x0393;(</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">) </span>distribution.
     </p></li>
     <li class="itemize">
     <!--l. 178--><p class="noindent" ><a 
 id="dx1-102025"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_chi2</span></span>&#x00A0;(<span class='args'>double df, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the centered <span 
class="lmmi-10x-x-109">&#x03C7;</span><sup><span 
class="rm-lmr-8">2</span></sup><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">df</span><span 
class="rm-lmr-10x-x-109">) </span>distribution.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 180--><p class="noindent" ><a 
 id="dx1-102026"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_ncchi2</span></span>&#x00A0;(<span class='args'>double df, double xnonc, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the non central <span 
class="lmmi-10x-x-109">&#x03C7;</span><sup><span 
class="rm-lmr-8">2</span></sup> distribution with <span class='var'>df</span> degrees of
     freedom and non central parameter <span class='var'>xnonc</span>.
     </p></li>
     <li class="itemize">
     <!--l. 183--><p class="noindent" ><a 
 id="dx1-102027"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_bessel</span></span>&#x00A0;(<span class='args'>double v, double a,<a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Bessel distribution with parameters <span class='var'>v &#x003E; -1</span> and <span class='var'>a
     &#x003E; 0</span>.
     </p></li>
     <li class="itemize">
     <!--l. 186--><p class="noindent" ><a 
 id="dx1-102028"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_gauss</span></span>&#x00A0;(<span class='args'>int d, int create_or_retrieve, int index, PnlRng <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>The second argument can be either <span class='var'>CREATE</span> (to actually draw the sample) or
     <span class='var'>RETRIEVE</span> (to retrieve that element of index <span class='var'>index</span>). With <span class='var'>CREATE</span>, it draws <span class='var'>d</span> random
     normal variables and stores them for future usage. They can be withdrawn using <span class='var'>RETRIEVE</span>
     with the index of the number to be retrieved.</p></li></ul>
<!--l. 195--><p class="noindent" >The following functions take an already existing <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>as first argument and fill each entry of
the vector with a sample from the specified distribution. All the entries are independent. The
difference between <span 
class="lmmi-10x-x-109">n</span><span 
class="lmsy-10x-x-109">-</span>samples from a distribution in dimension <span 
class="rm-lmr-10x-x-109">1</span>, and one sample from the same
distribution in dimension <span 
class="lmmi-10x-x-109">n </span>only matters when using a <span 
class="ec-lmbx-10x-x-109">quasi </span>random number generator.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 202--><p class="noindent" ><a 
 id="dx1-102029"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rng_bernoulli</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int samples, double a, double b, double
     p, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Simulate an i.i.d. sample from the Bernoulli distribution with values in
     <span class='var'>a,b</span> and parameter <span class='var'>p</span>. The result is stored in <span class='var'>V</span>.
     </p></li>
     <li class="itemize">
     <!--l. 208--><p class="noindent" ><a 
 id="dx1-102030"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rng_bernoulli_d</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int dimension, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>a,
     const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Simulate a random vector according to the Bernoulli distribution with
     values in <span class='var'>{a,b}</span> and parameter <span class='var'>p</span>. The result is stored in <span class='var'>V</span>, ie. <span class='var'>V(i)</span> follows a Bernoulli
     distribution on <span class='var'>{a(i), b(i)}</span> with parameter <span class='var'>p(i)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 215--><p class="noindent" ><a 
 id="dx1-102031"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rng_poisson</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int samples, double lambda, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Simulate an i.i.d. sample from the Poisson distribution with parameter
     <span class='var'>lambda</span>. The result is stored in <span class='var'>V</span>. Note that, we are using double based vectors and not
     integer based vectors.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 221--><p class="noindent" ><a 
 id="dx1-102032"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rng_poisson_d</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>V,  int  dimension,  const  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>lambda, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Simulate a random vector according to the Poisson distribution with
     <span 
class="ec-lmbx-10x-x-109">vector  </span>parameter  <span class='var'>lambda</span>.  The  result  is  stored  in  <span class='var'>V</span>,  ie.  <span class='var'>V(i)</span>  follows  a  Poisson
     distribution with parameter <span class='var'>lambda(i)</span>. Note that, we are using double based vectors
     and not integer based vectors.
     </p></li>
     <li class="itemize">
     <!--l. 228--><p class="noindent" ><a 
 id="dx1-102033"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rng_uni</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>G,  int  samples,  double  a,  double  b,  <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>G</span> is a vector of independent and identically distributed samples from
     the uniform distribution on <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 233--><p class="noindent" ><a 
 id="dx1-102034"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rng_normal</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>G, int samples, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>G</span> is a vector of independent and identically distributed samples from
     the standard normal distribution.
     </p></li>
     <li class="itemize">
     <!--l. 238--><p class="noindent" ><a 
 id="dx1-102035"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rng_uni_d</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>G, int d, double a, double b, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>G</span> is a sample from the uniform distribution on <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">]</span><sup>d</sup>.
     </p></li>
     <li class="itemize">
     <!--l. 243--><p class="noindent" ><a 
 id="dx1-102036"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rng_normal_d</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>G, int d, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>G</span> is a sample from the <span class='var'>d</span>-dimensional standard normal distribution.
</p>
     </li></ul>
<!--l. 250--><p class="noindent" >The following functions take an already existing <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>as first argument and fill each entry of the
matrix with a sample from the specified distribution. All the entries are independent. On
return, the matrix <span class='var'>M</span> is of size <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">samples</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;x</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;dimension</span></span></span>. The rows of <span class='var'>M</span> are independent and
identically distributed. Each row is a sample from the given law in dimension <span class='var'>dimension</span>.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 257--><p class="noindent" ><a 
 id="dx1-102037"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_rng_uni</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int samples, int d, const PnlVect <span 
class="ts1-lmr10-x-x-109">*</span>a, const
     PnlVect <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>M</span>   contains   <span class='var'>samples</span>   samples   from   the   uniform   distribution   on
     <span 
class="lmex-10">&#x220F;</span>
       <sub><span 
class="lmmi-8">i</span><span 
class="rm-lmr-8">=1</span></sub><sup><span 
class="lmmi-8">d</span></sup><span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">,b</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">]</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 263--><p class="noindent" ><a 
 id="dx1-102038"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_rng_uni2</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>M,  int  samples,  int  d,  double  a,  double  b,
     <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>M</span> contains <span class='var'>samples</span> samples from the uniform distribution on <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">]</span><sup>d</sup>.
     </p></li>
     <li class="itemize">
     <!--l. 268--><p class="noindent" ><a 
 id="dx1-102039"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_rng_normal</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int samples, int d, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>M</span> contains <span class='var'>samples</span> samples from the <span class='var'>d</span>-dimensional standard normal
     distribution.
     </p></li>
     <li class="itemize">
     <!--l. 273--><p class="noindent" ><a 
 id="dx1-102040"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_rng_bernoulli</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>M,  int  samples,  int  dimension,  const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>a, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute a random matrix with independent rows, each of them having
     a vector Bernoulli distribution, ie. <span class='var'>M(i, j)</span> follows a Bernoulli distribution on <span class='var'>{a(j), b(j)}</span>
     with parameter <span class='var'>p(j)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 279--><p class="noindent" ><a 
 id="dx1-102041"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_rng_poisson</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>M,  int  samples,  int  dimension,  const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lambda, <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rng</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute a random matrix with independent rows, each of them having
     a vector Poisson distribution, ie. <span class='var'>M(i, j)</span> follows a Poisson distribution with parameter
     <span class='var'>p(j)</span>.</p></li></ul>
<!--l. 286--><p class="noindent" >Some examples
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-36">
#include&#x00A0;&#x003C;stdlib.h&#x003E;
#include&#x00A0;"pnl/pnl_random.h"

int&#x00A0;main&#x00A0;()
{
&#x00A0;&#x00A0;int&#x00A0;i,&#x00A0;M;
&#x00A0;&#x00A0;PnlRng&#x00A0;*rng&#x00A0;=&#x00A0;pnl_rng_create(PNL_RNG_MERSENNE);
&#x00A0;&#x00A0;PnlVect&#x00A0;*v&#x00A0;=&#x00A0;pnl_vect_new();
&#x00A0;&#x00A0;M&#x00A0;=&#x00A0;10000;

&#x00A0;&#x00A0;/*&#x00A0;rng&#x00A0;must&#x00A0;be&#x00A0;initialized.&#x00A0;When&#x00A0;sseed=0,&#x00A0;a&#x00A0;default
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;value&#x00A0;depending&#x00A0;on&#x00A0;the&#x00A0;generator&#x00A0;is&#x00A0;used&#x00A0;*/
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_rng_sseed(rng,&#x00A0;0);

&#x00A0;&#x00A0;for&#x00A0;(i=0&#x00A0;;&#x00A0;i&#x003C;M&#x00A0;;&#x00A0;i++)
&#x00A0;&#x00A0;{
&#x00A0;&#x00A0;&#x00A0;&#x00A0;/*&#x00A0;Simulates&#x00A0;a&#x00A0;normal&#x00A0;random&#x00A0;vector&#x00A0;in&#x00A0;R^{10}&#x00A0;*/
&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_vect_rng_normal(v,&#x00A0;10,&#x00A0;rng);
&#x00A0;&#x00A0;&#x00A0;&#x00A0;/*&#x00A0;Do&#x00A0;something&#x00A0;with&#x00A0;v&#x00A0;*/
&#x00A0;&#x00A0;}

&#x00A0;&#x00A0;pnl_vect_free(&amp;v);
&#x00A0;&#x00A0;pnl_rng_free(&amp;rng);&#x00A0;/*&#x00A0;Frees&#x00A0;the&#x00A0;generator&#x00A0;*/
&#x00A0;&#x00A0;exit(0);
}
</pre>
<!--l. 313--><p class="nopar" >
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-37">
#include&#x00A0;&#x003C;stdlib.h&#x003E;
#include&#x00A0;&#x003C;time.h&#x003E;
#include&#x00A0;"pnl/pnl_random.h"

int&#x00A0;main&#x00A0;()
{
&#x00A0;&#x00A0;int&#x00A0;i,&#x00A0;M;
&#x00A0;&#x00A0;double&#x00A0;E;
&#x00A0;&#x00A0;PnlRng&#x00A0;*rng&#x00A0;=&#x00A0;pnl_rng_create(PNL_RNG_MERSENNE);
&#x00A0;&#x00A0;M&#x00A0;=&#x00A0;10000;

&#x00A0;&#x00A0;/*&#x00A0;rng&#x00A0;must&#x00A0;be&#x00A0;initialized.&#x00A0;*/
&#x00A0;&#x00A0;pnl_rng_sseed(rng,&#x00A0;time&#x00A0;(NULL));

&#x00A0;&#x00A0;for&#x00A0;(i=0&#x00A0;;&#x00A0;i&#x003C;M&#x00A0;;&#x00A0;i++)
&#x00A0;&#x00A0;{
&#x00A0;&#x00A0;&#x00A0;&#x00A0;/*&#x00A0;Simulates&#x00A0;an&#x00A0;exponential&#x00A0;random&#x00A0;variable&#x00A0;*/
&#x00A0;&#x00A0;&#x00A0;&#x00A0;E&#x00A0;=&#x00A0;pnl_rng_exp(1,&#x00A0;rng);
&#x00A0;&#x00A0;&#x00A0;&#x00A0;/*&#x00A0;Do&#x00A0;something&#x00A0;with&#x00A0;E&#x00A0;*/
&#x00A0;&#x00A0;}

&#x00A0;&#x00A0;pnl_rng_free(&amp;rng);&#x00A0;/*&#x00A0;Frees&#x00A0;the&#x00A0;generator&#x00A0;*/
&#x00A0;&#x00A0;exit(0);
}
</pre>
<!--l. 340--><p class="nopar" >
</p><!--l. 342--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">6.2   </span> <a 
 id="x1-1030006.2"></a>The <span 
class="ec-lmri-10x-x-109">rand </span>interface (deprecated)</h4>
<!--l. 346--><p class="noindent" ><span 
class="ec-lmbxi-10x-x-109">Note</span><span 
class="ec-lmri-10x-x-109">: For backward compatibility with older versions of the PNL, we still provide the old </span>rand
<span 
class="ec-lmri-10x-x-109">interface to random number generation although we strongly encourage users to use the new </span>rng
<span 
class="ec-lmri-10x-x-109">interface (see section</span><span 
class="ec-lmri-10x-x-109">&#x00A0;6.1).</span>
</p><!--l. 352--><p class="noindent" >Every generator is identified by an integer valued macro. One must <span 
class="ec-lmbx-10x-x-109">NOT </span>refer to a generator using
directly the value of the macro <span class='var'>PNL_RNG_XXX</span> because there is no warranty that the order used
to store the generators will remain the same in future releases. Instead, one should call generators
directly using their macro names.
</p><!--l. 358--><p class="noindent" >The initial seeds of all the generators are fixed by the function <a 
href="#x1-1030006.2">pnl_rand_init</a> but you can change it
by calling <a 
href="#x1-1030006.2">pnl_rand_sseed</a>.
</p><!--l. 361--><p class="noindent" >Before starting to use random number generators, you <span 
class="ec-lmbx-10x-x-109">must </span>initialize them by calling
</p>
                                                                                    

                                                                                    
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 364--><p class="noindent" ><a 
 id="dx1-103001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_init</span></span>&#x00A0;(<span class='args'>int type_generator, int simulation_dim, long samples</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>It resets the sample counter to <span 
class="rm-lmr-10x-x-109">0 </span>and checks that the generator described
     by <span class='var'>type_generator</span> can actually generate <span class='var'>samples</span> in dimension <span class='var'>simulation_dim</span> and
     fixes the seed.</p></li></ul>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 373--><p class="noindent" ><a 
 id="dx1-103002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_or_quasi</span></span>&#x00A0;(<span class='args'>int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the type the generator of index <span class='var'>type_generator</span>, <span class='var'>PNL_MC</span> or
     <span class='var'>PNL_QMC</span>
     </p></li>
     <li class="itemize">
     <!--l. 376--><p class="noindent" ><a 
 id="dx1-103003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_sseed</span></span>&#x00A0;(<span class='args'>(int type_generator, unsigned long int seed)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>It sets the seed of the generator <span class='var'>type_generator</span> with <span class='var'>seed</span>.
     </p></li>
     <li class="itemize">
     <!--l. 380--><p class="noindent" ><a 
 id="dx1-103004"></a> <span class='ret'>const char <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_name</span></span>&#x00A0;(<span class='args'>int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the name of the generator of index <span class='var'>type_generator</span></p></li></ul>
<!--l. 384--><p class="noindent" >Once a generator is chosen, there are several functions available in the library to draw samples
according to a given law.
</p><!--l. 387--><p class="noindent" >The following functions return one sample from a specified law. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 389--><p class="noindent" ><a 
 id="dx1-103005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_bernoulli</span></span>&#x00A0;(<span class='args'>double p, int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Bernouilli law on <span 
class="lmsy-10x-x-109">{</span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmsy-10x-x-109">} </span>with parameter <span class='var'>p</span>.
     </p></li>
     <li class="itemize">
     <!--l. 393--><p class="noindent" ><a 
 id="dx1-103006"></a> <span class='ret'>long</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_poisson</span></span>&#x00A0;(<span class='args'>double lambda, int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Poisson law with parameter <span class='var'>lambda</span>.
     </p></li>
     <li class="itemize">
     <!--l. 397--><p class="noindent" ><a 
 id="dx1-103007"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_exp</span></span>&#x00A0;(<span class='args'>double lambda, int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Exponential law with parameter <span class='var'>lambda</span>.
     </p></li>
     <li class="itemize">
     <!--l. 401--><p class="noindent" ><a 
 id="dx1-103008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_uni</span></span>&#x00A0;(<span class='args'>int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Uniform law on <span 
class="rm-lmr-10x-x-109">[0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1]</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 404--><p class="noindent" ><a 
 id="dx1-103009"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_uni_ab</span></span>&#x00A0;(<span class='args'>double a, double b, int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Uniform law on <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 408--><p class="noindent" ><a 
 id="dx1-103010"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_normal</span></span>&#x00A0;(<span class='args'>int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the standard normal distribution.
     </p></li>
     <li class="itemize">
     <!--l. 411--><p class="noindent" ><a 
 id="dx1-103011"></a> <span class='ret'>long</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_poisson1</span></span>&#x00A0;(<span class='args'>double lambda, double t, int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from a Poisson process with intensity <span class='var'>lambda</span> at time
     <span class='var'>t</span>.
     </p></li>
     <li class="itemize">
     <!--l. 416--><p class="noindent" ><a 
 id="dx1-103012"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_gamma</span></span>&#x00A0;(<span class='args'>double a, double b, int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the <span 
class="rm-lmr-10x-x-109">&#x0393;(</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">) </span>distribution.
     </p></li>
     <li class="itemize">
     <!--l. 419--><p class="noindent" ><a 
 id="dx1-103013"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_chi2</span></span>&#x00A0;(<span class='args'>double n, int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the centered <span 
class="lmmi-10x-x-109">&#x03C7;</span><sup><span 
class="rm-lmr-8">2</span></sup><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">n</span><span 
class="rm-lmr-10x-x-109">) </span>distribution.
     </p></li>
     <li class="itemize">
     <!--l. 421--><p class="noindent" ><a 
 id="dx1-103014"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_bessel</span></span>&#x00A0;(<span class='args'>double v, double a, int generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Generate a sample from the Bessel distribution with parameters <span class='var'>v &#x003E; -1</span>
     and <span class='var'>a &#x003E; 0</span>.</p></li></ul>
<!--l. 426--><p class="noindent" >The following functions take an already existing <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>&#x00A0;as its first argument and fill each entry
of the vector with a sample from the specified law. All the entries are independent. The difference
between <span 
class="lmmi-10x-x-109">n</span><span 
class="lmsy-10x-x-109">-</span>samples from a distribution in dimension <span 
class="rm-lmr-10x-x-109">1</span>, and one sample from the same
distribution in dimension <span 
class="lmmi-10x-x-109">n </span>only matters when using a <span 
class="ec-lmbx-10x-x-109">Quasi </span>random number generator.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 433--><p class="noindent" ><a 
 id="dx1-103015"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rand_uni</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>G,  int  samples,  double  a,  double  b,  int
     type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>G</span> is a vector of independent and identically distributed samples from
     the uniform distribution on <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">]</span>.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 438--><p class="noindent" ><a 
 id="dx1-103016"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rand_normal</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>G, int samples, int generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>G</span> is a vector of independent and identically distributed samples from
     the standard normal distribution.
     </p></li>
     <li class="itemize">
     <!--l. 443--><p class="noindent" ><a 
 id="dx1-103017"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rand_uni_d</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>G,  int  d,  double  a,  double  b,  int
     type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>G</span> is a sample from the uniform distribution on <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">]</span><sup>d</sup>.
     </p></li>
     <li class="itemize">
     <!--l. 448--><p class="noindent" ><a 
 id="dx1-103018"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_rand_normal_d</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>G, int d, int generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>G</span> is a sample from the <span class='var'>d</span>-dimensional standard normal distribution.
</p>
     </li></ul>
<!--l. 455--><p class="noindent" >The following functions take an already existing <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>&#x00A0;as first argument and fill each entry of
the vector with a sample from the specified law. All the entries are in-dependant. On return,
the matrix <span class='var'>M</span> is of size <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">samples</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;x</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;dimension</span></span></span>. The rows of <span class='var'>M</span> are independently and
identically distributed. Each row is a sample from the given law in dimension <span class='var'>dimension</span>.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 462--><p class="noindent" ><a 
 id="dx1-103019"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_rand_uni</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int samples, int d, const PnlVect <span 
class="ts1-lmr10-x-x-109">*</span>a, const
     PnlVect <span 
class="ts1-lmr10-x-x-109">*</span>b, int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>M</span>   contains   <span class='var'>samples</span>   samples   from   the   uniform   distribution   on
     <span 
class="lmex-10">&#x220F;</span>
       <sub><span 
class="lmmi-8">i</span><span 
class="rm-lmr-8">=1</span></sub><sup><span 
class="lmmi-8">d</span></sup><span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">,b</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 468--><p class="noindent" ><a 
 id="dx1-103020"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_rand_uni2</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int samples, int d, double a, double b, int
     type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>M</span> contains <span class='var'>samples</span> samples from the uniform distribution on <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">]</span><sup>d</sup>.
     </p></li>
     <li class="itemize">
     <!--l. 473--><p class="noindent" ><a 
 id="dx1-103021"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_rand_normal</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int samples, int d, int type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>M</span> contains <span class='var'>samples</span> samples from the <span class='var'>d</span>-dimensional standard normal
     distribution.</p></li></ul>
<!--l. 479--><p class="noindent" >Because of the use of <span 
class="ec-lmbx-10x-x-109">Quasi </span>random number generators, you may need to draw a set of samples at
once because they represent one sample from a multi-dimensional distribution. The following
function enables to draw one sample from the <span class='var'>dimension</span>-dimensional standard normal
distribution and store it so that you can access the elements individually afterwards.
</p>
                                                                                    

                                                                                    
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 485--><p class="noindent" ><a 
 id="dx1-103022"></a>    <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rand_gauss</span></span>&#x00A0;(<span class='args'>int    d,    int    create_or_retrieve,    int    index,    int
     type_generator</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>The  second  argument  can  be  either  <span class='var'>CREATE</span>  (to  actually  draw  the
     sample)  or  <span class='var'>RETRIEVE</span>  (to  retrieve  that  element  of  index  <span class='var'>index</span>).  With  <span class='var'>CREATE</span>,
     it draws <span class='var'>d</span> random normal variables and stores them for future usage. They can be
     withdrawn using <span class='var'>RETRIEVE</span> with the index of the number to be retrieved.</p></li></ul>
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">7   </span> <a 
 id="x1-1040007"></a>Function bases and regression</h3>
<!--l. 2--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">7.1   </span> <a 
 id="x1-1050007.1"></a>Overview</h4>
<!--l. 4--><p class="noindent" >To use these functionalities, you should include <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_basis.h</span></span></span>.
<a 
 id="dx1-105001"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-38">
struct&#x00A0;PnlBasis_t&#x00A0;{
&#x00A0;&#x00A0;PnlObject&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;object;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;basis&#x00A0;type&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;id;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;string&#x00A0;to&#x00A0;label&#x00A0;the&#x00A0;basis&#x00A0;*/
&#x00A0;&#x00A0;const&#x00A0;char&#x00A0;&#x00A0;&#x00A0;*label;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;number&#x00A0;of&#x00A0;variates&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nb_variates;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;total&#x00A0;number&#x00A0;of&#x00A0;elements&#x00A0;in&#x00A0;the&#x00A0;basis&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;nb_func;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;tensor&#x00A0;matrix&#x00A0;*/
&#x00A0;&#x00A0;PnlMatInt&#x00A0;&#x00A0;&#x00A0;&#x00A0;*T;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;sparse&#x00A0;Tensor&#x00A0;matrix&#x00A0;*/
&#x00A0;&#x00A0;PnlSpMatInt&#x00A0;&#x00A0;*SpT;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;number&#x00A0;of&#x00A0;functions&#x00A0;in&#x00A0;the&#x00A0;tensor&#x00A0;#T&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;len_T;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;i-th&#x00A0;element&#x00A0;of&#x00A0;the&#x00A0;one&#x00A0;dimensional&#x00A0;basis.&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(*f)(double&#x00A0;&#x00A0;&#x00A0;&#x00A0;x,&#x00A0;int&#x00A0;i);
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;first&#x00A0;derivative&#x00A0;of&#x00A0;i-th&#x00A0;element&#x00A0;of&#x00A0;the&#x00A0;one&#x00A0;dimensional&#x00A0;basis&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(*Df)(double&#x00A0;&#x00A0;&#x00A0;x,&#x00A0;int&#x00A0;i);
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;second&#x00A0;derivative&#x00A0;of&#x00A0;the&#x00A0;i-th&#x00A0;element&#x00A0;of&#x00A0;the&#x00A0;one&#x00A0;dimensional&#x00A0;basis&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(*D2f)(double&#x00A0;&#x00A0;x,&#x00A0;int&#x00A0;i);
&#x00A0;&#x00A0;/**&#x00A0;TRUE&#x00A0;if&#x00A0;the&#x00A0;basis&#x00A0;is&#x00A0;reduced&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;isreduced;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;center&#x00A0;of&#x00A0;the&#x00A0;domain&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;*center;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;inverse&#x00A0;of&#x00A0;the&#x00A0;scaling&#x00A0;factor&#x00A0;to&#x00A0;map&#x00A0;the&#x00A0;domain&#x00A0;to&#x00A0;[-1,&#x00A0;1]^nb_variates&#x00A0;*/
&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;*scale;
&#x00A0;&#x00A0;/**&#x00A0;An&#x00A0;array&#x00A0;of&#x00A0;additional&#x00A0;functions&#x00A0;*/
&#x00A0;&#x00A0;PnlRnFuncR&#x00A0;&#x00A0;*func_list;
&#x00A0;&#x00A0;/**&#x00A0;The&#x00A0;number&#x00A0;of&#x00A0;functions&#x00A0;in&#x00A0;#func_list&#x00A0;*/
&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;len_func_list;
};
</pre>
<!--l. 41--><p class="nopar" >
</p><!--l. 43--><p class="noindent" >A <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> is a family of multivariate functions with real values. Tow different kinds of functions
can be stored in these families: tensor functions &#8212; originally, this was the only possibility, and
standard multivariate function typed as <a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncR</span></a>.
</p>
<!--l. 48--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-106000"></a><span 
class="ec-lmbx-10x-x-109">Tensor functions.</span></span>
                                                                                    

                                                                                    
Tensors functions are built as a tensor product of one dimensional elements. Hence, we only need a
tensor matrix <span class='var'>T</span> to describe a multi-dimensional basis in terms of the one dimensional one. These
tensors functions can be easily evaluated and differentiated twice, see <a 
href="#x1-108017r7.2">pnl_basis_eval</a>,
<a 
href="#x1-108017r7.2">pnl_basis_eval_vect</a>, <a 
href="#x1-108017r7.2">pnl_basis_eval_D</a>, <a 
href="#x1-108017r7.2">pnl_basis_eval_D_vect</a>, <a 
href="#x1-108017r7.2">pnl_basis_eval_D2</a>,
<a 
href="#x1-108017r7.2">pnl_basis_eval_D2_vect</a>, <a 
href="#x1-108017r7.2">pnl_basis_eval_derivs</a>, <a 
href="#x1-108017r7.2">pnl_basis_eval_derivs_vect</a>.
</p><!--l. 56--><p class="noindent" >The two tensors <span class='var'>T</span> and <span class='var'>SpT</span> do actually store the same information &#8212; <span class='var'>T(i,j)</span> is the degree w.r.t the
<span class='var'>j</span>-th variable in the <span class='var'>i</span>-th function. Originally, we were only using the dense representation <span class='var'>T</span>, which is
far more convenient to use when building the basis but it slows down the evaluation of
the basis by a great deal. To overcome this lack of efficiency, a sparse storage has been
added.
</p>
<div class="table">
                                                                                    

                                                                                    
<!--l. 63--><p class="noindent" ><a 
 id="x1-1060043"></a></p><hr class="float" /><div class="float" 
>
                                                                                    

                                                                                    
<!--tex4ht:inline--><div class="tabular"> <table id="TBL-12" class="tabular" 
 
><colgroup id="TBL-12-1g"><col 
id="TBL-12-1" /><col 
id="TBL-12-2" /><col 
id="TBL-12-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-12-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-12-1-1"  
class="td11"><a 
 id="dx1-106001"></a><a 
 id="x1-106000doc"></a><span class='struct'>PNL_BASIS_CANONICAL</span>  </td><td  style="white-space:normal; text-align:left;" id="TBL-12-1-2"  
class="td11"><!--l. 65--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-12-1-3"  
class="td11">for the Canonical polynomials  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-12-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-12-2-1"  
class="td11"><a 
 id="dx1-106002"></a><span class='struct'>PNL_BASIS_HERMITE</span>       </td><td  style="white-space:normal; text-align:left;" id="TBL-12-2-2"  
class="td11"><!--l. 66--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-12-2-3"  
class="td11">for the Hermite polynomials     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-12-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-12-3-1"  
class="td11"><a 
 id="dx1-106003"></a><span class='struct'>PNL_BASIS_TCHEBYCHEV</span></td><td  style="white-space:normal; text-align:left;" id="TBL-12-3-2"  
class="td11"><!--l. 67--><p class="noindent" >     </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-12-3-3"  
class="td11">for the Tchebychev polynomials</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-12-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-12-4-1"  
class="td11">                          </td></tr></table>                                                      </div>
 <div class="caption" 
><span class="id">Table&#x00A0;3: </span><span  
class="content">Names of the bases. See also function <a 
href="#x1-1080007.2">pnl_basis_type_register</a> to register more
basis types.</span></div><!--tex4ht:label?: x1-1060043 -->
                                                                                    

                                                                                    
</div><hr class="endfloat" />
</div>
<!--l. 74--><p class="noindent" >The Hermite polynomials are defined by
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual22x.png" alt="                   n
H (x) = (- 1)n ex22-d-e- x22-.
 n               dxn
" class="math-display"  /></div>
</td></tr></table>
<!--l. 77--><p class="nopar" >If <span 
class="lmmi-10x-x-109">G </span>is a real valued standard normal random variable, <span 
class="msbm-10x-x-109">E</span><span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">H</span><sub><span 
class="lmmi-8">n</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">G</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">H</span><sub><span 
class="lmmi-8">m</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">G</span><span 
class="rm-lmr-10x-x-109">)] = </span><span 
class="lmmi-10x-x-109">n</span><span 
class="rm-lmr-10x-x-109">!1</span><sub><img 
src="pnl-manual23x.png" alt="{n=m}"  class="left" align="middle" /></sub>.
<br 
class="newline" />
</p>
<!--l. 81--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-107000"></a><span 
class="ec-lmbx-10x-x-109">Standard multivariate functions.</span></span>
These functions are supposed to be <a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncR</span></a>.
</p><!--l. 83--><p class="noindent" >To make this toolbox more complete, it is now possible to add some extra functions, which are not
tensor product. They are stored using an independent mechanism in <span class='var'>func_list</span>. These additional
functions are only taken into account by the methods <a 
href="#x1-108017r7.2">pnl_basis_i</a>, <a 
href="#x1-108017r7.2">pnl_basis_i_vect</a>,
<a 
href="#x1-108017r7.2">pnl_basis_eval</a> and <a 
href="#x1-108017r7.2">pnl_basis_eval_vect</a>. Note in particular that it is not possible to
differentiate these functions. To add an extra function to an existing <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a>, call the function
<a 
href="#x1-1080007.2">pnl_basis_add_function</a>.
</p><!--l. 91--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">7.2   </span> <a 
 id="x1-1080007.2"></a>Functions</h4>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 94--><p class="noindent" ><a 
 id="dx1-108001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_type_register</span></span>&#x00A0;(<span class='args'>const char *name, double (*f)(double, int), double
     (*Df)(double, int), double (*D2f)(double, int)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Register a new basis type and return the index to be passed to <a 
href="#x1-1080007.2">pnl_basis_create</a> .
     The variable <span class='var'>name</span> is a unique string identifier of the family. The variables <span class='var'>f</span>, <span class='var'>Df</span>, <span class='var'>D2f</span> are the
     one dimensional basis functions, its first and second order derivatives. Each of these functions
     must return a <span class='var'>double</span> and take two arguments : the first one is the point at which evaluating
     the basis functions, the second one is the index of function. Here is a toy example to show
     how the canonical basis is registered (this family is actually already available with
                                                                                    

                                                                                    
     the id PNL_BASIS_CANONICAL, so the following example may look a little
     fake)
                                                                                    

                                                                                    
</p>
     <pre class="verbatim" id="verbatim-39">
     &#x00A0;&#x00A0;double&#x00A0;f(double&#x00A0;x,&#x00A0;int&#x00A0;n)&#x00A0;{&#x00A0;return&#x00A0;pnl_pow_i(x,&#x00A0;n);&#x00A0;}
     &#x00A0;&#x00A0;double&#x00A0;Df(double&#x00A0;x,&#x00A0;int&#x00A0;n)&#x00A0;{&#x00A0;return&#x00A0;n&#x00A0;*&#x00A0;pnl_pow_i(x,&#x00A0;n-1);&#x00A0;}
     &#x00A0;&#x00A0;double&#x00A0;f(double&#x00A0;x,&#x00A0;int&#x00A0;n)&#x00A0;{&#x00A0;return&#x00A0;n&#x00A0;*&#x00A0;(n-1)&#x00A0;*&#x00A0;pnl_pow_i(x,&#x00A0;n-2);&#x00A0;}
     
     &#x00A0;&#x00A0;int&#x00A0;id&#x00A0;=&#x00A0;pnl_basis_register&#x00A0;("Canonic",&#x00A0;f,&#x00A0;Df,&#x00A0;D2f);
     &#x00A0;&#x00A0;/*
     &#x00A0;&#x00A0;&#x00A0;*&#x00A0;B&#x00A0;is&#x00A0;the&#x00A0;Canonical&#x00A0;basis&#x00A0;of&#x00A0;polynomials&#x00A0;with&#x00A0;degree&#x00A0;less&#x00A0;or&#x00A0;equal&#x00A0;than&#x00A0;2&#x00A0;in
     &#x00A0;&#x00A0;&#x00A0;*&#x00A0;dimension&#x00A0;5.
     &#x00A0;&#x00A0;&#x00A0;*/
     &#x00A0;&#x00A0;PnlBasis&#x00A0;*B&#x00A0;=&#x00A0;pnl_basis_create_from_degree&#x00A0;(id,&#x00A0;2,&#x00A0;5);
     &#x00A0;&#x00A0;
</pre>
     <!--l. 115--><p class="nopar" >
     </p></li>
     <li class="itemize">
     <!--l. 117--><p class="noindent" ><a 
 id="dx1-108002"></a> <span class='ret'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 120--><p class="noindent" ><a 
 id="dx1-108003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print the characteristics of a basis.
     </p></li>
     <li class="itemize">
     <!--l. 124--><p class="noindent" ><a 
 id="dx1-108004"></a> <span class='ret'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create</span></span>&#x00A0;(<span class='args'>int index, int nb_func, int nb_variates</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> for the family defined by <span class='var'>index</span> (see Table&#x00A0;3 and
     <a 
href="#x1-1080007.2">pnl_basis_type_register</a>) with <span class='var'>nb_variates</span> variates. The basis will contain <span class='var'>nb_func</span>.
     </p></li>
     <li class="itemize">
     <!--l. 131--><p class="noindent" ><a 
 id="dx1-108005"></a> <span class='ret'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create_from_degree</span></span>&#x00A0;(<span class='args'>int index, int degree, int nb_variates</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> for the family defined by <span class='var'>index</span> (see Table&#x00A0;3 and
     <a 
href="#x1-1080007.2">pnl_basis_type_register</a>) with total degree less or equal than <span class='var'>degree</span> and <span class='var'>nb_variates</span>
     variates. The total degree is the sum of the partial degrees.<br 
class="newline" />For instance, calling <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_basis_create_from_degree</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(index,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;2,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;4)</span></span></span> is equivalent to calling
     <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl_basis_create_from_tensor</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(index,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;T)</span></span></span> where <span class='var'>T</span> is given by
                                                                                    

                                                                                    
     </p>
<div class="math-display" >
<img 
src="pnl-manual24x.png" alt="(             )
   0  0  0  0
||  1  0  0  0 ||
||  0  1  0  0 ||
||  0  0  1  0 ||
||  0  0  0  1 ||
||  1  1  0  0 ||
||             ||
||  1  0  1  0 ||
||  1  0  0  1 ||
||  0  1  1  0 ||
||  0  1  0  1 ||
||  0  0  1  1 ||
||  2  0  0  0 ||
||  0  2  0  0 ||
||             ||
||  0  0  2  0 ||
(  0  0  0  2 )
" class="math-display"  /></div>
     </li>
     <li class="itemize">
     <!--l. 159--><p class="noindent" ><a 
 id="dx1-108006"></a> <span class='ret'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create_from_prod_degree</span></span>&#x00A0;(<span class='args'>int index, int degree, int
     nb_variates</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> for the family defined by <span class='var'>index</span> (see Table&#x00A0;3 and
     <a 
href="#x1-1080007.2">pnl_basis_type_register</a>) with total degree less or equal than <span class='var'>degree</span> and <span class='var'>nb_variates</span>
     variates. The total degree is the product of <span class='var'>MAX(1, d_i)</span> where the <span class='var'>d_i</span> are the partial
     degrees.
     </p></li>
     <li class="itemize">
     <!--l. 167--><p class="noindent" ><a 
 id="dx1-108007"></a> <span class='ret'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> *</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create_from_tensor</span></span>&#x00A0;(<span class='args'>int index, PnlMatInt <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> for the polynomial family defined by <span class='var'>index</span> (see Table&#x00A0;3)
     using the basis described by the tensor matrix <span class='var'>T</span>. The number of lines of <span class='var'>T</span> is the number of
     functions of the basis whereas the numbers of columns of <span class='var'>T</span> is the number of variates of the
     functions. Note that <span class='var'>T</span> is not copied inside this function but only its address is stored, so
     <span 
class="ec-lmbx-10x-x-109">never </span>free <span class='var'>T</span>. It will be freed when calling <a 
href="#x1-1080007.2">pnl_basis_free</a> on the returned object.
     i<br 
class="newline" />Here is an example of a tensor matrix. Assume you are working with three variate functions,
     the basis <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">{</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;1,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;x,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;y,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;z,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;x^2,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;xy,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;yz,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;z^3}</span></span></span> is decomposed in the one dimensional
     canonical basis using the following tensor matrix
                                                                                    

                                                                                    
     </p>
<div class="math-display" >
<img 
src="pnl-manual25x.png" alt="(         )
|  0 0  0 |
||  1 0  0 ||
||  0 1  0 ||
||  0 0  1 ||
||  2 0  0 ||
||  1 1  0 ||
|(  0 1  1 |)

   0 0  3
" class="math-display"  /></div>
     </li>
     <li class="itemize">
     <!--l. 194--><p class="noindent" ><a 
 id="dx1-108008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_add_function</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncR</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>f</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Add the function <span class='var'>f</span> to the already existing basis <span class='var'>b</span>.
     </p></li>
     <li class="itemize">
     <!--l. 196--><p class="noindent" ><a 
 id="dx1-108009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>dest, const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone <span class='var'>src</span> into <span class='var'>dest</span>. The basis <span class='var'>dest</span> must already exist before calling this
     function. On exit, <span class='var'>dest</span> and <span class='var'>src</span> are identical and independent.
     </p></li>
     <li class="itemize">
     <!--l. 200--><p class="noindent" ><a 
 id="dx1-108010"></a> <span class='ret'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a copy of <span class='var'>B</span>.
     </p></li>
     <li class="itemize">
     <!--l. 202--><p class="noindent" ><a 
 id="dx1-108011"></a> <span class='ret'>void </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_set_from_tensor</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, int index, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatInt</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set an alredy existing basis <span class='var'>b</span> to a polynomial family defined by <span class='var'>index</span> (see
     Table&#x00A0;3) using the basis described by the tensor matrix <span class='var'>T</span>. The number of lines of <span class='var'>T</span> is the
     number of functions of the basis whereas the numbers of columns of <span class='var'>T</span> is the number of
     variates of the functions. <br 
class="newline" />Same function as <a 
href="#x1-1080007.2">pnl_basis_create_from_tensor</a> except that it operates on an already
     existing basis.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 212--><p class="noindent" ><a 
 id="dx1-108012"></a> <span class='ret'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_create_from_hyperbolic_degree</span></span>&#x00A0;(<span class='args'>int index, double degree,
     double q, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a sparse basis of polynomial with <span class='var'>n</span> variates. We give the example of the
     Canonical basis. A canonical polynomial with <span class='var'>n</span> variates writes <span 
class="lmmi-10x-x-109">X</span><sub><span 
class="rm-lmr-8">1</span></sub><sup><span 
class="lmmi-8">&#x03B1;</span><sub><span 
class="rm-lmr-6">1</span></sub></sup><span 
class="lmmi-10x-x-109">X</span><sub><span 
class="rm-lmr-8">2</span></sub><sup><span 
class="lmmi-8">&#x03B1;</span><sub><span 
class="rm-lmr-6">2</span></sub></sup><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">X</span><sub><span 
class="lmmi-8">n</span></sub><sup><span 
class="lmmi-8">&#x03B1;</span><sub><span 
class="lmmi-6">n</span></sub></sup>. To be a
     member of the basis, it must satisfy <img 
src="pnl-manual26x.png" alt=" &#x2211;n     q
(  i=1&#x03B1;i )"  class="left" align="middle" /><sup><span 
class="rm-lmr-8">1</span><span 
class="lmmi-8">&#x2215;q</span></sup> <span 
class="lmsy-10x-x-109">&#x2264; </span><span 
class="lmmi-10x-x-109">degree</span>. This kind of basis based on
     an hyperbolic set of indices gives priority to polynomials associated to low order
     interaction.
     </p></li>
     <li class="itemize">
     <!--l. 222--><p class="noindent" ><a 
 id="dx1-108013"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_free</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>basis</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> created by <a 
href="#x1-1080007.2">pnl_basis_create</a>. Beware that <span class='var'>basis</span> is the address
     of a <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>.
     </p></li>
     <li class="itemize">
     <!--l. 228--><p class="noindent" ><a 
 id="dx1-108014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_del_elt</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Remove the function defined by the tensor product <span class='var'>d</span> from an existing basis
     <span class='var'>B</span>.
     </p></li>
     <li class="itemize">
     <!--l. 232--><p class="noindent" ><a 
 id="dx1-108015"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_del_elt_i</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Remove the <span class='var'>i-th</span> element of basis <span class='var'>B</span>.
     </p></li>
     <li class="itemize">
     <!--l. 235--><p class="noindent" ><a 
 id="dx1-108016"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_add_elt</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Add the function defined by the tensor <span class='var'>d</span> to the Basis <span class='var'>B</span>.
</p>
     </li></ul>
<!--l. 242--><p class="noindent" >Functional regression based on a least square approach often leads to ill conditioned linear systems.
One way of improving the stability of the system is to use centered and renormalised
polynomials so that the original domain of interest <span 
class="lmsy-10x-x-109"><!--span 
class="htf-calligraphy"-->D<!--/span--> </span>(a subset of <span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">d</span></sup>) is mapped to <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmsy-10x-x-109">-</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1]</span><sup><span 
class="lmmi-8">d</span></sup>.
If the domain <span 
class="lmsy-10x-x-109"><!--span 
class="htf-calligraphy"-->D<!--/span--> </span>is rectangular and writes <span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">a,b</span><span 
class="rm-lmr-10x-x-109">] </span>where <span 
class="lmmi-10x-x-109">a,b </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">d</span></sup>, the mapping is done
by
</p>
<table 
class="equation"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual27x.png" alt="          (               )
x &#x2208; D &#x21A6;- &#x2192;   xi --(bi +-ai)&#x2215;2
              (bi - ai)&#x2215;2   i=1,&#x22C5;&#x22C5;&#x22C5;,d
" class="math-display"  /><a 
 id="x1-108017r1"></a></div>
</td><td class="equation-label">(1)</td></tr></table>
<!--l. 251--><p class="nopar" ></p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 253--><p class="noindent" ><a 
 id="dx1-108018"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_set_domain</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>a, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function declares <span class='var'>B</span> as a centered and normalised basis as defined by
     Equation&#x00A0;1. Calling this function is equivalent to calling <a 
href="#x1-108017r7.2">pnl_basis_set_reduced</a> with
     <span class='var'>center=(b+a)/2</span> and <span class='var'>scale=(b-a)/2</span>.
     </p></li>
     <li class="itemize">
     <!--l. 259--><p class="noindent" ><a 
 id="dx1-108019"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_set_reduced</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>center, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>scale</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function declares <span class='var'>B</span> as a centered and normalised basis using the
     mapping
</p>
     <table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual28x.png" alt="          (            )
            xi --centeri
x &#x2208; D &#x21A6;-&#x2192;      scalei    i=1,&#x22C5;&#x22C5;&#x22C5;,d
" class="math-display"  /></div>
     </td></tr></table>
     <!--l. 266--><p class="nopar" ></p></li></ul>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 271--><p class="noindent" ><a 
 id="dx1-108020"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_fit_ls</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the coefficients <span class='var'>coef</span> defined by
</p>
     <table 
class="equation-star"><tr><td>
                                                                                    

                                                                                    
<div class="math-display" >
<img 
src="pnl-manual29x.png" alt="               n ( N              )2
coef = arg min &#x2211;  ( &#x2211;  &#x03B1; P (x )- y )
           &#x03B1;  i=1   j=0  j j  i    i
" class="math-display"  /></div>
     </td></tr></table>
     <!--l. 278--><p class="nopar" >where <span class='var'>N</span> is the number of functions to regress upon and <span 
class="lmmi-10x-x-109">n </span>is the number of points at which the
     values of the original function are known. <span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">j</span></sub> is the <span 
class="lmmi-10x-x-109">j </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">th </span>basis function. Each
     row of the matrix <span class='var'>x</span> defines the coordinates of one point <span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">i</span></sub>. The function to be
     approximated is defined by the vector <span class='var'>y</span> of the values of the function at the points
     <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 285--><p class="noindent" ><a 
 id="dx1-108021"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_ik_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int
     k</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>An element of a basis writes <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="lmmi-8">l</span><span 
class="rm-lmr-8">=0</span></sub><sup><span class='var'><span 
class="lmmi-8">nb</span><sub><span 
class="lmmi-6">v</span></sub><span 
class="lmmi-8">ariates</span></span></sup><span 
class="lmmi-10x-x-109">&#x03D5;</span><sub><span 
class="lmmi-8">l</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">l</span></sub><span 
class="rm-lmr-10x-x-109">) </span>where the <span 
class="lmmi-10x-x-109">&#x03D5;</span>&#8217;s are one
     dimensional polynomials. This functions computes the therm <span 
class="lmmi-10x-x-109">&#x03D5;</span><sub><span 
class="lmmi-8">k</span></sub> of the <span class='var'>i-th</span> basis function at
     the point <span class='var'>x</span>.
     </p></li>
     <li class="itemize">
     <!--l. 290--><p class="noindent" ><a 
 id="dx1-108022"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>If <span class='var'>b</span> is composed of <span 
class="lmmi-10x-x-109">f</span><sub><span 
class="rm-lmr-8">0</span></sub><span 
class="lmmi-10x-x-109">,</span><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">,f</span><sub><span class='var'><span 
class="lmmi-8">nb</span>_<span 
class="lmmi-8">func</span></span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sub>, then this function returns <span 
class="lmmi-10x-x-109">f</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 294--><p class="noindent" ><a 
 id="dx1-108023"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_D_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int
     j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>If <span class='var'>b</span> is composed of <span 
class="lmmi-10x-x-109">f</span><sub><span 
class="rm-lmr-8">0</span></sub><span 
class="lmmi-10x-x-109">,</span><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">,f</span><sub><span class='var'><span 
class="lmmi-8">nb</span>_<span 
class="lmmi-8">func</span></span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sub>, then this function returns <span 
class="lmmi-10x-x-109">&#x2202;</span><sub><span 
class="lmmi-8">x</span><sub><span class='var'><span 
class="lmmi-6">j</span></span></sub></sub><span 
class="lmmi-10x-x-109">f</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 299--><p class="noindent" ><a 
 id="dx1-108024"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_D2_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j1, int
     j2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>If <span class='var'>b</span> is composed of <span 
class="lmmi-10x-x-109">f</span><sub><span 
class="rm-lmr-8">0</span></sub><span 
class="lmmi-10x-x-109">,</span><span 
class="lmmi-10x-x-109">&#x2026;</span><span 
class="lmmi-10x-x-109">,f</span><sub><span class='var'><span 
class="lmmi-8">nb</span>_<span 
class="lmmi-8">func</span></span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sub>, then this function returns <span 
class="lmmi-10x-x-109">&#x2202;</span><sup><span 
class="rm-lmr-8">2</span></sup><sub><span 
class="lmmi-8">x</span><sub><span class='var'><span 
class="lmmi-6">j</span><span 
class="rm-lmr-6">1</span></span></sub><span 
class="lmmi-8">,x</span><sub><span class='var'><span 
class="lmmi-6">j</span><span 
class="rm-lmr-6">2</span></span></sub></sub><span 
class="lmmi-10x-x-109">f</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 305--><p class="noindent" ><a 
 id="dx1-108025"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_derivs_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>fx, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Dfx, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>D2fx</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the function, the gradient and the Hessian matrix of
     <span 
class="lmex-10">&#x2211;</span>
       <sub><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">=0</span></sub><sup><span 
class="lmmi-8">n</span></sup><span class='var'><span 
class="lmmi-10x-x-109">coef</span></span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmsy-10x-x-109">&#x22C5;</span><span 
class="rm-lmr-10x-x-109">) </span>at the point <span class='var'>x</span>. On output, <span class='var'>fx</span> contains the value of the function, <span class='var'>Dfx</span> its
     gradient and <span class='var'>D2fx</span> its Hessian matrix. This function is optimized and performs much
     better than calling <a 
href="#x1-108017r7.2">pnl_basis_eval</a>, <a 
href="#x1-108017r7.2">pnl_basis_eval_D</a> and <a 
href="#x1-108017r7.2">pnl_basis_eval_D2</a>
     sequentially.
     </p></li>
     <li class="itemize">
     <!--l. 313--><p class="noindent" ><a 
 id="dx1-108026"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>basis, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the linear combination of <span class='var'>P_k(x)</span> defined by <span class='var'>coef</span>. Given
     the coefficients computed by the function <a 
href="#x1-108017r7.2">pnl_basis_fit_ls</a>, this function returns
     <span 
class="lmex-10">&#x2211;</span>
       <sub><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">=0</span></sub><sup><span 
class="lmmi-8">n</span></sup><span class='var'><span 
class="lmmi-10x-x-109">coef</span></span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">x</span></span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 319--><p class="noindent" ><a 
 id="dx1-108027"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_D_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>basis, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the derivative with respect to <span class='var'>x_i</span> of the linear combination of
     <span class='var'>P_k(x)</span> defined by <span class='var'>coef</span>. Given the coefficients computed by the function <a 
href="#x1-108017r7.2">pnl_basis_fit_ls</a>,
     this function returns <span 
class="lmmi-10x-x-109">&#x2202;</span><sub><span 
class="lmmi-8">x</span><sub><span 
class="lmmi-6">i</span></sub></sub> <span 
class="lmex-10">&#x2211;</span>
   <sub><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">=0</span></sub><sup><span 
class="lmmi-8">n</span></sup><span class='var'><span 
class="lmmi-10x-x-109">coef</span></span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">x</span></span><span 
class="rm-lmr-10x-x-109">) </span>The index <span class='var'>i</span> may vary between <span class='var'>0</span> and
     <span class='var'>P-&#x003E;nb_variates - 1</span>.
     </p></li>
     <li class="itemize">
     <!--l. 327--><p class="noindent" ><a 
 id="dx1-108028"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_D2_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>basis, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the derivative with respect to <span class='var'>x_i</span> of the linear combination of
     <span class='var'>P_k(x)</span> defined by <span class='var'>coef</span>. Given the coefficients computed by the function <a 
href="#x1-108017r7.2">pnl_basis_fit_ls</a>,
     this function returns <span 
class="lmmi-10x-x-109">&#x2202;</span><sub><span 
class="lmmi-8">x</span><sub><span 
class="lmmi-6">i</span></sub></sub><span 
class="lmmi-10x-x-109">&#x2202;</span><sub><span 
class="lmmi-8">x</span><sub><span 
class="lmmi-6">j</span></sub></sub> <span 
class="lmex-10">&#x2211;</span>
   <sub><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">=0</span></sub><sup><span 
class="lmmi-8">n</span></sup><span class='var'><span 
class="lmmi-10x-x-109">coef</span></span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">x</span></span><span 
class="rm-lmr-10x-x-109">)</span>. The indices <span class='var'>i</span> and <span class='var'>j</span> may vary between <span class='var'>0</span> and
     <span class='var'>P-&#x003E;nb_variates - 1</span>.
</p>
     </li></ul>
<!--l. 336--><p class="noindent" >The following functions are provided for compatibility purposes but are marked as deprecated. Use
the functions with the <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">_vect</span></span></span> extension. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 339--><p class="noindent" ><a 
 id="dx1-108029"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_ik</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int k</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x1-108017r7.2">pnl_basis_ik_vect</a> but takes a C array as the point of
     evaluation.
     </p></li>
     <li class="itemize">
     <!--l. 342--><p class="noindent" ><a 
 id="dx1-108030"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x1-108017r7.2">pnl_basis_i_vect</a> but takes a C array as the point of
     evaluation.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 345--><p class="noindent" ><a 
 id="dx1-108031"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_D</span></span>&#x00A0;(<span class='args'> const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j </span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x1-108017r7.2">pnl_basis_i_D_vect</a> but takes a C array as the point
     of evaluation.
     </p></li>
     <li class="itemize">
     <!--l. 348--><p class="noindent" ><a 
 id="dx1-108032"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_i_D2</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j1, int j2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x1-108017r7.2">pnl_basis_i_D2_vect</a> but takes a C array as the point
     of evaluation.
     </p></li>
     <li class="itemize">
     <!--l. 351--><p class="noindent" ><a 
 id="dx1-108033"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, double <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x1-108017r7.2">pnl_basis_eval_vect</a> but takes a C array as the point
     of evaluation.
     </p></li>
     <li class="itemize">
     <!--l. 354--><p class="noindent" ><a 
 id="dx1-108034"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_D</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x1-108017r7.2">pnl_basis_eval_D_vect</a> but takes a C array as the
     point of evaluation.
     </p></li>
     <li class="itemize">
     <!--l. 357--><p class="noindent" ><a 
 id="dx1-108035"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_D2</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x1-108017r7.2">pnl_basis_eval_D2_vect</a> but takes a C array as the
     point of evaluation.
     </p></li>
     <li class="itemize">
     <!--l. 360--><p class="noindent" ><a 
 id="dx1-108036"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_basis_eval_derivs</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1050007.1"><span class='struct'>PnlBasis</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>P, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>coef, double <span 
class="ts1-lmr10-x-x-109">*</span>x, double <span 
class="ts1-lmr10-x-x-109">*</span>fx,
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Dfx, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>D2fx</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as function <a 
href="#x1-108017r7.2">pnl_basis_eval_derivs_vect</a> but takes a C array as
     the point of evaluation.</p></li></ul>
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">8   </span> <a 
 id="x1-1090008"></a>Numerical integration</h3>
                                                                                    

                                                                                    
<!--l. 2--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">8.1   </span> <a 
 id="x1-1100008.1"></a>Overview</h4>
<!--l. 4--><p class="noindent" >To use these functionalities, you should include <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_integration.h</span></span></span>.
</p><!--l. 6--><p class="noindent" >Numerical integration methods are designed to numerically evaluate the integral over a finite or
non finite interval (resp. over a square) of real valued functions defined on <span 
class="msbm-10x-x-109">&#x211D; </span>(resp. on
<span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="rm-lmr-8">2</span></sup>).
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-40">
typedef&#x00A0;struct&#x00A0;{
&#x00A0;&#x00A0;double&#x00A0;(*function)&#x00A0;(double&#x00A0;x,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlFunc;

typedef&#x00A0;struct&#x00A0;{
&#x00A0;&#x00A0;double&#x00A0;(*function)&#x00A0;(double&#x00A0;x,&#x00A0;double&#x00A0;y,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlFunc2D;
</pre>
<!--l. 20--><p class="nopar" >
</p><!--l. 22--><p class="noindent" >We provide the following two macros to evaluate a <a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> or <a 
href="#x1-13000013.1"><span class='struct'>PnlFunc2D</span></a> at a given
point
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-41">
#define&#x00A0;PNL_EVAL_FUNC(F,&#x00A0;x)&#x00A0;(*((F)-&#x003E;function))(x,&#x00A0;(F)-&#x003E;params)
#define&#x00A0;PNL_EVAL_FUNC2D(F,&#x00A0;x,&#x00A0;y)&#x00A0;(*((F)-&#x003E;function))(x,&#x00A0;y,&#x00A0;(F)-&#x003E;params)
</pre>
<!--l. 27--><p class="nopar" >
</p><!--l. 31--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">8.2   </span> <a 
 id="x1-1110008.2"></a>Functions</h4>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 34--><p class="noindent" ><a 
 id="dx1-111001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_integration</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>F, double x0, double x1, int n, char <span 
class="ts1-lmr10-x-x-109">*</span>meth</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Evaluate  <span 
class="lmex-10">&#x222B;</span>
  <sub><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">0</span></sub></sub><sup><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">1</span></sub></sup><span 
class="lmmi-10x-x-109">F  </span>using  <span class='var'>n</span>  discretization  steps.  The  method  used  to
     discretize the integral is defined by <span class='var'>meth</span> which can be <span class='var'>"rect"</span> (rectangle rule), <span class='var'>"trap"</span>
     (trapezoidal rule), <span class='var'>"simpson"</span> (Simpson&#8217;s rule).
     </p></li>
     <li class="itemize">
     <!--l. 41--><p class="noindent" ><a 
 id="dx1-111002"></a>  <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_integration_2d</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc2D</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>F,  double  x0,  double  x1,  double  y0,
     double y1, int nx, int ny, char <span 
class="ts1-lmr10-x-x-109">*</span>meth</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Evaluate <span 
class="lmex-10">&#x222B;</span>
  <sub><span 
class="rm-lmr-8">[</span><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">0</span></sub><span 
class="lmmi-8">,x</span><sub><span 
class="rm-lmr-6">1</span></sub><span 
class="rm-lmr-8">]</span><span 
class="lmsy8-">&#x00D7;</span><span 
class="rm-lmr-8">[</span><span 
class="lmmi-8">y</span><sub><span 
class="rm-lmr-6">0</span></sub><span 
class="lmmi-8">,y</span><sub><span 
class="rm-lmr-6">1</span></sub><span 
class="rm-lmr-8">]</span></sub><span 
class="lmmi-10x-x-109">F </span>using <span class='var'>nx</span> (resp. <span class='var'>ny</span>) discretization steps for <span class='var'>[x0,
     x1]</span> (resp. <span class='var'>[y0, y1]</span>). The method used to discretize the integral is defined by <span class='var'>meth</span> which
     can be <span class='var'>"rect"</span> (rectangle rule), <span class='var'>"trap"</span> (trapezoidal rule), <span class='var'>"simpson"</span> (Simpson&#8217;s rule).
     </p></li>
     <li class="itemize">
     <!--l. 50--><p class="noindent" ><a 
 id="dx1-111003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_integration_qng</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>F, double x0, double x1, double epsabs, double
     epsrel, double <span 
class="ts1-lmr10-x-x-109">*</span>result, double <span 
class="ts1-lmr10-x-x-109">*</span>abserr, int <span 
class="ts1-lmr10-x-x-109">*</span>neval</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Evaluate <span 
class="lmex-10">&#x222B;</span>
  <sub><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">0</span></sub></sub><sup><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">1</span></sub></sup><span 
class="lmmi-10x-x-109">F </span>with an absolute error less than <span class='var'>espabs</span> and a relative
     error less than <span class='var'>esprel</span>. The value of the integral is stored in <span class='var'>result</span>, while the variables
     <span class='var'>abserr</span> and <span class='var'>neval</span> respectively contain the absolute error and the number of function
     evaluations. This function returns <span class='var'>OK</span> if the required accuracy has been reached and
     <span class='var'>FAIL</span> otherwise. This function uses a non-adaptive Gauss Konrod procedure (qng routine
     from <span 
class="ec-lmri-10x-x-109">QuadPack</span>).
     </p></li>
     <li class="itemize">
     <!--l. 61--><p class="noindent" ><a 
 id="dx1-111004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_integration_GK</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>F, double x0, double x1, double epsabs, double
     epsrel, double <span 
class="ts1-lmr10-x-x-109">*</span>result, double <span 
class="ts1-lmr10-x-x-109">*</span>abserr, int <span 
class="ts1-lmr10-x-x-109">*</span>neval</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This  function  is  a  synonymous  of  <a 
href="#x1-1110008.2">pnl_integration_qng</a>  and  is  only
     available for backward compatibility. It is deprecated, please use <a 
href="#x1-1110008.2">pnl_integration_qng</a>
     instead.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 69--><p class="noindent" ><a 
 id="dx1-111005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_integration_qng_2d</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc2D</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>F, double x0, double x1, double y0,
     double y1, double epsabs, double epsrel, double <span 
class="ts1-lmr10-x-x-109">*</span>result, double <span 
class="ts1-lmr10-x-x-109">*</span>abserr, int <span 
class="ts1-lmr10-x-x-109">*</span>neval</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Evaluate <span 
class="lmex-10">&#x222B;</span>
  <sub><span 
class="rm-lmr-8">[</span><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">0</span></sub><span 
class="lmmi-8">,x</span><sub><span 
class="rm-lmr-6">1</span></sub><span 
class="rm-lmr-8">]</span><span 
class="lmsy8-">&#x00D7;</span><span 
class="rm-lmr-8">[</span><span 
class="lmmi-8">y</span><sub><span 
class="rm-lmr-6">0</span></sub><span 
class="lmmi-8">,y</span><sub><span 
class="rm-lmr-6">1</span></sub><span 
class="rm-lmr-8">]</span></sub><span 
class="lmmi-10x-x-109">F </span>with an absolute error less than <span class='var'>espabs</span> and a
     relative error less than <span class='var'>esprel</span>. The value of the integral is stored in <span class='var'>result</span>, while the
     variables <span class='var'>abserr</span> and <span class='var'>neval</span> respectively contain the absolute error and the number of
     function evaluations. This function returns <span class='var'>OK</span> if the required accuracy has been reached
     and <span class='var'>FAIL</span> otherwise.
     </p></li>
     <li class="itemize">
     <!--l. 79--><p class="noindent" ><a 
 id="dx1-111006"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_integration_GK2D</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>F, double x0, double x1, double epsabs,
     double epsrel, double <span 
class="ts1-lmr10-x-x-109">*</span>result, double <span 
class="ts1-lmr10-x-x-109">*</span>abserr, int <span 
class="ts1-lmr10-x-x-109">*</span>neval</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This   function   is   a   synonymous   of   <a 
href="#x1-1110008.2">pnl_integration_qng_2d</a>   and
     is   only   available   for   backward   compatibility.   It   is   deprecated,   please   use
     <a 
href="#x1-1110008.2">pnl_integration_qng_2d</a> instead.
     </p></li>
     <li class="itemize">
     <!--l. 87--><p class="noindent" ><a 
 id="dx1-111007"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_integration_qag</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>F, double x0, double x1, double epsabs, int
     limit, double epsrel, double <span 
class="ts1-lmr10-x-x-109">*</span>result, double <span 
class="ts1-lmr10-x-x-109">*</span>abserr, int <span 
class="ts1-lmr10-x-x-109">*</span>neval</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Evaluate  <span 
class="lmex-10">&#x222B;</span>
  <sub><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">0</span></sub></sub><sup><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">1</span></sub></sup><span 
class="lmmi-10x-x-109">F  </span>with  an  absolute  error  less  than  <span class='var'>espabs</span>  and  a
     relative error less than <span class='var'>esprel</span>. <span class='var'>x0</span> and <span class='var'>x1</span> can be non finite (i.e. <span class='var'>PNL_NEGINF</span> or
     <span class='var'>PNL_POSINF</span>). The value of the integral is stored in <span class='var'>result</span>, while the variables <span class='var'>abserr</span>
     and <span class='var'>neval</span> respectively contain the absolute error and the number of iterations. <span class='var'>limit</span> is
     the maximum number of subdivisions of the interval <span class='var'>(x0,x1)</span> used during the integration.
     If on input, <span class='var'>limit 0</span>, then 750 subdivisions are used. This function returns <span class='var'>OK</span> if the
     required  accuracy  has  been  reached  and  <span class='var'>FAIL</span>  otherwise.  This  function  uses  some
     adaptive procedures (qags and qagi routines from <span 
class="ec-lmri-10x-x-109">QuadPack</span>). This function is able to
     handle functions <span class='var'>F</span> with integrable singularities on the interval <span class='var'>[x0,x1]</span>.
     </p></li>
     <li class="itemize">
     <!--l. 103--><p class="noindent" ><a 
 id="dx1-111008"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_integration_qagp</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>F,  double  x0,  double  x1,  const  PnlVect
     <span 
class="ts1-lmr10-x-x-109">*</span>singularities, double epsabs, int limit, double epsrel, double <span 
class="ts1-lmr10-x-x-109">*</span>result, double <span 
class="ts1-lmr10-x-x-109">*</span>abserr, int
     <span 
class="ts1-lmr10-x-x-109">*</span>neval</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Evaluate  <span 
class="lmex-10">&#x222B;</span>
  <sub><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">0</span></sub></sub><sup><span 
class="lmmi-8">x</span><sub><span 
class="rm-lmr-6">1</span></sub></sup><span 
class="lmmi-10x-x-109">F  </span>for  a  function  <span class='var'>F</span>  with  known  singularities  listed  in
     <span class='var'>singularities</span>. <span class='var'>singularities</span> must be a sorted vector which does not contain <span class='var'>x0</span> nor <span class='var'>x1</span>. <span class='var'>x0</span>
     and <span class='var'>x1</span> must be finite. The value of the integral is stored in <span class='var'>result</span>, while the variables
     <span class='var'>abserr</span> and <span class='var'>neval</span> respectively contain the absolute error and the number of iterations.
     <span class='var'>limit</span> is the maximum number of subdivisions of the interval <span class='var'>(x0,x1)</span> used during the
     integration. If on input, <span class='var'>limit = 0</span>, then 750 subdivisions are used. This function returns
     <span class='var'>OK</span> if the required accuracy has been reached and <span class='var'>FAIL</span> otherwise. This function uses
     some adaptive procedures (qagp routine from <span 
class="ec-lmri-10x-x-109">QuadPack</span>). This function is able to handle
     functions <span class='var'>F</span> with integrable singularities on the interval <span class='var'>[x0,x1]</span>.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">9   </span> <a 
 id="x1-1120009"></a>Fast Fourier Transform</h3>
<!--l. 2--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">9.1   </span> <a 
 id="x1-1130009.1"></a>Overview</h4>
<!--l. 4--><p class="noindent" >This toolbox uses C version of the Fortran FFTPack library available on    <a 
href="http://www.netlib.org/fftpack" class="url" ><span 
class="ec-lmtt-10x-x-109">http://www.netlib.org/fftpack</span></a>.
<br 
class="newline" />
</p><!--l. 7--><p class="noindent" >The forward Fourier transform of a vector <span 
class="lmmi-10x-x-109">c </span>is defined by
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual30x.png" alt="     N&#x2211;- 1   -ijk2&#x03C0;&#x2215;N
zj =     cke       ,  j = 0,&#x22C5;&#x22C5;&#x22C5; ,N - 1
     k=0
" class="math-display"  /></div>
</td></tr></table>
<!--l. 10--><p class="nopar" >The inverse Fourier transform enables to recover <span 
class="lmmi-10x-x-109">c </span>from <span 
class="lmmi-10x-x-109">z </span>and is defined by
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual31x.png" alt="    -1 N&#x2211;- 1   ijk2&#x03C0;&#x2215;N
ck = N      cke      ,  j = 0,&#x22C5;&#x22C5;&#x22C5; ,N - 1
       k=0
" class="math-display"  /></div>
</td></tr></table>
<!--l. 14--><p class="nopar" >Note that the inverse Fourier transform is scaled by <img 
src="pnl-manual32x.png" alt="-1
N"  class="frac" align="middle" />, such that the inverse Fourier transform
applies to the Fourier transform just yields the original vector.
</p><!--l. 18--><p class="noindent" >The coefficients of the Fourier transform of a real function satisfy the following relation
</p>
                                                                                    

                                                                                    
<table 
class="equation"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual33x.png" alt="     -----
zk = zN-k,
" class="math-display"  /><a 
 id="x1-113001r2"></a></div>
</td><td class="equation-label">(2)</td></tr></table>
<!--l. 23--><p class="nopar" >where <span 
class="lmmi-10x-x-109">N </span>is the number of discretization points.
</p><!--l. 26--><p class="noindent" >A few remarks on the FFT of real functions and its inverse transform: </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 28--><p class="noindent" >We only need half of the coefficients.
     </p></li>
     <li class="itemize">
     <!--l. 29--><p class="noindent" >When a value is known to be real, its imaginary part is not stored. So the imaginary
     part of the zero-frequency component is never stored as it is known to be zero.
     </p></li>
     <li class="itemize">
     <!--l. 32--><p class="noindent" >For a sequence of even length the imaginary part of the frequency <span 
class="lmmi-10x-x-109">n&#x2215;</span><span 
class="rm-lmr-10x-x-109">2 </span>is not stored
     either, since the symmetry (2) implies that this is purely real too.</p></li></ul>
<!--l. 38--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-114000"></a><span 
class="ec-lmbx-10x-x-109">FFTPack storage</span></span>
<a 
 id="x1-114000doc"></a>
The functions use the fftpack storage convention for half-complex sequences. In this convention, the
half-complex transform of a real sequence is stored with frequencies in increasing order,
starting from zero, with the real and imaginary parts of each frequency in neighboring
locations.
</p><!--l. 46--><p class="noindent" >The storage scheme is best shown by some examples. The table below shows the output for an
odd-length sequence, <span 
class="lmmi-10x-x-109">n </span><span 
class="rm-lmr-10x-x-109">= 5</span>. The two columns give the correspondence between the <span 
class="rm-lmr-10x-x-109">5 </span>values in the
half-complex sequence (stored in a PnlVect <span 
class="lmmi-10x-x-109">V </span>) and the values (PnlVectComplex <span 
class="lmmi-10x-x-109">C</span>) that would be
returned if the same real input sequence were passed to <a 
href="#x1-1160009.2.1">pnl_fft</a> as a complex sequence (with
imaginary parts set to 0),
</p>
<table 
class="equation"><tr><td>
                                                                                    

                                                                                    
<div class="math-display" >
<img 
src="pnl-manual34x.png" alt="C(0) = V(0) + i0,
C(1) = V(1) + iV (2),
C(2) = V(3) + iV (4), -----
C(3) = V(3) - iV (4) = C (2),
C(4) = V(1) + iV (2) = C-(1)
" class="math-display"  /><a 
 id="x1-114001r3"></a></div>
</td><td class="equation-label">(3)</td></tr></table>
<!--l. 60--><p class="nopar" >
</p><!--l. 62--><p class="noindent" >The elements of index greater than <span 
class="lmmi-10x-x-109">N&#x2215;</span><span 
class="rm-lmr-10x-x-109">2 </span>of the complex array, as <span 
class="lmmi-10x-x-109">C</span><span 
class="rm-lmr-10x-x-109">(3) </span>and <span 
class="lmmi-10x-x-109">C</span><span 
class="rm-lmr-10x-x-109">(4) </span>are filled in using
the symmetry condition.
</p><!--l. 65--><p class="noindent" >The next table shows the output for an even-length sequence, <span 
class="lmmi-10x-x-109">n </span><span 
class="rm-lmr-10x-x-109">= 6</span>. In the even case, there are two
values which are purely real,
</p>
<table 
class="equation"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual35x.png" alt="C(0) = V(0) + i0,

C(1) = V(1) + iV (2),
C(2) = V(3) + iV (4),---
C(3) = V(5) - i0 = C (0),---
C(4) = V(3) - iV (4) = C-(2),
C(5) = V(1) + iV (2) = C (1)
" class="math-display"  /><a 
 id="x1-114002r4"></a></div>
</td><td class="equation-label">(4)</td></tr></table>
<!--l. 76--><p class="nopar" >
</p><!--l. 79--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">9.2   </span> <a 
 id="x1-1150009.2"></a>Functions</h4>
<!--l. 81--><p class="noindent" >To use the following functions, you should include <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_fft.h</span></span></span>.
                                                                                    

                                                                                    
</p><!--l. 83--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">9.2.1   </span> <a 
 id="x1-1160009.2.1"></a>Direct call functions</h5>
<!--l. 84--><p class="noindent" >All FFT functions need some extra memory to perform their computations. This is automatically
handled by all the functions but you can these repeatedly, for instance inside a Monte Carlo loop,
you should allocate a workspace once and for all and use the same at every iteration. In this case,
use the functions defined in Section&#x00A0;9.2.2.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 87--><p class="noindent" ><a 
 id="dx1-116001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_fft_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>data</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the FFT of <span class='var'>data</span> in place. The original content of <span class='var'>data</span> is lost.
     </p></li>
     <li class="itemize">
     <!--l. 91--><p class="noindent" ><a 
 id="dx1-116002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ifft_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>data</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of <span class='var'>data</span> in place. The original content of <span class='var'>data</span>
     is lost.
     </p></li>
     <li class="itemize">
     <!--l. 95--><p class="noindent" ><a 
 id="dx1-116003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_fft</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the FFT of <span class='var'>in</span> and stores it into <span class='var'>out</span>.
     </p></li>
     <li class="itemize">
     <!--l. 99--><p class="noindent" ><a 
 id="dx1-116004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ifft</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of <span class='var'>in</span> and stores it into <span class='var'>out</span>.
     </p></li>
     <li class="itemize">
     <!--l. 103--><p class="noindent" ><a 
 id="dx1-116005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_fft2</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>re, double <span 
class="ts1-lmr10-x-x-109">*</span>im, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the FFT of the vector of length <span class='var'>n</span> whose real (resp. imaginary)
     parts are given by the arrays <span class='var'>re</span> (resp. <span class='var'>im</span>). The real and imaginary parts of the FFT
     are respectively stored in <span class='var'>re</span> and <span class='var'>im</span> on output.
     </p></li>
     <li class="itemize">
     <!--l. 109--><p class="noindent" ><a 
 id="dx1-116006"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ifft2</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>re, double <span 
class="ts1-lmr10-x-x-109">*</span>im, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of the vector of length <span class='var'>n</span> whose real (resp.
     imaginary) parts are given by the arrays <span class='var'>re</span> (resp. <span class='var'>im</span>). The real and imaginary parts of
     the inverse FFT are respectively stored in <span class='var'>re</span> and <span class='var'>im</span> on output.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 115--><p class="noindent" ><a 
 id="dx1-116007"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_fft</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the FFT of the real valued sequence <span class='var'>in</span> and stores it into <span class='var'>out</span>.
     </p></li>
     <li class="itemize">
     <!--l. 120--><p class="noindent" ><a 
 id="dx1-116008"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_ifft</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of <span class='var'>in</span> and stores it into <span class='var'>out</span>. The vector <span class='var'>in</span> is
     supposed to be the FFT of a real valued vector.
     </p></li>
     <li class="itemize">
     <!--l. 124--><p class="noindent" ><a 
 id="dx1-116009"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_fft_inplace</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>data, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the FFT of the real valued vector <span class='var'>data</span> of length <span class='var'>n</span>. The result
     is stored in <span class='var'>data</span> using the FFTPack storage described above, see&#x00A0;9.1.0.0.
     </p></li>
     <li class="itemize">
     <!--l. 129--><p class="noindent" ><a 
 id="dx1-116010"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_ifft_inplace</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>data, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of the vector <span class='var'>data</span> of length <span class='var'>n</span>. <span class='var'>data</span> is supposed
     to be the FFT coefficients a real valued sequence stored using the FFTPack storage.
     On output, <span class='var'>data</span> contains the inverse FFT.
     </p></li>
     <li class="itemize">
     <!--l. 135--><p class="noindent" ><a 
 id="dx1-116011"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_fft2</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>re, double <span 
class="ts1-lmr10-x-x-109">*</span>im, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the FFT of the real vector <span class='var'>re</span> of length <span class='var'>n</span>. <span class='var'>im</span> is only used on
     output to store the imaginary part the FFT. The real part is stored into <span class='var'>re</span>
     </p></li>
     <li class="itemize">
     <!--l. 140--><p class="noindent" ><a 
 id="dx1-116012"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_ifft2</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>re, double <span 
class="ts1-lmr10-x-x-109">*</span>im, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of the vector <span class='var'>re + i * im</span> of length <span class='var'>n</span>, which is
     supposed to be the FFT of a real valued sequence. On exit, <span class='var'>im</span> is unused.
     </p></li>
     <li class="itemize">
     <!--l. 144--><p class="noindent" ><a 
 id="dx1-116013"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_fft2d_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>data</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the 2D FFT of <span class='var'>data</span>. This function applies a 1D FFT to each
     row of the matrix and then a 1D FFT to each column of the modified matrix.
     </p></li>
     <li class="itemize">
     <!--l. 148--><p class="noindent" ><a 
 id="dx1-116014"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ifft2d_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>data</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse 2D FFT of <span class='var'>data</span>. This function is the inverse of the
     function <a 
href="#x1-1160009.2.1">pnl_fft2d_inplace</a>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 151--><p class="noindent" ><a 
 id="dx1-116015"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_fft2d</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the 2D FFT of <span class='var'>in</span> and stores it into <span class='var'>out</span>.
     </p></li>
     <li class="itemize">
     <!--l. 153--><p class="noindent" ><a 
 id="dx1-116016"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ifft2d</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse 2D FFT of <span class='var'>in</span> and stores it into <span class='var'>out</span>.
     </p></li>
     <li class="itemize">
     <!--l. 155--><p class="noindent" ><a 
 id="dx1-116017"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_fft2d</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the 2D FFT of the real matrix <span class='var'>in</span> and stores it into <span class='var'>out</span>.
     </p></li>
     <li class="itemize">
     <!--l. 157--><p class="noindent" ><a 
 id="dx1-116018"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_ifft2d</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse 2D FFT of the complex matrix <span class='var'>in</span> which is known
     to be the forward 2D FFT a real matrix. The result id stored it into <span class='var'>out</span>. Note that this
     function modifies the input matrix <span class='var'>in</span>.</p></li></ul>
<!--l. 163--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">9.2.2   </span> <a 
 id="x1-1170009.2.2"></a>Function with workspace</h5>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 167--><p class="noindent" ><a 
 id="dx1-117001"></a> <span class='ret'>double<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_fft_alloc_wspace</span></span>&#x00A0;(<span class='args'>const char <span 
class="ts1-lmr10-x-x-109">*</span>func, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return an allocated workspace array ready yo use for function <span class='var'>func</span> and
     input data of size <span class='var'>n</span>
     </p></li>
     <li class="itemize">
     <!--l. 170--><p class="noindent" ><a 
 id="dx1-117002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_fft_inplace_with_wspace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>data, double <span 
class="ts1-lmr10-x-x-109">*</span>wspace</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the FFT of <span class='var'>data</span> in place. The original content of <span class='var'>data</span> is lost.
     </p></li>
     <li class="itemize">
     <!--l. 173--><p class="noindent" ><a 
 id="dx1-117003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ifft_inplace_with_wspace</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>data, double <span 
class="ts1-lmr10-x-x-109">*</span>wspace</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of <span class='var'>data</span> in place. The original content of <span class='var'>data</span>
     is lost.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 176--><p class="noindent" ><a 
 id="dx1-117004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_fft_inplace_with_wspace</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>data, double <span 
class="ts1-lmr10-x-x-109">*</span>wspace, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of <span class='var'>in</span> and stores it into <span class='var'>out</span>. The vector <span class='var'>in</span> is
     supposed to be the FFT of a real valued vector.
     </p></li>
     <li class="itemize">
     <!--l. 179--><p class="noindent" ><a 
 id="dx1-117005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_ifft_inplace_with_wspace</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>data, double <span 
class="ts1-lmr10-x-x-109">*</span>wspace, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of the vector <span class='var'>data</span> of length <span class='var'>n</span>. <span class='var'>data</span> is supposed
     to be the FFT coefficients a real valued sequence stored using the FFTPack storage.
     On output, <span class='var'>data</span> contains the inverse FFT.
     </p></li>
     <li class="itemize">
     <!--l. 185--><p class="noindent" ><a 
 id="dx1-117006"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_fft_with_wspace</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out, double
     <span 
class="ts1-lmr10-x-x-109">*</span>wspace</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the FFT of the real valued sequence <span class='var'>in</span> and stores it into <span class='var'>out</span>.
     </p></li>
     <li class="itemize">
     <!--l. 188--><p class="noindent" ><a 
 id="dx1-117007"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_real_ifft_with_wspace</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>in, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>out, double
     <span 
class="ts1-lmr10-x-x-109">*</span>wspace</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse FFT of <span class='var'>in</span> and stores it into <span class='var'>out</span>. The vector <span class='var'>in</span> is
     supposed to be the FFT of a real valued vector.</p></li></ul>
<!--l. 2--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">10   </span> <a 
 id="x1-11800010"></a>Inverse Laplace Transform</h3>
<!--l. 4--><p class="noindent" >For a real valued function <span 
class="lmmi-10x-x-109">f </span>such that <span 
class="lmmi-10x-x-109">t</span><span 
class="lmmi-10x-x-109">&#x27FC;</span><span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">t</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="rm-lmr-10x-x-109">e</span><span 
class="lmsy8-">-</span><span 
class="lmmi-8">&#x03C3;</span><sub><span 
class="lmmi-6">c</span></sub><span 
class="lmmi-8">t</span> is integrable over <span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="rm-lmr-8">+</span></sup>, we can define its Laplace
transform
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual36x.png" alt="       &#x222B;
 ^       &#x221E;      -&#x03BB;t
f(&#x03BB;) =  0  f(t)e   dt    for &#x03BB; &#x2208; &#x2102; with Re (&#x03BB; ) &#x2265; &#x03C3;c.
" class="math-display"  /></div>
</td></tr></table>
                                                                                    

                                                                                    
<!--l. 9--><p class="nopar" >
</p><!--l. 11--><p class="noindent" >To use the following functions, you should include <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_laplace.h</span></span></span>.
<a 
 id="dx1-118001"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-42">
typedef&#x00A0;struct
{
&#x00A0;&#x00A0;dcomplex&#x00A0;(*F)&#x00A0;(dcomplex&#x00A0;x,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlCmplxFunc;
&#x00A0;
</pre>
<!--l. 20--><p class="nopar" >
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 23--><p class="noindent" ><a 
 id="dx1-118002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ilap_euler</span></span>&#x00A0;(<span class='args'><a 
href="#x1-11800010"><span class='struct'>PnlCmplxFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>fhat, double t, int N, int M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  <span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">t</span></span><span 
class="rm-lmr-10x-x-109">)  </span>where  <span 
class="lmmi-10x-x-109">f  </span>is  given  by  its  Laplace  transform  <span class='var'>fhat</span>  by
     numerically inverting the Laplace transform using Euler&#8217;s summation. The values <span class='var'>N =
     M = 15</span> usually give a very good accuracy. For more details on the accuracy of the
     method.
     </p></li>
     <li class="itemize">
     <!--l. 30--><p class="noindent" ><a 
 id="dx1-118003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ilap_cdf_euler</span></span>&#x00A0;(<span class='args'><a 
href="#x1-11800010"><span class='struct'>PnlCmplxFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>fhat, double t, double h, int N, int
     M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  cumulative  distribution  function  <span 
class="lmmi-10x-x-109">F</span><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">t</span></span><span 
class="rm-lmr-10x-x-109">)  </span>where  <span 
class="lmmi-10x-x-109">F</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)  =</span>
     <span 
class="lmex-10">&#x222B;</span>
      <sub><span 
class="rm-lmr-8">0</span></sub><sup><span 
class="lmmi-8">x</span></sup><span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">t</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">dt </span>and <span 
class="lmmi-10x-x-109">f </span>is a density function with values on the positive real linegiven by its
     Laplace transform <span class='var'>fhat</span>. The computation is carried out by numerical inversion of the
     Laplace transform using Euler&#8217;s summation. The values <span class='var'>N = M = 15</span> usually give a
     very good accuracy. The parameter <span class='var'>h</span> is the discretization step, the algorithm is very
     sensitive to the choice of <span class='var'>h</span>.
     </p></li>
     <li class="itemize">
     <!--l. 40--><p class="noindent" ><a 
 id="dx1-118004"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ilap_fft</span></span>&#x00A0;(<span class='args'><a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>res, <a 
href="#x1-11800010"><span class='struct'>PnlCmplxFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>fhat, double T, double eps</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">t</span><span 
class="rm-lmr-10x-x-109">) </span>for <span 
class="lmmi-10x-x-109">t </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">h,</span><span class='var'><span 
class="lmmi-10x-x-109">T</span></span><span 
class="rm-lmr-10x-x-109">] </span>on a regular grid and stores the values in
     <span class='var'>res</span>, where <span 
class="lmmi-10x-x-109">h </span><span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">T&#x2215;</span><span 
class="rm-lmr-10x-x-109">s</span><span 
class="lmmi-10x-x-109">ize</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">res</span><span 
class="rm-lmr-10x-x-109">)</span>. The function <span 
class="lmmi-10x-x-109">f </span>is defined by its Laplace transform <span class='var'>fhat</span>,
     which is numerically inverted using a Fast Fourier Transform algorithm. The size of <span class='var'>res</span>
     is related to the choice of the relative precision <span class='var'>eps</span> required on the value of <span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">t</span><span 
class="rm-lmr-10x-x-109">) </span>for all
     <span 
class="lmmi-10x-x-109">t </span><span 
class="lmsy-10x-x-109">&#x2264; </span><span 
class="lmmi-10x-x-109">T</span>.
     </p></li>
     <li class="itemize">
     <!--l. 49--><p class="noindent" ><a 
 id="dx1-118005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ilap_gs</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>fhat, double t, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  <span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">t</span></span><span 
class="rm-lmr-10x-x-109">)  </span>where  <span 
class="lmmi-10x-x-109">f  </span>is  given  by  its  Laplace  transform  <span class='var'>fhat</span>  by
                                                                                    

                                                                                    
     numerically inverting the Laplace transform using a weighted combination of different
     Gaver Stehfest&#8217;s algorithms. Note that this function does not need the complex valued
     Laplace transform but only the real valued one. <span class='var'>n</span> is the number of terms used in the
     weighted combination.
     </p></li>
     <li class="itemize">
     <!--l. 57--><p class="noindent" ><a 
 id="dx1-118006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ilap_gs_basic</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>fhat, double t, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  <span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">t</span></span><span 
class="rm-lmr-10x-x-109">)  </span>where  <span 
class="lmmi-10x-x-109">f  </span>is  given  by  its  Laplace  transform  <span class='var'>fhat</span>  by
     numerically inverting the Laplace transform using Gaver Stehfest&#8217;s method. Note that
     this function does not need the complex valued Laplace transform but only the real
     valued one. <span class='var'>n</span> is the number of iterations of the algorithm. <span 
class="ec-lmbx-10x-x-109">Note : </span>&#x00A0;This function
     is provided for test purposes only. The function <a 
href="#x1-11800010">pnl_ilap_gs</a> gives far more accurate
     results.</p></li></ul>
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">11   </span> <a 
 id="x1-11900011"></a>Ordinary differential equations</h3>
<!--l. 2--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">11.1   </span> <a 
 id="x1-12000011.1"></a>Overview</h4>
<!--l. 4--><p class="noindent" >To use these functionalities, you should include <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_integration.h</span></span></span>.
</p><!--l. 6--><p class="noindent" >These functions are designed for numerically solving <span 
class="lmmi-10x-x-109">n</span><span 
class="lmsy-10x-x-109">-</span>dimensional first order ordinary differential
equation of the general form
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual37x.png" alt="dyi(t) = fi(t,y1(t),&#x22C5;&#x22C5;&#x22C5; ,yn(t))
dt
" class="math-display"  /></div>
</td></tr></table>
<!--l. 10--><p class="nopar" >The system of equations is defined by the following structure <a 
 id="dx1-120001"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-43">
typedef&#x00A0;struct
{
&#x00A0;&#x00A0;void&#x00A0;(*F)&#x00A0;(int&#x00A0;neqn,&#x00A0;double&#x00A0;t,&#x00A0;const&#x00A0;double&#x00A0;*y,&#x00A0;double&#x00A0;*yp,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;int&#x00A0;neqn;
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlODEFunc&#x00A0;;
</pre>
<!--l. 20--><p class="nopar" >
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 23--><p class="noindent" >int&#x00A0;<span 
class="ec-lmbx-10x-x-109">neqn</span><br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Number of equations
     </p></li>
     <li class="itemize">
     <!--l. 25--><p class="noindent" >void <span 
class="ts1-lmr10-x-x-109">*</span>&#x00A0;<span 
class="ec-lmbx-10x-x-109">params</span><br 
class="newline" />   <span class='description'>Description&#x00A0;</span>An untyped structure used to pass extra arguments to the function <span class='var'>f</span>
     defining the system
     </p></li>
     <li class="itemize">
     <!--l. 28--><p class="noindent" ><span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">(</span><span 
class="ts1-lmbx10-x-x-109">*</span><span 
class="ec-lmbx-10x-x-109">&#x00A0;F)</span></span>&#x00A0;(<span class='args'>int neqn, double t, const double <span 
class="ts1-lmr10-x-x-109">*</span>y, double <span 
class="ts1-lmr10-x-x-109">*</span>yp, void <span 
class="ts1-lmr10-x-x-109">*</span>params</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>After calling the fuction, <span class='var'>yp</span> should be defined as follows <span class='var'>yp_i = f_i(neqn,
     t, y, params)</span>. <span class='var'>y</span> and <span class='var'>yp</span> should be both of size <span class='var'>neqn</span></p></li></ul>
<!--l. 34--><p class="noindent" >We provide the following macro to evaluate a <a 
href="#x1-12000011.1"><span class='struct'>PnlODEFunc</span></a> at a given point
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-44">
#define&#x00A0;PNL_EVAL_ODEFUNC(Fstruct,&#x00A0;t,&#x00A0;y,&#x00A0;yp)&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(*((Fstruct)-&#x003E;F))((Fstruct)-&#x003E;neqn,&#x00A0;t,&#x00A0;y,&#x00A0;yp,&#x00A0;(Fstruct)-&#x003E;params)
</pre>
<!--l. 39--><p class="nopar" >
</p><!--l. 41--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">11.2   </span> <a 
 id="x1-12100011.2"></a>Functions</h4>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 44--><p class="noindent" ><a 
 id="dx1-121001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ode_rkf45</span></span>&#x00A0;(<span class='args'><a 
href="#x1-12000011.1"><span class='struct'>PnlODEFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>f, double <span 
class="ts1-lmr10-x-x-109">*</span>y, double t, double t_out, double relerr,
     double abserr, int <span 
class="ts1-lmr10-x-x-109">*</span>flag</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function computes the solution of the system defined by the <a 
href="#x1-12000011.1"><span class='struct'>PnlODEFunc</span></a>
     <span class='var'>f</span> at the point <span class='var'>t_out</span>. On input, <span class='var'><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">t,y</span><span 
class="rm-lmr-10x-x-109">)</span></span> should be the initial condition, <span class='var'>abserr,relerr</span> are the
     maximum absolute and relative errors for local error tests (at each step, <span class='var'>abs(local error)</span>
     should be less that <span class='var'>relerr * abs(y) + abserr</span>). Note that if <span class='var'>abserr = 0</span> or <span class='var'>relerr = 0</span> on
     input, an optimal value for these variables is computed inside the function The
     function returns an error <span class='var'>OK</span> or <span class='var'>FAIL</span>. In case of an <span class='var'>OK</span> code, the <span class='var'>y</span> contains the
     solution computed at <span class='var'>t_out</span>, in case of a <span class='var'>FAIL</span> code, <span class='var'>flag</span> should be examined to
     determine the reason of the error. Here are the different possible values for <span class='var'>flag</span>
     </p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 58--><p class="noindent" ><span class='var'>flag = 2</span> : integration reached <span class='var'>t_out</span>, it indicates successful return and is the normal
          mode for continuing integration.
          </p></li>
          <li class="itemize">
          <!--l. 60--><p class="noindent" ><span class='var'>flag = 3</span> : integration was not completed because relative error tolerance was too
          small. relerr has been increased appropriately for continuing.
          </p></li>
          <li class="itemize">
          <!--l. 63--><p class="noindent" ><span class='var'>flag  =  4</span>  :  integration  was  not  completed  because  more  than  3000  derivative
          evaluations were needed. this is approximately 500 steps.
          </p></li>
          <li class="itemize">
          <!--l. 65--><p class="noindent" ><span class='var'>flag = 5</span> : integration was not completed because solution vanished making a pure
          relative error test impossible.  must use non-zero abserr to continue.  using the
          one-step integration mode for one step is a good way to proceed.
                                                                                    

                                                                                    
          </p></li>
          <li class="itemize">
          <!--l. 69--><p class="noindent" ><span class='var'>flag = 6</span> : integration was not completed because requested accuracy could not be
          achieved using smallest allowable stepsize. user must increase the error tolerance
          before continued integration can be attempted.
          </p></li>
          <li class="itemize">
          <!--l. 72--><p class="noindent" ><span class='var'>flag = 7</span> : it is likely that rkf45 is inefficient for solving this problem. too much
          output is restricting the natural stepsize choice. use the one-step integrator mode.
          see <a 
href="#x1-12100011.2">pnl_ode_rkf45_step</a>.
          </p></li>
          <li class="itemize">
          <!--l. 75--><p class="noindent" ><span class='var'>flag = 8</span> : invalid input parameters this indicator occurs if any of the following is
          satisfied - neqn &#x003C;= 0, t=tout, relerr or abserr &#x003C;= 0.</p></li></ul>
     </li>
     <li class="itemize">
     <!--l. 78--><p class="noindent" ><a 
 id="dx1-121002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_ode_rkf45_step</span></span>&#x00A0;(<span class='args'><a 
href="#x1-12000011.1"><span class='struct'>PnlODEFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>f, double <span 
class="ts1-lmr10-x-x-109">*</span>y, double <span 
class="ts1-lmr10-x-x-109">*</span>t, double t_out, double
     <span 
class="ts1-lmr10-x-x-109">*</span>relerr, double abserr, double <span 
class="ts1-lmr10-x-x-109">*</span>work, int <span 
class="ts1-lmr10-x-x-109">*</span>iwork, int <span 
class="ts1-lmr10-x-x-109">*</span>flag</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-12100011.2">pnl_ode_rkf45</a> but it only computes one step of integration in the
     direction of <span class='var'>t_out</span>. <span class='var'>work</span> and <span class='var'>iwork</span> are working arrays of size <span class='var'>3 + 6 * neqn</span> and <span class='var'>5</span> respectively
     and should remain untouched between successive calls to the function. On output <span class='var'>t</span> holds
     the point at which integration stopped and <span class='var'>y</span> the value of the solution at that
     point.</p></li></ul>
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">12   </span> <a 
 id="x1-12200012"></a>Optimization</h3>
<!--l. 3--><p class="noindent" >To use the functions described in this section, you should include <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_optim.h</span></span></span>.
</p><!--l. 5--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">12.1   </span> <a 
 id="x1-12300012.1"></a>Linear constrained optimization (linear programming)</h4>
<!--l. 7--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">12.1.1   </span> <a 
 id="x1-12400012.1.1"></a>Overview</h5>
<!--l. 9--><p class="noindent" >Consider the minimization problem
                                                                                    

                                                                                    
</p><table 
class="align-star">
                                <tr><td 
class="align-odd"><span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">x</span></sub>   </td>                                <td 
class="align-even"><span 
class="lmmi-10x-x-109">C</span><sup><span 
class="lmmi-8">T</span> </sup> <span 
class="lmmi-10x-x-109">x</span></td>                                            <td 
class="align-label"></td>                                <td 
class="align-label">
                                </td></tr><tr><td 
class="align-odd">s.t.   </td>                                  <td 
class="align-even"><span 
class="lmmi-10x-x-109">A</span><sub>ineq</sub> <span 
class="lmmi-10x-x-109">x </span><span 
class="lmsy-10x-x-109">&#x2264; </span><span 
class="lmmi-10x-x-109">B</span><sub>ineq</sub></td>                                 <td 
class="align-label"></td>                                <td 
class="align-label">
                                </td></tr><tr><td 
class="align-odd"></td>                                       <td 
class="align-even"><span 
class="lmmi-10x-x-109">A</span><sub>eq</sub> <span 
class="lmmi-10x-x-109">x </span><span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">B</span><sub>eq</sub></td>                                    <td 
class="align-label"></td>                                <td 
class="align-label">
                                </td></tr><tr><td 
class="align-odd"></td>                                       <td 
class="align-even"><span 
class="lmmi-10x-x-109">x</span><sub>min</sub> <span 
class="lmsy-10x-x-109">&#x2264; </span><span 
class="lmmi-10x-x-109">x </span><span 
class="lmsy-10x-x-109">&#x2264; </span><span 
class="lmmi-10x-x-109">x</span><sub>max</sub></td>                                <td 
class="align-label"></td>                                <td 
class="align-label"></td></tr></table>
<!--l. 18--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">12.1.2   </span> <a 
 id="x1-12500012.1.2"></a>Functions</h5>
<!--l. 19--><p class="noindent" >To solve such a linear problem, we provide a wrapper to the <span 
class="ec-lmri-10x-x-109">LPSolve </span>library (
<a 
href="http://lpsolve.sourceforge.net" class="url" ><span 
class="ec-lmtt-10x-x-109">http://lpsolve.sourceforge.net</span></a>). </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 22--><p class="noindent" ><a 
 id="dx1-125001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_optim_linprog</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A_ineq, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>B_ineq, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A_eq, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B_eq, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x_min, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x_max, int debug, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>xopt, double <span 
class="ts1-lmr10-x-x-109">*</span>fobj_opt</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function has the following arguments: </p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 25--><p class="noindent" ><span class='var'>C</span> The coefficients of the linear objective function.
          </p></li>
          <li class="itemize">
          <!--l. 26--><p class="noindent" ><span class='var'>A_ineq</span> The l.h.s matrix of the inequality constraints. Can be NULL.
          </p></li>
          <li class="itemize">
          <!--l. 27--><p class="noindent" ><span class='var'>B_ineq</span> The r.h.s vector of the inequality constraints. The lengh of <span class='var'>B_ineq</span> must
          match the number of rows of <span class='var'>A_ineq</span>.
          </p></li>
          <li class="itemize">
          <!--l. 29--><p class="noindent" ><span class='var'>A_eq</span> The l.h.s matrix of the equality constraints. Can be NULL.
                                                                                    

                                                                                    
          </p></li>
          <li class="itemize">
          <!--l. 30--><p class="noindent" ><span class='var'>B_eq</span> The r.h.s vector of the equality constraints. The lengh of <span class='var'>B_eq</span> must match
          the number of rows of <span class='var'>A_ineq</span>.
          </p></li>
          <li class="itemize">
          <!--l. 32--><p class="noindent" ><span class='var'>x_min</span> The lower bound on <span class='var'>x</span>. If NULL, it means all the components of <span class='var'>x</span> must be
          non negative.
          </p></li>
          <li class="itemize">
          <!--l. 34--><p class="noindent" ><span class='var'>x_max</span> The upper bound on <span class='var'>x</span>. If NULL, it means <span class='var'>+Infinity</span> for all the components.
          </p></li>
          <li class="itemize">
          <!--l. 36--><p class="noindent" ><span class='var'>debug</span> TRUE or FALSE. If TRUE some debugging details are printed.
          </p></li>
          <li class="itemize">
          <!--l. 37--><p class="noindent" ><span class='var'>xopt</span> The <span class='var'>argmin</span> of the problem.
          </p></li>
          <li class="itemize">
          <!--l. 38--><p class="noindent" ><span class='var'>fobj_opt</span> The value of the obective funtion at the optimum <span class='var'>xopt</span></p></li></ul>
     <!--l. 40--><p class="noindent" >The function returns <span class='var'>OK</span> or <span class='var'>FAIL</span>.
     </p></li>
     <li class="itemize">
     <!--l. 42--><p class="noindent" ><a 
 id="dx1-125002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_optim_linprog_sp</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A_ineq, const
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B_ineq, const <a 
href="#x1-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A_eq, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B_eq, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>index_min, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x_min, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>index_max, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x_max,
     int debug, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>xopt, double <span 
class="ts1-lmr10-x-x-109">*</span>fobj_opt</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function has the following arguments: </p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 45--><p class="noindent" ><span class='var'>C</span> The coefficients of the linear obejctive function, given as a sparse matrix with a
          single column.
          </p></li>
          <li class="itemize">
          <!--l. 47--><p class="noindent" ><span class='var'>A_ineq</span> The l.h.s matrix of the inequality constraints. Can be NULL.
          </p></li>
          <li class="itemize">
          <!--l. 48--><p class="noindent" ><span class='var'>B_ineq</span> The r.h.s vector of the inequality constraints. The lengh of <span class='var'>B_ineq</span> must
          match the number of rows of <span class='var'>A_ineq</span>.
          </p></li>
          <li class="itemize">
          <!--l. 50--><p class="noindent" ><span class='var'>A_eq</span> The l.h.s matrix of the equality constraints. Can be NULL.
                                                                                    

                                                                                    
          </p></li>
          <li class="itemize">
          <!--l. 51--><p class="noindent" ><span class='var'>B_eq</span> The r.h.s vector of the equality constraints. The lengh of <span class='var'>B_eq</span> must match
          the number of rows of <span class='var'>A_ineq</span>.
          </p></li>
          <li class="itemize">
          <!--l. 53--><p class="noindent" ><span class='var'>index_min</span>  The  indices  of  the  variables  with  a  lower  bound  constraint.  The
          corresponding lower bound is given in <span class='var'>x_min</span>
          </p></li>
          <li class="itemize">
          <!--l. 55--><p class="noindent" ><span class='var'>x_min</span> The lower bound on <span class='var'>x</span>. If NULL, it means all the components of <span class='var'>x</span> must be
          non negative. Can be NULL. For non specified variables, the default lower bound
          is <span class='var'>0</span>.
          </p></li>
          <li class="itemize">
          <!--l. 58--><p class="noindent" ><span class='var'>index_max</span> The indices of the variables with an upper bound constraint. The
          corresponding lower bound is given in <span class='var'>x_max</span>. Can be NULL.
          </p></li>
          <li class="itemize">
          <!--l. 60--><p class="noindent" ><span class='var'>x_max</span> The upper bound on <span class='var'>x</span>. If NULL, it means <span class='var'>+Infinity</span> for all the components.
          For non specified variables, the default upper bound is <span class='var'>+Infinity</span>..
          </p></li>
          <li class="itemize">
          <!--l. 63--><p class="noindent" ><span class='var'>debug</span> TRUE or FALSE. If TRUE some debugging details are printed.
          </p></li>
          <li class="itemize">
          <!--l. 64--><p class="noindent" ><span class='var'>xopt</span> The <span class='var'>argmin</span> of the problem.
          </p></li>
          <li class="itemize">
          <!--l. 65--><p class="noindent" ><span class='var'>fobj_opt</span> The value of the obective funtion at the optimum <span class='var'>xopt</span></p></li></ul>
     <!--l. 67--><p class="noindent" >The function returns <span class='var'>OK</span> or <span class='var'>FAIL</span>.</p></li></ul>
<!--l. 71--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">12.2   </span> <a 
 id="x1-12600012.2"></a>Nonlinear constrained optimization</h4>
<!--l. 72--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">12.2.1   </span> <a 
 id="x1-12700012.2.1"></a>Overview</h5>
<!--l. 74--><p class="noindent" >A standard Constrained Nonlinear Optimization problem can be written as:
                                                                                    

                                                                                    
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual38x.png" alt="     (
     |{ min  f(x)
(O )   cI(x) &#x2265; 0
     |( cE (x ) = 0
" class="math-display"  /></div>
</td></tr></table>
<!--l. 85--><p class="nopar" >
</p><!--l. 87--><p class="noindent" >where the function <span 
class="lmmi-10x-x-109">f </span><span 
class="rm-lmr-10x-x-109">: </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup> <span 
class="lmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D; </span>is the objective function, <span 
class="lmmi-10x-x-109">c</span><sup><span 
class="lmmi-8">I</span></sup> <span 
class="rm-lmr-10x-x-109">: </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup> <span 
class="lmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">m</span><sub><span 
class="lmmi-6">I</span></sub></sup> are the inequality
constraints and <span 
class="lmmi-10x-x-109">c</span><sup><span 
class="lmmi-8">E</span></sup> <span 
class="rm-lmr-10x-x-109">: </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup> <span 
class="lmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">m</span><sub><span 
class="lmmi-6">E</span></sub></sup> are the equality constraints. These functions are supposed to be
smooth.
</p><!--l. 89--><p class="noindent" >In general, the inequality constraints are of the form <span 
class="lmmi-10x-x-109">c</span><sup><span 
class="lmmi-8">I</span></sup><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">) = </span><img 
src="pnl-manual39x.png" alt="(g(x), x- l, u - x)"  class="left" align="middle" />. The vector <span 
class="lmmi-10x-x-109">l </span>and
<span 
class="lmmi-10x-x-109">u </span>are the lower and upper bounds on the variables <span 
class="lmmi-10x-x-109">x </span>and <span 
class="lmmi-10x-x-109">g</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">) </span>and the non linear inequality
constraints.
</p><!--l. 91--><p class="noindent" >Under some conditions, if <span 
class="lmmi-10x-x-109">x </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup> is a solution of problem (<span 
class="lmmi-10x-x-109">O</span>), then there exist a vector
<span 
class="lmmi-10x-x-109">&#x03BB; </span><span 
class="rm-lmr-10x-x-109">= (</span><span 
class="lmmi-10x-x-109">&#x03BB;</span><sup><span 
class="lmmi-8">I</span></sup><span 
class="lmmi-10x-x-109">,&#x03BB;</span><sup><span 
class="lmmi-8">E</span></sup><span 
class="rm-lmr-10x-x-109">) </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">m</span><sub><span 
class="lmmi-6">I</span></sub></sup> <span 
class="lmsy-10x-x-109">&#x00D7; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">m</span><sub><span 
class="lmmi-6">E</span></sub></sup>, such that the well known Karush-Kuhn-Tucker (KKT) optimality
conditions are satisfied:
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual40x.png" alt="    (
    ||  &#x2207; &#x2113;(x,&#x03BB;I,&#x03BB;E) = &#x2207;f (x)- &#x2207;cI (x)&#x03BB;I - &#x2207;cE (x)&#x03BB;E = 0
    ||||                     cE (x ) = 0
    |{                      cI(x) &#x2265; 0
(P )|                       &#x03BB;I &#x2265; 0
    ||||               cI(x)&#x03BB;I = 0, i = 1...m
    ||(                i    i             I
" class="math-display"  /></div>
</td></tr></table>
<!--l. 104--><p class="nopar" >
</p><!--l. 106--><p class="noindent" ><span 
class="lmmi-10x-x-109">l </span>is known as the Lagrangian of the problem <span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">O</span><span 
class="rm-lmr-10x-x-109">)</span>, <span 
class="lmmi-10x-x-109">&#x03BB;</span><sup><span 
class="lmmi-8">I</span></sup> and <span 
class="lmmi-10x-x-109">&#x03BB;</span><sup><span 
class="lmmi-8">E</span></sup> as the dual variables while <span 
class="lmmi-10x-x-109">x </span>is the
primal variable.
                                                                                    

                                                                                    
</p><!--l. 108--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">12.2.2   </span> <a 
 id="x1-12800012.2.2"></a>Functions</h5>
<!--l. 110--><p class="noindent" >To solve an inequality constrained optimization problem, ie <span 
class="lmmi-10x-x-109">m</span><sub><span 
class="lmmi-8">E</span></sub> <span 
class="rm-lmr-10x-x-109">= 0</span>, we provide the following
function. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 112--><p class="noindent" ><a 
 id="dx1-128001"></a>                              <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_optim_intpoints_bfgs_solve</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncR</span></a><span 
class="ts1-lmr10-x-x-109">*</span>func,
     <a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncRm</span></a><span 
class="ts1-lmr10-x-x-109">*</span>grad_func,  <a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncRm</span></a><span 
class="ts1-lmr10-x-x-109">*</span>nl_constraints,  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>lower_bounds,
     <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>upper_bounds,  <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>x_input,  double  tolerance,  int  iter_max,  int
     print_inner_steps, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>output</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This function has the following arguments:
</p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 116--><p class="noindent" ><span class='var'>func</span> is the function to minimize <span 
class="lmmi-10x-x-109">f</span>.
          </p></li>
          <li class="itemize">
          <!--l. 117--><p class="noindent" ><span class='var'>grad</span> is the gradient of <span 
class="lmmi-10x-x-109">f</span>. If this gradient is not available, then enter <span class='var'>grad</span>=NULL.
          In this case, finite difference will be used to estimate the gradient.
          </p></li>
          <li class="itemize">
          <!--l. 118--><p class="noindent" ><span class='var'>nl_constraints</span> is the function <span 
class="lmmi-10x-x-109">g</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>, ie the non linear inequality constraints.
          </p></li>
          <li class="itemize">
          <!--l. 119--><p class="noindent" ><span class='var'>lower_bounds</span> are the lower bounds on <span 
class="lmmi-10x-x-109">x</span>. Can be NULL if there is no lower bound.
          </p></li>
          <li class="itemize">
          <!--l. 121--><p class="noindent" ><span class='var'>upper_bounds</span> are the upper bounds on <span 
class="lmmi-10x-x-109">x</span>. Can be NULL if there is no upper
          bound.
          </p></li>
          <li class="itemize">
          <!--l. 123--><p class="noindent" ><span class='var'>x_input</span> is the initial point where the algorithm starts.
          </p></li>
          <li class="itemize">
          <!--l. 124--><p class="noindent" ><span class='var'>tolerance</span> is the precision required in solving (P).
          </p></li>
          <li class="itemize">
          <!--l. 125--><p class="noindent" ><span class='var'>iter_max</span> is the maximum number of iterations in the algorithm.
                                                                                    

                                                                                    
          </p></li>
          <li class="itemize">
          <!--l. 126--><p class="noindent" ><span class='var'>print_algo_steps</span> is a flag to decide to print information.
          </p></li>
          <li class="itemize">
          <!--l. 127--><p class="noindent" ><span class='var'>x_output</span> is the point where the algorithm stops.</p></li></ul>
     <!--l. 130--><p class="noindent" >The algorithm returns an <span 
class="lmmi-10x-x-109">int</span>, its value depends on the output status of the algorithm. We
     have 4 cases: </p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 132--><p class="noindent" >0: Failure: Initial point is not strictly feasible.
          </p></li>
          <li class="itemize">
          <!--l. 133--><p class="noindent" >1: Step is too small, we stop the algorithm.
          </p></li>
          <li class="itemize">
          <!--l. 134--><p class="noindent" >2: Maximum number of iterations reached.
          </p></li>
          <li class="itemize">
          <!--l. 135--><p class="noindent" >3: A solution has been found up to the required accuracy.</p></li></ul>
     <!--l. 138--><p class="noindent" >The last case is equivalent to the two inequalities:
     </p><!--l. 140--><p class="noindent" >
     </p>
<div class="math-display" >
<img 
src="pnl-manual41x.png" alt="||&#x2207; &#x2113;(x,&#x03BB;I)||&#x221E; = ||&#x2207;f (x )- &#x2207;cI (x )&#x03BB;I||&#x221E; &#x003C; tolerance
" class="math-display"  /></div>
     <!--l. 141--><p class="noindent" >
     </p>
                                                                                    

                                                                                    
<div class="math-display" >
<img 
src="pnl-manual42x.png" alt="||cI(x)&#x03BB;I||  &#x003C; tolerance
         &#x221E;
" class="math-display"  /></div>
     <!--l. 143--><p class="noindent" >where <span 
class="lmmi-10x-x-109">c</span><sup><span 
class="lmmi-8">I</span></sup><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">) </span><span 
class="lmmi-10x-x-109">. </span><span 
class="lmsy-10x-x-109">* </span><span 
class="lmmi-10x-x-109">&#x03BB;</span><sup><span 
class="lmmi-8">I</span></sup> where &#8217;<span 
class="lmmi-10x-x-109">.</span><span 
class="lmsy-10x-x-109">*</span>&#8217; denotes the term by term multiplication.
     </p><!--l. 145--><p class="noindent" >The first inequality is known as the optimality condition, the second one as the
     complementarity condition.<br 
class="newline" />
     </p><!--l. 147--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Remarks </span>Our implementation requires the initial point <span 
class="lmmi-10x-x-109">x</span><sub><span 
class="rm-lmr-8">0</span></sub> to be strictly feasible, ie:
     <span 
class="lmmi-10x-x-109">c</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="rm-lmr-8">0</span></sub><span 
class="rm-lmr-10x-x-109">) </span><span 
class="lmmi-10x-x-109">&#x003E; </span><span 
class="rm-lmr-10x-x-109">0</span>. The algorithm tries to find a pair (<span 
class="lmmi-10x-x-109">x</span>, <span 
class="lmmi-10x-x-109">&#x03BB;</span>) solving the Equations (<span 
class="lmmi-10x-x-109">P</span>), but this does
     not guarantee that <span 
class="lmmi-10x-x-109">x </span>is a global minimum of <span 
class="lmmi-10x-x-109">f </span>on the set <span 
class="lmsy-10x-x-109">{</span><span 
class="lmmi-10x-x-109">c</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">) </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmsy-10x-x-109">}</span>.
</p>
     </li></ul>
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">13   </span> <a 
 id="x1-12900013"></a>Root finding</h3>
<!--l. 2--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">13.1   </span> <a 
 id="x1-13000013.1"></a>Overview</h4>
<!--l. 5--><p class="noindent" >To provide a uniformed framework to root finding functions, we use several structures for storing
different kind of functions. The pointer <span class='var'>params</span> is used to store the extra parameters. These new
types come with dedicated macros starting in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PNL_EVAL</span></span></span> to evaluate the function and their Jacobian.
<a 
 id="dx1-130001"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-45">
/*
&#x00A0;*&#x00A0;f:&#x00A0;R&#x00A0;--&#x003E;&#x00A0;R
&#x00A0;*&#x00A0;The&#x00A0;function&#x00A0;&#x00A0;pointer&#x00A0;returns&#x00A0;f(x)
&#x00A0;*
typedef&#x00A0;struct&#x00A0;{
&#x00A0;&#x00A0;double&#x00A0;(*F)&#x00A0;(double&#x00A0;x,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlFunc&#x00A0;;
#define&#x00A0;PNL_EVAL_FUNC(Fstruct,&#x00A0;x)&#x00A0;(*((Fstruct)-&#x003E;F))(x,&#x00A0;(Fstruct)-&#x003E;params)
</pre>
<!--l. 21--><p class="nopar" >
<a 
 id="dx1-130002"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-46">
/*
&#x00A0;*&#x00A0;f:&#x00A0;R^2&#x00A0;--&#x003E;&#x00A0;R
&#x00A0;*&#x00A0;The&#x00A0;function&#x00A0;pointer&#x00A0;returns&#x00A0;f(x)
&#x00A0;*
typedef&#x00A0;struct&#x00A0;{
&#x00A0;&#x00A0;double&#x00A0;(*F)&#x00A0;(double&#x00A0;x,&#x00A0;double&#x00A0;y,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlFunc2D&#x00A0;;
#define&#x00A0;PNL_EVAL_FUNC2D(Fstruct,&#x00A0;x,&#x00A0;y)&#x00A0;(*((Fstruct)-&#x003E;F))(x,&#x00A0;y,&#x00A0;(Fstruct)-&#x003E;params)
</pre>
<!--l. 34--><p class="nopar" >
<a 
 id="dx1-130003"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-47">
/*
&#x00A0;*&#x00A0;f:&#x00A0;R&#x00A0;--&#x003E;&#x00A0;R
&#x00A0;*&#x00A0;The&#x00A0;function&#x00A0;pointer&#x00A0;computes&#x00A0;f(x)&#x00A0;and&#x00A0;Df(x)&#x00A0;and&#x00A0;stores&#x00A0;them&#x00A0;in&#x00A0;fx
&#x00A0;*&#x00A0;and&#x00A0;dfx&#x00A0;respectively
&#x00A0;*
typedef&#x00A0;struct&#x00A0;{
&#x00A0;&#x00A0;void&#x00A0;(*F)&#x00A0;(double&#x00A0;x,&#x00A0;double&#x00A0;*fx,&#x00A0;double&#x00A0;*dfx,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlFuncDFunc&#x00A0;;
#define&#x00A0;PNL_EVAL_FUNC_FDF(Fstruct,&#x00A0;x,&#x00A0;fx,&#x00A0;dfx)&#x00A0;(*((Fstruct)-&#x003E;F))(x,&#x00A0;fx,&#x00A0;dfx,&#x00A0;(Fstruct)-&#x003E;params)
</pre>
<!--l. 48--><p class="nopar" >
<a 
 id="dx1-130004"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-48">
/*
&#x00A0;*&#x00A0;f:&#x00A0;R^n&#x00A0;--&#x003E;&#x00A0;R
&#x00A0;*&#x00A0;The&#x00A0;function&#x00A0;pointer&#x00A0;returns&#x00A0;f(x)
&#x00A0;*
typedef&#x00A0;struct&#x00A0;{
&#x00A0;&#x00A0;double&#x00A0;(*F)&#x00A0;(const&#x00A0;PnlVect&#x00A0;*x,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlRnFuncR&#x00A0;;
#define&#x00A0;PNL_EVAL_RNFUNCR(Fstruct,&#x00A0;x)&#x00A0;(*((Fstruct)-&#x003E;F))(x,&#x00A0;(Fstruct)-&#x003E;params)
</pre>
<!--l. 61--><p class="nopar" >
<a 
 id="dx1-130005"></a>
<a 
 id="dx1-130006"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-49">
/*
&#x00A0;*&#x00A0;f:&#x00A0;R^n&#x00A0;--&#x003E;&#x00A0;R^m
&#x00A0;*&#x00A0;The&#x00A0;function&#x00A0;pointer&#x00A0;computes&#x00A0;the&#x00A0;vector&#x00A0;f(x)&#x00A0;and&#x00A0;stores&#x00A0;it&#x00A0;in
&#x00A0;*&#x00A0;fx&#x00A0;(vector&#x00A0;of&#x00A0;size&#x00A0;m)
&#x00A0;*
typedef&#x00A0;struct&#x00A0;{
&#x00A0;&#x00A0;void&#x00A0;(*F)&#x00A0;(const&#x00A0;PnlVect&#x00A0;*x,&#x00A0;PnlVect&#x00A0;*fx,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlRnFuncRm&#x00A0;;
#define&#x00A0;PNL_EVAL_RNFUNCRM(Fstruct,&#x00A0;x,&#x00A0;fx)&#x00A0;(*((Fstruct)-&#x003E;F))(x,&#x00A0;fx,&#x00A0;(Fstruct)-&#x003E;params)

/*
&#x00A0;*&#x00A0;Synonymous&#x00A0;of&#x00A0;PnlRnFuncRm&#x00A0;for&#x00A0;f:R^n&#x00A0;--&#x003E;&#x00A0;R^n
&#x00A0;*
typedef&#x00A0;PnlRnFuncRm&#x00A0;PnlRnFuncRn;
#define&#x00A0;PNL_EVAL_RNFUNCRN&#x00A0;&#x00A0;PNL_EVAL_RNFUNCRM
</pre>
<!--l. 82--><p class="nopar" >
<a 
 id="dx1-130007"></a>
<a 
 id="dx1-130008"></a>
                                                                                    

                                                                                    
</p>
<pre class="verbatim" id="verbatim-50">
/*
&#x00A0;*&#x00A0;f:&#x00A0;R^n&#x00A0;--&#x003E;&#x00A0;R^m
&#x00A0;*&#x00A0;The&#x00A0;function&#x00A0;pointer&#x00A0;computes&#x00A0;the&#x00A0;vector&#x00A0;f(x)&#x00A0;and&#x00A0;stores&#x00A0;it&#x00A0;in&#x00A0;fx
&#x00A0;*&#x00A0;(vector&#x00A0;of&#x00A0;size&#x00A0;m)
&#x00A0;*&#x00A0;The&#x00A0;Dfunction&#x00A0;pointer&#x00A0;computes&#x00A0;the&#x00A0;matrix&#x00A0;Df(x)&#x00A0;and&#x00A0;stores&#x00A0;it&#x00A0;in&#x00A0;dfx
&#x00A0;*&#x00A0;(matrix&#x00A0;of&#x00A0;size&#x00A0;m&#x00A0;x&#x00A0;n)
&#x00A0;*
typedef&#x00A0;struct&#x00A0;{
&#x00A0;&#x00A0;void&#x00A0;(*F)&#x00A0;(const&#x00A0;PnlVect&#x00A0;*x,&#x00A0;PnlVect&#x00A0;*fx,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;(*DF)&#x00A0;(const&#x00A0;PnlVect&#x00A0;*x,&#x00A0;PnlMat&#x00A0;*dfx,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;(*FDF)&#x00A0;(const&#x00A0;PnlVect&#x00A0;*x,&#x00A0;PnlVect&#x00A0;*fx,&#x00A0;PnlMat&#x00A0;*dfx,&#x00A0;void&#x00A0;*params);
&#x00A0;&#x00A0;void&#x00A0;*params;
}&#x00A0;PnlRnFuncRmDFunc&#x00A0;;
#define&#x00A0;PNL_EVAL_RNFUNCRM_DF(Fstruct,&#x00A0;x,&#x00A0;dfx)&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(*((Fstruct)-&#x003E;Dfunction))(x,&#x00A0;dfx,&#x00A0;(Fstruct)-&#x003E;params)
#define&#x00A0;PNL_EVAL_RNFUNCRM_FDF(Fstruct,&#x00A0;x,&#x00A0;fx,&#x00A0;dfx)&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;(*((Fstruct)-&#x003E;F))(x,&#x00A0;fx,&#x00A0;dfx,&#x00A0;(Fstruct)-&#x003E;params)
#define&#x00A0;PNL_EVAL_RNFUNCRM_F_DF(Fstruct,&#x00A0;x,&#x00A0;fx,&#x00A0;dfx)&#x00A0;&#x00A0;&#x00A0;&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(&#x00A0;(Fstruct)-&#x003E;FDF&#x00A0;!=&#x00A0;NULL&#x00A0;)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;PNL_EVAL_RNFUNCRN_FDF&#x00A0;(Fstruct,&#x00A0;x,&#x00A0;fx,&#x00A0;dfx);&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;else&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;PNL_EVAL_RNFUNCRN&#x00A0;(Fstruct,&#x00A0;x,&#x00A0;fx);&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;PNL_EVAL_RNFUNCRN_DF&#x00A0;(Fstruct,&#x00A0;x,&#x00A0;dfx);&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;\
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
/*
&#x00A0;*&#x00A0;Synonymous&#x00A0;of&#x00A0;PnlRnFuncRmDFunc&#x00A0;for&#x00A0;f:R^n&#x00A0;--&#x003E;&#x00A0;R^m
&#x00A0;*
typedef&#x00A0;PnlRnFuncRmDFunc&#x00A0;PnlRnFuncRnDFunc;
#define&#x00A0;PNL_EVAL_RNFUNCRN_DF&#x00A0;PNL_EVAL_RNFUNCRM_DF
#define&#x00A0;PNL_EVAL_RNFUNCRN_FDF&#x00A0;PNL_EVAL_RNFUNCRM_FDF
#define&#x00A0;PNL_EVAL_RNFUNCRN_F_DF&#x00A0;PNL_EVAL_RNFUNCRM_F_DF
</pre>
<!--l. 121--><p class="nopar" >
</p><!--l. 123--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">13.2   </span> <a 
 id="x1-13100013.2"></a>Functions</h4>
<!--l. 125--><p class="noindent" >To use the following functions, you should include <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_root.h</span></span></span>.
                                                                                    

                                                                                    
</p>
<!--l. 127--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-132000"></a><span 
class="ec-lmbx-10x-x-109">Real valued functions of a real argument</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 129--><p class="noindent" ><a 
 id="dx1-132001"></a><a 
 id="x1-132000doc"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_root_brent</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>F, double x1, double x2, double <span 
class="ts1-lmr10-x-x-109">*</span>tol</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Find the root of <span class='var'>F</span> between <span class='var'>x1</span> and <span class='var'>x2</span> with an accuracy of order <span class='var'>tol</span>. On
     exit <span class='var'>tol</span> is an upper bound of the error.
     </p></li>
     <li class="itemize">
     <!--l. 135--><p class="noindent" ><a 
 id="dx1-132002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_root_newton_bisection</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFuncDFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Func, double x_min, double
     x_max, double tol, int N_Max, double <span 
class="ts1-lmr10-x-x-109">*</span>res</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Find the root of <span class='var'>F</span> between <span class='var'>x1</span> and <span class='var'>x2</span> with an accuracy of order <span class='var'>tol</span>
     and a maximum of <span class='var'>N_max</span> iterations. On exit, the root is stored in <span class='var'>res</span>. Note that the
     function <span class='var'>Func</span> must also compute the first derivative of the function. This function relies
     on combining Newton&#8217;s approach with a bisection technique.
     </p></li>
     <li class="itemize">
     <!--l. 144--><p class="noindent" ><a 
 id="dx1-132003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_root_newton</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFuncDFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Func, double x0, double x_eps, double fx_eps, int
     max_iter, double <span 
class="ts1-lmr10-x-x-109">*</span>res</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Find the root of <span class='var'>f</span> starting from <span class='var'>x0</span> using Newton&#8217;s method with descent
     direction given by the inverse of the derivative, ie. <span 
class="lmmi-10x-x-109">d</span><sub><span 
class="lmmi-8">k</span></sub> <span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">&#x2215;f</span><span 
class="lmsy-10x-x-109">&#x2032;</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">)</span>. Armijo&#8217;s line search is
     used to make sure <span class='var'>|f|</span> decreases along the iterations. <span 
class="lmmi-10x-x-109">&#x03B1;</span><sub><span 
class="lmmi-8">k</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">max</span><span 
class="lmsy-10x-x-109">{</span><span 
class="lmmi-10x-x-109">&#x03B3;</span><sup><span 
class="lmmi-8">j</span></sup> <span 
class="rm-lmr-10x-x-109">; </span><span 
class="lmmi-10x-x-109">j </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmsy-10x-x-109">} </span>such
     that
     </p><table 
class="align-star">
                        <tr><td 
class="align-odd"><span 
class="lmsy-10x-x-109">|</span><span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">k</span></sub> <span 
class="rm-lmr-10x-x-109">+ </span><span 
class="lmmi-10x-x-109">&#x03B1;</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">d</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmsy-10x-x-109">|</span></td>                        <td 
class="align-even"><span 
class="lmsy-10x-x-109">&#x2264;|</span><span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmsy-10x-x-109">|</span><span 
class="rm-lmr-10x-x-109">(1 </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">&#x03C9;&#x03B1;</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">.</span></td>                        <td 
class="align-label"></td>                        <td 
class="align-label"></td></tr></table>
     <!--l. 154--><p class="noindent" >In this implementation, <span 
class="lmmi-10x-x-109">&#x03C9; </span><span 
class="rm-lmr-10x-x-109">= 10</span><sup><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">4</span></sup> and <span 
class="lmmi-10x-x-109">&#x03B3; </span><span 
class="rm-lmr-10x-x-109">= 1</span><span 
class="lmmi-10x-x-109">&#x2215;</span><span 
class="rm-lmr-10x-x-109">2</span>. The algorithm stops when one of the three
     following conditions is met: </p>
                                                                                    

                                                                                    
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 158--><p class="noindent" >the maximum number of iterations <span class='var'>max_iter</span> is reached;
          </p></li>
          <li class="itemize">
          <!--l. 159--><p class="noindent" >the last improvement over <span class='var'>x</span> is smaller that <span class='var'>x * x_eps</span>;
          </p></li>
          <li class="itemize">
          <!--l. 160--><p class="noindent" >at the current position <span class='var'>|f(x)| &#x003C; fx_eps</span></p></li></ul>
     <!--l. 162--><p class="noindent" >On exit, the root is stored in <span class='var'>res</span>.
     </p></li>
     <li class="itemize">
     <!--l. 163--><p class="noindent" ><a 
 id="dx1-132004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_root_bisection</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Func, double xmin, double xmax, double epsrel, double
     espabs, int N_max, double <span 
class="ts1-lmr10-x-x-109">*</span>res</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Find the root of <span class='var'>F</span> between <span class='var'>x1</span> and <span class='var'>x2</span> with the accuracy <span class='var'>|x2 - x1| &#x003C; epsrel * x1
     + epsabs</span> or with the maximum number of iterations <span class='var'>N_max</span>. On exit, <span class='var'>res = (x2 + x1) /
     2</span>.</p></li></ul>
<!--l. 171--><p class="noindent" ><span class="paragraphHead"><a 
 id="x1-133000"></a><span 
class="ec-lmbx-10x-x-109">Vector valued functions with several arguments</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 174--><p class="noindent" ><a 
 id="dx1-133001"></a><a 
 id="x1-133000doc"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_multiroot_newton</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncRnDFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>func, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x0, double
     x_eps, double fx_eps, int max_iter, int verbose, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>res</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Find the root of <span class='var'>func</span> starting from <span class='var'>x0</span> using Newton&#8217;s method with descent
     direction given by the inverse of the Jacobian matrix, ie. <span 
class="lmmi-10x-x-109">d</span><sub><span 
class="lmmi-8">k</span></sub> <span 
class="rm-lmr-10x-x-109">= (</span><span 
class="lmsy-10x-x-109">&#x2207;</span><span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">))</span><sup><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sup><span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">)</span>. Armijo&#8217;s line
     search is used to make sure <span class='var'>|f|</span> decreases along the iterations. <span 
class="lmmi-10x-x-109">&#x03B1;</span><sub><span 
class="lmmi-8">k</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">max</span><span 
class="lmsy-10x-x-109">{</span><span 
class="lmmi-10x-x-109">&#x03B3;</span><sup><span 
class="lmmi-8">j</span></sup> <span 
class="rm-lmr-10x-x-109">; </span><span 
class="lmmi-10x-x-109">j </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmsy-10x-x-109">} </span>such
     that
                                                                                    

                                                                                    
     </p><table 
class="align-star">
                        <tr><td 
class="align-odd"><span 
class="lmsy-10x-x-109">|</span><span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">k</span></sub> <span 
class="rm-lmr-10x-x-109">+ </span><span 
class="lmmi-10x-x-109">&#x03B1;</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="lmmi-10x-x-109">d</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmsy-10x-x-109">|</span></td>                        <td 
class="align-even"><span 
class="lmsy-10x-x-109">&#x2264;|</span><span 
class="lmmi-10x-x-109">f</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmsy-10x-x-109">|</span><span 
class="rm-lmr-10x-x-109">(1 </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">&#x03C9;&#x03B1;</span><sub><span 
class="lmmi-8">k</span></sub><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">.</span></td>                        <td 
class="align-label"></td>                        <td 
class="align-label"></td></tr></table>
     <!--l. 185--><p class="noindent" >In this implementation, <span 
class="lmmi-10x-x-109">&#x03C9; </span><span 
class="rm-lmr-10x-x-109">= 10</span><sup><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">4</span></sup> and <span 
class="lmmi-10x-x-109">&#x03B3; </span><span 
class="rm-lmr-10x-x-109">= 1</span><span 
class="lmmi-10x-x-109">&#x2215;</span><span 
class="rm-lmr-10x-x-109">2</span>. The algorithm stops when one of the three
     following conditions is met: </p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 188--><p class="noindent" >the maximum number of iterations <span class='var'>max_iter</span> is reached;
          </p></li>
          <li class="itemize">
          <!--l. 189--><p class="noindent" >the norm of the last improvement over <span class='var'>x</span> is smaller that <span class='var'>|x| * x_eps</span>;
          </p></li>
          <li class="itemize">
          <!--l. 190--><p class="noindent" >at the current position <span class='var'>|f(x)| &#x003C; fx_eps</span></p></li></ul>
     <!--l. 192--><p class="noindent" >On exit, the root is stored in <span class='var'>res</span>. Note that the function <span class='var'>F</span> must also compute the first
     derivative of the function. When defining <span class='var'>Func</span>, you must either define <span class='var'>Func-&#x003E;F</span> and
     <span class='var'>Func-&#x003E;DF</span> or <span class='var'>Func-&#x003E;FDF</span>.</p></li></ul>
<!--l. 197--><p class="noindent" >We provide two wrappers for calling minpack routines. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 199--><p class="noindent" ><a 
 id="dx1-133002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_root_fsolve</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncRnDFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>f, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>fx, double xtol, int
     maxfev, int <span 
class="ts1-lmr10-x-x-109">*</span>nfev, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>scale, int error_msg</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the root of a function <span 
class="lmmi-10x-x-109">f </span><span 
class="rm-lmr-10x-x-109">: </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup><span 
class="lmmi-10x-x-109">&#x27FC;</span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup>. Note that the number of
     components of <span class='var'>f</span> must be equal to the number of variates of <span class='var'>f</span>. This function returns <span class='var'>OK</span> or
     <span class='var'>FAIL</span> if something went wrong.<br 
class="newline" />   <span class='description'>Parameters&#x00A0;</span></p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 210--><p class="noindent" ><span class='var'>f</span> is a pointer to a <a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncRnDFunc</span></a> used to store the function whose root is to
          be found. <span class='var'>f</span> can also store the Jacobian of the function, if not it is computed using
          finite differences (see the file     <a 
href="examples/minpack_test.c" class="url" ><span 
class="ec-lmtt-10x-x-109">examples/minpack_test.c</span></a> for a usage example).
          <span class='var'>f-&#x003E;FDF</span> can be NULL because it is not used in this function.
          </p></li>
          <li class="itemize">
          <!--l. 216--><p class="noindent" ><span class='var'>x</span> contains on input the starting point of the search and an approximation of the
          root of <span class='var'>f</span> on output,
                                                                                    

                                                                                    
          </p></li>
          <li class="itemize">
          <!--l. 218--><p class="noindent" ><span class='var'>xtol</span> is the precision required on <span class='var'>x</span>, if set to 0 a default value is used.
          </p></li>
          <li class="itemize">
          <!--l. 220--><p class="noindent" ><span class='var'>maxfev</span>  is  the  maximum  number  of  evaluations  of  the  function  <span class='var'>f</span>  before  the
          algorithm returns, if set to 0, a coherent number is determined internally.
          </p></li>
          <li class="itemize">
          <!--l. 223--><p class="noindent" ><span class='var'>nfev</span> contains on output the number of evaluations of <span class='var'>f</span> during the algorithm,
          </p></li>
          <li class="itemize">
          <!--l. 225--><p class="noindent" ><span class='var'>scale</span> is a vector used to rescale <span class='var'>x</span> in a way that each coordinate of the solution is
          approximately of order 1 after rescaling. If on input <span class='var'>scale=NULL</span>, a scaling vector
          is computed internally by the algorithm.
          </p></li>
          <li class="itemize">
          <!--l. 229--><p class="noindent" ><span class='var'>error_msg</span> is a boolean (<span class='var'>TRUE</span> or <span class='var'>FALSE</span>) to specify if an error message should
          be printed when the algorithm stops before having converged.
          </p></li>
          <li class="itemize">
          <!--l. 232--><p class="noindent" >On output, <span class='var'>fx</span> contains <span class='var'>f(x)</span>.</p></li></ul>
     </li>
     <li class="itemize">
     <!--l. 235--><p class="noindent" ><a 
 id="dx1-133003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_root_fsolve_lsq</span></span>&#x00A0;(<span class='args'><a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncRmDFunc</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>f, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int m, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>fx,
     double xtol, double ftol, double gtol, int maxfev, int <span 
class="ts1-lmr10-x-x-109">*</span>nfev, <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>scale, int
     error_msg</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the root of <span 
class="lmmi-10x-x-109">x </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="lmmi-8">n</span></sup><span 
class="lmmi-10x-x-109">&#x27FC;</span><span 
class="lmex-10">&#x2211;</span>
   <sub><span 
class="lmmi-8">i</span><span 
class="rm-lmr-8">=1</span></sub><sup><span 
class="lmmi-8">m</span></sup><span 
class="lmmi-10x-x-109">f</span><sub><span 
class="lmmi-8">i</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span><sup><span 
class="rm-lmr-8">2</span></sup>, note that there is no reason why <span class='var'>m</span>
     should be equal to <span class='var'>n</span>.<br 
class="newline" />   <span class='description'>Parameters&#x00A0;</span></p>
          <ul class="itemize2">
          <li class="itemize">
          <!--l. 244--><p class="noindent" ><span class='var'>f</span> is a pointer to a <a 
href="#x1-13000013.1"><span class='struct'>PnlRnFuncRmDFunc</span></a> used to store the function whose root is to
          be found. <span class='var'>f</span> can also store the Jacobian of the function, if not it is computed using
          finite differences (see the file     <a 
href="examples/minpack_test.c" class="url" ><span 
class="ec-lmtt-10x-x-109">examples/minpack_test.c</span></a> for a usage example).
          <span class='var'>f-&#x003E;FDF</span> can be NULL because it is not used in this function.
          </p></li>
          <li class="itemize">
          <!--l. 250--><p class="noindent" ><span class='var'>x</span> contains on input the starting point of the search and an approximation of the
          root of <span class='var'>f</span> on output,
          </p></li>
          <li class="itemize">
          <!--l. 253--><p class="noindent" ><span class='var'>m</span> is the number of components of <span class='var'>f</span>,
                                                                                    

                                                                                    
          </p></li>
          <li class="itemize">
          <!--l. 254--><p class="noindent" ><span class='var'>xtol</span> is the precision required on <span class='var'>x</span>, if set to 0 a default value is used.
          </p></li>
          <li class="itemize">
          <!--l. 256--><p class="noindent" ><span class='var'>ftol</span> is the precision required on <span class='var'>f</span>, if set to 0 a default value is used.
          </p></li>
          <li class="itemize">
          <!--l. 258--><p class="noindent" ><span class='var'>gtol</span> is the precision required on the Jacobian of <span class='var'>f</span>, if set to 0 a default value is used.
          </p></li>
          <li class="itemize">
          <!--l. 260--><p class="noindent" ><span class='var'>maxfev</span>  is  the  maximum  number  of  evaluations  of  the  function  <span class='var'>f</span>  before  the
          algorithm returns, if set to 0, a coherent number is determined internally.
          </p></li>
          <li class="itemize">
          <!--l. 263--><p class="noindent" ><span class='var'>nfev</span> contains on output the number of evaluations of <span class='var'>f</span> during the algorithm,
          </p></li>
          <li class="itemize">
          <!--l. 265--><p class="noindent" ><span class='var'>scale</span> is a vector used to rescale <span class='var'>x</span> in a way that each coordinate of the solution is
          approximately of order 1 after rescaling. If on input <span class='var'>scale=NULL</span>, a scaling vector
          is computed internally by the algorithm.
          </p></li>
          <li class="itemize">
          <!--l. 269--><p class="noindent" ><span class='var'>error_msg</span> is a boolean (<span class='var'>TRUE</span> or <span class='var'>FALSE</span>) to specify if an error message should
          be printed when the algorithm stops before having converged.
          </p></li>
          <li class="itemize">
          <!--l. 272--><p class="noindent" >On output, <span class='var'>fx</span> contains <span class='var'>f(x)</span>.</p></li></ul>
     </li></ul>
<!--l. 2--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">14   </span> <a 
 id="x1-13400014"></a>Special functions</h3>
<!--l. 4--><p class="noindent" >The special function approximations are defined in the header <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_specfun.h</span></span></span>.<br 
class="newline" />
</p><!--l. 6--><p class="noindent" >Most of these functions rely on the <span 
class="ec-lmri-10x-x-109">Cephes </span>library which uses its own error mechanism which can be
activated or deactivated using the two following functions </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 10--><p class="noindent" ><a 
 id="dx1-134001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_deactivate_mtherr</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Deactivate Cephes error mechanism
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 12--><p class="noindent" ><a 
 id="dx1-134002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_activate_mtherr</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Activate Cephes error mechanism</p></li></ul>
<!--l. 17--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">14.1   </span> <a 
 id="x1-13500014.1"></a>Real Bessel functions</h4>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 20--><p class="noindent" ><a 
 id="dx1-135001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_i</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Modified Bessel function of the first kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 23--><p class="noindent" ><a 
 id="dx1-135002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_i_scaled</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Modified Bessel function of the first kind of order <span class='var'>v</span> divided by <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmsy8-">|</span><span 
class="lmmi-8">x</span><span 
class="lmsy8-">|</span></sup>.
     </p></li>
     <li class="itemize">
     <!--l. 26--><p class="noindent" ><a 
 id="dx1-135003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_rati</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Ratio of modified Bessel functions of the first kind : <span 
class="lmmi-10x-x-109">I</span><sub><span 
class="lmmi-8">v</span><span 
class="rm-lmr-8">+1</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">&#x2215;I</span><sub><span 
class="lmmi-8">v</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 29--><p class="noindent" ><a 
 id="dx1-135004"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_j</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Bessel function of the first kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 32--><p class="noindent" ><a 
 id="dx1-135005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_j_scaled</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Bessel  function  of  the  first  kind  of  order  <span class='var'>v</span>.  Same  function  as
     <a 
href="#x1-13500014.1">pnl_bessel_j</a>.
     </p></li>
     <li class="itemize">
     <!--l. 35--><p class="noindent" ><a 
 id="dx1-135006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_y</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Modified Bessel function of the second kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 38--><p class="noindent" ><a 
 id="dx1-135007"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_y_scaled</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Modified Bessel function of the second kind of order <span class='var'>v</span>. Same function as
     <a 
href="#x1-13500014.1">pnl_bessel_y</a>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 41--><p class="noindent" ><a 
 id="dx1-135008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_k</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Bessel function of the third kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 44--><p class="noindent" ><a 
 id="dx1-135009"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_k_scaled</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Bessel function of the third kind of order <span class='var'>v</span> multiplied by <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmmi-8">x</span></sup>.
     </p></li>
     <li class="itemize">
     <!--l. 47--><p class="noindent" ><a 
 id="dx1-135010"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_h1</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Hankel function of the first kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 50--><p class="noindent" ><a 
 id="dx1-135011"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_h1_scaled</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Hankel function of the first kind of order <span class='var'>v</span> and divided by <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmmi-8">Ix</span></sup>.
     </p></li>
     <li class="itemize">
     <!--l. 53--><p class="noindent" ><a 
 id="dx1-135012"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_h2</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Hankel function of the second kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 56--><p class="noindent" ><a 
 id="dx1-135013"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bessel_h2_scaled</span></span>&#x00A0;(<span class='args'>double v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Hankel function of the second kind of order <span class='var'>v</span> and multiplied by <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmmi-8">Ix</span></sup>.</p></li></ul>
<!--l. 61--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">14.2   </span> <a 
 id="x1-13600014.2"></a>Complex Bessel functions</h4>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 64--><p class="noindent" ><a 
 id="dx1-136001"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_i</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Modified Bessel function of the first kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 67--><p class="noindent" ><a 
 id="dx1-136002"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_i_scaled</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Modified Bessel function of the first kind of order <span class='var'>v</span> divided by
     <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmsy8-">|</span><span 
class="lmmi-8">Creal</span><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">z</span><span 
class="rm-lmr-8">)</span><span 
class="lmsy8-">|</span></sup>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 70--><p class="noindent" ><a 
 id="dx1-136003"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_rati</span></span>&#x00A0;(<span class='args'>double v, dcomplex x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Ratio  of  complex  modified  Bessel  functions  of  the  first  kind  :
     <span 
class="lmmi-10x-x-109">I</span><sub><span 
class="lmmi-8">v</span><span 
class="rm-lmr-8">+1</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">&#x2215;I</span><sub><span 
class="lmmi-8">v</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 73--><p class="noindent" ><a 
 id="dx1-136004"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_j</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Bessel function of the first kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 76--><p class="noindent" ><a 
 id="dx1-136005"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_j_scaled</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Bessel function of the first kind of order <span class='var'>v</span> divided by <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmsy8-">|</span><span 
class="lmmi-8">Cimag</span><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">z</span><span 
class="rm-lmr-8">)</span><span 
class="lmsy8-">|</span></sup>.
     </p></li>
     <li class="itemize">
     <!--l. 79--><p class="noindent" ><a 
 id="dx1-136006"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_y</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Modified Bessel function of the second kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 82--><p class="noindent" ><a 
 id="dx1-136007"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_y_scaled</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Modified Bessel function of the second kind of order <span class='var'>v</span> divided
     by <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmsy8-">|</span><span 
class="lmmi-8">Cimag</span><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">z</span><span 
class="rm-lmr-8">)</span><span 
class="lmsy8-">|</span></sup>.
     </p></li>
     <li class="itemize">
     <!--l. 85--><p class="noindent" ><a 
 id="dx1-136008"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_k</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Bessel function of the third kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 88--><p class="noindent" ><a 
 id="dx1-136009"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_k_scaled</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Bessel function of the third kind of order <span class='var'>v</span> multiplied by <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmmi-8">z</span></sup>.
     </p></li>
     <li class="itemize">
     <!--l. 91--><p class="noindent" ><a 
 id="dx1-136010"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_h1</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Hankel function of the first kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 94--><p class="noindent" ><a 
 id="dx1-136011"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_h1_scaled</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Hankel function of the first kind of order <span class='var'>v</span> and divided by <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmmi-8">Iz</span></sup>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 97--><p class="noindent" ><a 
 id="dx1-136012"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_h2</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Hankel function of the second kind of order <span class='var'>v</span>.
     </p></li>
     <li class="itemize">
     <!--l. 100--><p class="noindent" ><a 
 id="dx1-136013"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_complex_bessel_h2_scaled</span></span>&#x00A0;(<span class='args'>double v, dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Complex Hankel function of the second kind of order <span class='var'>v</span> and multiplied
     by <span 
class="lmmi-10x-x-109">e</span><sup><span 
class="lmmi-8">Iz</span></sup>.</p></li></ul>
<!--l. 105--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">14.3   </span> <a 
 id="x1-13700014.3"></a>Error functions</h4>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 108--><p class="noindent" ><a 
 id="dx1-137001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_erf</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the error function <img 
src="pnl-manual43x.png" alt="2
&#x03C0;"  class="frac" align="middle" /> <span 
class="lmex-10">&#x222B;</span>
   <sub><span 
class="rm-lmr-8">0</span></sub><sup><span 
class="lmmi-8">x</span></sup> <span 
class="rm-lmr-10x-x-109">e</span><span 
class="lmsy8-">-</span><span 
class="lmmi-8">t</span><sup><span 
class="rm-lmr-6">2</span></sup>
         <span 
class="lmmi-10x-x-109">dt</span>.
     </p></li>
     <li class="itemize">
     <!--l. 110--><p class="noindent" ><a 
 id="dx1-137002"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_complex_erf</span></span>&#x00A0;(<span class='args'>dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-13700014.3">pnl_sf_erf</a> for complex arguments.
     </p></li>
     <li class="itemize">
     <!--l. 112--><p class="noindent" ><a 
 id="dx1-137003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_erfc</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the complementary error function <span class='var'>1. - erf(x)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 114--><p class="noindent" ><a 
 id="dx1-137004"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_complex_erfc</span></span>&#x00A0;(<span class='args'>dcomplex x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-13700014.3">pnl_sf_erfc</a> for complex arguments.
     </p></li>
     <li class="itemize">
     <!--l. 116--><p class="noindent" ><a 
 id="dx1-137005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_erfcx</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  scaled  complementary  error  function  of  x,  defined  by
     <span 
class="rm-lmr-10x-x-109">e</span><span 
class="lmmi-8">x</span><sup><span 
class="rm-lmr-6">2</span></sup>
        erfc<span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 119--><p class="noindent" ><a 
 id="dx1-137006"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_complex_erfcx</span></span>&#x00A0;(<span class='args'>dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-13700014.3">pnl_sf_erfcx</a> for complex arguments. Note that <span class='var'>erfcx(-i x) =
     w(x)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 122--><p class="noindent" ><a 
 id="dx1-137007"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_w</span></span>&#x00A0;(<span class='args'>dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span 
class="rm-lmr-10x-x-109">e</span><span 
class="lmsy8-">-</span><span 
class="lmmi-8">z</span><sup><span 
class="rm-lmr-6">2</span></sup>
           erfc<span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmsy-10x-x-109">-</span><span 
class="lmmi-10x-x-109">iz</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 124--><p class="noindent" ><a 
 id="dx1-137008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_w_im</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span 
class="rm-lmr-10x-x-109">2</span>Dawson<span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">&#x2215;</span><img 
src="pnl-manual44x.png" alt="&#x221A; &#x03C0;-"  class="sqrt"  />
     </p></li>
     <li class="itemize">
     <!--l. 126--><p class="noindent" ><a 
 id="dx1-137009"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_erfi</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>-i erf(i z)</span>
     </p></li>
     <li class="itemize">
     <!--l. 128--><p class="noindent" ><a 
 id="dx1-137010"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_complex_erfi</span></span>&#x00A0;(<span class='args'>dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-13700014.3">pnl_sf_erfi</a> for complex arguments.
     </p></li>
     <li class="itemize">
     <!--l. 130--><p class="noindent" ><a 
 id="dx1-137011"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_dawson</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <img 
src="pnl-manual45x.png" alt="&#x221A; --
  &#x03C0;"  class="sqrt"  /><span 
class="lmmi-10x-x-109">&#x2215;</span><span 
class="rm-lmr-10x-x-109">2</span> <span 
class="rm-lmr-10x-x-109">e</span><span 
class="lmsy8-">-</span><span 
class="lmmi-8">x</span><sup><span 
class="rm-lmr-6">2</span></sup>
           erfi<span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 132--><p class="noindent" ><a 
 id="dx1-137012"></a> <span class='ret'>dcomplex</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_complex_dawson</span></span>&#x00A0;(<span class='args'>dcomplex z</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x1-13700014.3">pnl_sf_dawson</a> for complex arguments.
     </p></li>
     <li class="itemize">
     <!--l. 134--><p class="noindent" ><a 
 id="dx1-137013"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_log_erf</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span 
class="rm-lmr-10x-x-109">log</span> <a 
href="#x1-13700014.3">pnl_sf_erf</a><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>
     </p></li>
     <li class="itemize">
     <!--l. 136--><p class="noindent" ><a 
 id="dx1-137014"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_log_erfc</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span 
class="rm-lmr-10x-x-109">log</span> <a 
href="#x1-13700014.3">pnl_sf_erfc</a><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span></p></li></ul>
                                                                                    

                                                                                    
<!--l. 140--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">14.4   </span> <a 
 id="x1-13800014.4"></a>Gamma functions</h4>
<!--l. 142--><p class="noindent" >For <span 
class="lmmi-10x-x-109">x &#x003E; </span><span 
class="rm-lmr-10x-x-109">0</span>, the Gamma Function is defined by
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual46x.png" alt="       &#x222B;
&#x0393; (x ) =  &#x221E; e-u ux-1du.
        0
" class="math-display"  /></div>
</td></tr></table>
<!--l. 145--><p class="nopar" >
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 148--><p class="noindent" ><a 
 id="dx1-138001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_fact</span></span>&#x00A0;(<span class='args'>int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Computes factorial of <span class='var'>n</span> <span 
class="rm-lmr-10x-x-109">&#x0393;(</span><span 
class="lmmi-10x-x-109">n </span><span 
class="rm-lmr-10x-x-109">+ 1)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 150--><p class="noindent" ><a 
 id="dx1-138002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_gamma</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Computes <span 
class="rm-lmr-10x-x-109">&#x0393;(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">,x </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span>
     </p></li>
     <li class="itemize">
     <!--l. 152--><p class="noindent" ><a 
 id="dx1-138003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_log_gamma</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Computes <span 
class="rm-lmr-10x-x-109">log</span><span 
class="rm-lmr-10x-x-109">(&#x0393;(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">))</span><span 
class="lmmi-10x-x-109">,x </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span>
     </p></li>
     <li class="itemize">
     <!--l. 154--><p class="noindent" ><a 
 id="dx1-138004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_log_gamma_sgn</span></span>&#x00A0;(<span class='args'>double x, double <span 
class="ts1-lmr10-x-x-109">*</span>y, int <span 
class="ts1-lmr10-x-x-109">*</span>sgn</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Computes <span 
class="lmmi-10x-x-109">y </span><span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">log</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmsy-10x-x-109">|</span><span 
class="rm-lmr-10x-x-109">&#x0393;(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmsy-10x-x-109">|</span><span 
class="rm-lmr-10x-x-109">) </span>for <span class='var'>x &#x003E; 0</span> <span class='var'>sgn</span> contains the sign of <span 
class="rm-lmr-10x-x-109">&#x0393;(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">) </span>(-1 or
     +1).
     </p></li>
     <li class="itemize">
     <!--l. 157--><p class="noindent" ><a 
 id="dx1-138005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_choose</span></span>&#x00A0;(<span class='args'>int n, int k</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Computes the binomial coefficient <img 
src="pnl-manual47x.png" alt="()
nk"  /> <span 
class="rm-lmr-10x-x-109">=</span> <img 
src="pnl-manual48x.png" alt="k!(nn-!k)!"  class="frac" align="middle" /> for <span 
class="rm-lmr-10x-x-109">0 </span><span 
class="lmsy-10x-x-109">&#x2264; </span><span 
class="lmmi-10x-x-109">k </span><span 
class="lmsy-10x-x-109">&#x2264; </span><span 
class="lmmi-10x-x-109">n </span>in double
     precision.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 162--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">14.5   </span> <a 
 id="x1-13900014.5"></a>Digamma function</h4>
<!--l. 164--><p class="noindent" >For <span 
class="lmmi-10x-x-109">x &#x003E; </span><span 
class="rm-lmr-10x-x-109">0</span>, the digamma function <span 
class="lmmi-10x-x-109">&#x03C8; </span>is defined as the logarithmic derivative of the Gamma function
<span 
class="rm-lmr-10x-x-109">&#x0393;</span>
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual49x.png" alt="       -d-          &#x0393;-&#x2032;(x)
&#x03C8; (x ) = dx log&#x0393; (x ) = &#x0393; (x).
" class="math-display"  /></div>
</td></tr></table>
<!--l. 168--><p class="nopar" >The function <span 
class="lmmi-10x-x-109">&#x03C8; </span>admits the following integral representation
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual50x.png" alt="       &#x222B; &#x221E; ( - u     -xu  )
&#x03C8;(x) =       e---  -e-----  .
        0     u    1- e- u
" class="math-display"  /></div>
</td></tr></table>
<!--l. 173--><p class="nopar" >
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 176--><p class="noindent" ><a 
 id="dx1-139001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_psi</span></span>&#x00A0;(<span class='args'>double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span 
class="lmmi-10x-x-109">&#x03C8;</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 180--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">14.6   </span> <a 
 id="x1-14000014.6"></a>Incomplete Gamma functions</h4>
<!--l. 182--><p class="noindent" >For <span 
class="lmmi-10x-x-109">a </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D; </span>and <span 
class="lmmi-10x-x-109">x &#x003E; </span><span 
class="rm-lmr-10x-x-109">0</span>, the Incomplete Gamma Function is defined by
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual51x.png" alt="         &#x222B;
           &#x221E;  -u  a-1
&#x0393; (a,x ) = x  e   u   du.
" class="math-display"  /></div>
</td></tr></table>
<!--l. 185--><p class="nopar" >A relation similar to the one existing for the standard Gamma function holds
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual52x.png" alt="          - xa-e-x+-&#x0393; (a-+-1,x)
&#x0393; (a,x) =          a         .
" class="math-display"  /></div>
</td></tr></table>
<!--l. 189--><p class="nopar" >
                                                                                    

                                                                                    
</p><table 
class="align-star">
                 <tr><td 
class="align-odd"><span 
class="rm-lmr-10x-x-109">&#x0393;(</span><span 
class="lmmi-10x-x-109">a</span><span 
class="rm-lmr-10x-x-109">)</span></td>                   <td 
class="align-even"> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="lmex-10">&#x222B;</span>
  <sub><span 
class="rm-lmr-8">0</span></sub><sup><span 
class="lmsy8-">&#x221E;</span></sup><span 
class="lmmi-10x-x-109">u</span><sup><span 
class="lmmi-8">a</span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sup> <span 
class="rm-lmr-10x-x-109">e</span><span 
class="lmsy8-">-</span><span 
class="lmmi-8">u</span> <span 
class="lmmi-10x-x-109">du</span></td>                                            <td 
class="align-label"></td>                 <td 
class="align-label">
                 </td></tr><tr><td 
class="align-odd"><span 
class="lmmi-10x-x-109">P</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a,x</span><span 
class="rm-lmr-10x-x-109">)</span></td>                 <td 
class="align-even"> <span 
class="rm-lmr-10x-x-109">=</span> <img 
src="pnl-manual53x.png" alt="&#x0393; (a) - &#x0393; (a,x)
-------------
    &#x0393; (a)"  class="frac" align="middle" /> <span 
class="rm-lmr-10x-x-109">=</span> <img 
src="pnl-manual54x.png" alt="  1
-----
&#x0393; (a)"  class="frac" align="middle" /><span 
class="lmex-10">&#x222B;</span>
     <sub><span 
class="rm-lmr-8">0</span></sub><sup><span 
class="lmmi-8">x</span></sup><span 
class="lmmi-10x-x-109">u</span><sup><span 
class="lmmi-8">a</span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sup> <span 
class="rm-lmr-10x-x-109">e</span><span 
class="lmsy8-">-</span><span 
class="lmmi-8">u</span> <span 
class="lmmi-10x-x-109">du</span></td>                        <td 
class="align-label"></td>                 <td 
class="align-label">
                 </td></tr><tr><td 
class="align-odd"><span 
class="lmmi-10x-x-109">Q</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a,x</span><span 
class="rm-lmr-10x-x-109">)</span></td>                 <td 
class="align-even"> <span 
class="rm-lmr-10x-x-109">= 1 </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">P</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a,x</span><span 
class="rm-lmr-10x-x-109">) =</span> <img 
src="pnl-manual55x.png" alt="&#x0393; (a,x)
 &#x0393; (a)"  class="frac" align="middle" /> <span 
class="rm-lmr-10x-x-109">=</span> <img 
src="pnl-manual56x.png" alt="--1--
&#x0393; (a )"  class="frac" align="middle" /><span 
class="lmex-10">&#x222B;</span>
     <sub><span 
class="lmmi-8">x</span></sub><sup><span 
class="lmsy8-">&#x221E;</span></sup><span 
class="rm-lmr-10x-x-109">e</span><span 
class="lmsy8-">-</span><span 
class="lmmi-8">u</span> <span 
class="lmmi-10x-x-109">u</span><sup><span 
class="lmmi-8">a</span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sup><span 
class="lmmi-10x-x-109">du.</span></td>                 <td 
class="align-label"></td>                 <td 
class="align-label"></td></tr></table>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 199--><p class="noindent" ><a 
 id="dx1-140001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_gamma_inc</span></span>&#x00A0;(<span class='args'>double a, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Computes <span 
class="rm-lmr-10x-x-109">&#x0393;(</span><span 
class="lmmi-10x-x-109">a,x</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">,   a </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span><span 
class="lmmi-10x-x-109">,x </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span>
     </p></li>
     <li class="itemize">
     <!--l. 201--><p class="noindent" ><a 
 id="dx1-140002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_gamma_inc_P</span></span>&#x00A0;(<span class='args'>double a, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Computes <span 
class="lmmi-10x-x-109">P</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a,x</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">,   a &#x003E; </span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,x </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span>
     </p></li>
     <li class="itemize">
     <!--l. 203--><p class="noindent" ><a 
 id="dx1-140003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_gamma_inc_Q</span></span>&#x00A0;(<span class='args'>double a, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Computes <span 
class="lmmi-10x-x-109">Q</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a,x</span><span 
class="rm-lmr-10x-x-109">)</span><span 
class="lmmi-10x-x-109">,   a &#x003E; </span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,x </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span></p></li></ul>
<!--l. 207--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">14.7   </span> <a 
 id="x1-14100014.7"></a>Exponential integrals</h4>
<!--l. 208--><p class="noindent" >For <span 
class="lmmi-10x-x-109">x &#x003E; </span><span 
class="rm-lmr-10x-x-109">0 </span>and <span 
class="lmmi-10x-x-109">n </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x2115;</span>, the function <span 
class="lmmi-10x-x-109">E</span><sub><span 
class="lmmi-8">n</span></sub> is defined by
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual57x.png" alt="        &#x222B; &#x221E;
En (x ) =    e-xu u-ndu
         1
" class="math-display"  /></div>
</td></tr></table>
<!--l. 211--><p class="nopar" >
</p><!--l. 213--><p class="noindent" >This function is linked to the Incomplete Gamma function by
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual58x.png" alt="        &#x222B; &#x221E;                             &#x222B; &#x221E;
En (x) =    e- xu(xu )-nxn-1d(xu) = xn-1     e-tt-ndt = xn-1&#x0393; (1 - n,x) ,
         x                               x
" class="math-display"  /></div>
</td></tr></table>
<!--l. 218--><p class="nopar" >from which we can deduce
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual59x.png" alt="nE    (x) = e- x- xE  (x ).
   n+1             n
" class="math-display"  /></div>
</td></tr></table>
<!--l. 222--><p class="nopar" >For <span 
class="lmmi-10x-x-109">n &#x003E; </span><span 
class="rm-lmr-10x-x-109">1</span>, the series expansion is given by
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual60x.png" alt="                      [                                         ]
         n-1             --1--   --x--   ---x2---   --x3----
En(x) = x   &#x0393; (1 - n)+  -1 - n + 2 - n - 2(3-  n) + 6(4 - n) - ... .
" class="math-display"  /></div>
</td></tr></table>
<!--l. 228--><p class="nopar" >The asymptotic behaviour is given by
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual61x.png" alt="            [                     ]
E  (x ) = e--x 1 - n-+ n(n-+-1) + ....
 n       x       x      x2
" class="math-display"  /></div>
</td></tr></table>
<!--l. 232--><p class="nopar" >The special case <span 
class="lmmi-10x-x-109">n </span><span 
class="rm-lmr-10x-x-109">= 1 </span>gives
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual62x.png" alt="        &#x222B; &#x221E;  e- u
E1 (x) =     ---du,   |Arg (x )| &#x2265; &#x03C0;.
         x    u
" class="math-display"  /></div>
</td></tr></table>
<!--l. 236--><p class="nopar" >For any complex number <span 
class="lmmi-10x-x-109">x </span>with positive real part, this can be written
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual63x.png" alt="         &#x222B;    -ux
E  (x) =  &#x221E;  e---du,   &#x211C;(x) &#x2265; 0.
  1       1   u
" class="math-display"  /></div>
</td></tr></table>
<!--l. 240--><p class="nopar" >By integrating the Taylor expansion of <span 
class="rm-lmr-10x-x-109">e</span><span 
class="lmsy8-">-</span><span 
class="lmmi-8">t</span> <span 
class="lmmi-10x-x-109">&#x2215;t</span>, and extracting the logarithmic singularity, we can
derive the following series representation for <span 
class="lmmi-10x-x-109">E</span><sub><span 
class="rm-lmr-8">1</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span>,
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual64x.png" alt="                   &#x2211;&#x221E; (- 1)kxk
E1(x) = - &#x03B3; - lnx -   --k-k!--    |Arg(x)| &#x003C; &#x03C0;.
                   k=1
" class="math-display"  /></div>
</td></tr></table>
<!--l. 247--><p class="nopar" >The function <span 
class="lmmi-10x-x-109">E</span><sub><span 
class="rm-lmr-8">1</span></sub> is linked to the exponential integral <span 
class="lmmi-10x-x-109">Ei</span>
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual65x.png" alt="        &#x222B;              &#x222B;
Ei (x) =  x  eudu =  -  &#x221E;  e-u-du  &#x2200;x &#x2044;= 0.
         - &#x221E; u          -x  u
" class="math-display"  /></div>
</td></tr></table>
<!--l. 252--><p class="nopar" >The above definition can be used for positive values of <span 
class="lmmi-10x-x-109">x</span>, but the integral has to be
understood in terms of its Cauchy principal value, due to the singularity of the integrand at
zero.
</p>
<table 
class="equation-star"><tr><td>
                                                                                    

                                                                                    
<div class="math-display" >
<img 
src="pnl-manual66x.png" alt="Ei(- x) = - E (x ),  &#x211C; (x) &#x2265; 0.
             1
" class="math-display"  /></div>
</td></tr></table>
<!--l. 258--><p class="nopar" >We deduce,
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual67x.png" alt="                  &#x2211;&#x221E; -xk-
Ei (x ) = &#x03B3; + lnx +   k k!,  x &#x003E; 0.
                  k=1
" class="math-display"  /></div>
</td></tr></table>
<!--l. 262--><p class="nopar" >For <span 
class="lmmi-10x-x-109">x </span><span 
class="lmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x211D;</span>
</p>
<table 
class="equation-star"><tr><td>
<div class="math-display" >
<img 
src="pnl-manual68x.png" alt="         {
            - Ei (- x) - i&#x03C0; x &#x003C; 0,
&#x0393; (0,x) =   - Ei (- x) x &#x003E; 0.
" class="math-display"  /></div>
</td></tr></table>
<!--l. 270--><p class="nopar" >
</p>
     <ul class="itemize1">
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 273--><p class="noindent" ><a 
 id="dx1-141001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_expint_En</span></span>&#x00A0;(<span class='args'>int n, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Computes <span class='var'>E_n(x)</span> for <span 
class="lmmi-10x-x-109">n </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,x </span><span 
class="lmsy-10x-x-109">&#x2265; </span><span 
class="rm-lmr-10x-x-109">0</span>, or <span 
class="lmmi-10x-x-109">x &#x003E; </span><span 
class="rm-lmr-10x-x-109">0 </span>when <span 
class="lmmi-10x-x-109">n </span><span 
class="rm-lmr-10x-x-109">= 0 </span>or <span 
class="rm-lmr-10x-x-109">1</span>.</p></li></ul>
<!--l. 278--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">14.8   </span> <a 
 id="x1-14200014.8"></a>Hypergeometric functions</h4>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 281--><p class="noindent" ><a 
 id="dx1-142001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_hyperg_2F1</span></span>&#x00A0;(<span class='args'>double a, double b, double c, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the Gauss hypergeometric function <span class='var'>2F1(a,b,c,x)</span> for <span class='var'>|x| &#x003C; 1</span> and
     for <span class='var'>x &#x003C; -1</span> when <span class='var'>b,a,c,(b-a),(c-a),(c-b)</span> are not integers
     </p></li>
     <li class="itemize">
     <!--l. 286--><p class="noindent" ><a 
 id="dx1-142002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_hyperg_1F1</span></span>&#x00A0;(<span class='args'>double a, double b, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the hypergeometric function <span class='var'>1F1(a,b,x)</span>
     </p></li>
     <li class="itemize">
     <!--l. 288--><p class="noindent" ><a 
 id="dx1-142003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_hyperg_2F0</span></span>&#x00A0;(<span class='args'>double a, double b, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  hypergeometric  function  <span class='var'>2F0(a,b,x)</span>  for  <span class='var'>x&#x003C;0</span>  using  the
     relation <span 
class="rm-lmr-10x-x-109">2</span><span 
class="lmmi-10x-x-109">F</span><span 
class="rm-lmr-10x-x-109">0(</span><span 
class="lmmi-10x-x-109">a,b,x</span><span 
class="rm-lmr-10x-x-109">) = (</span><span 
class="lmsy-10x-x-109">-</span><span 
class="lmmi-10x-x-109">x</span><span 
class="rm-lmr-10x-x-109">)</span><sup><span 
class="lmsy8-">-</span><span 
class="lmmi-8">a</span></sup><span 
class="lmmi-10x-x-109">U</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">a,</span><span 
class="rm-lmr-10x-x-109">1 + </span><span 
class="lmmi-10x-x-109">a </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">b,</span><span 
class="lmsy-10x-x-109">-</span><img 
src="pnl-manual69x.png" alt="1
x"  class="frac" align="middle" /><span 
class="rm-lmr-10x-x-109">)</span>.
     </p></li>
     <li class="itemize">
     <!--l. 291--><p class="noindent" ><a 
 id="dx1-142004"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_hyperg_0F1</span></span>&#x00A0;(<span class='args'>double c, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the hypergeometric function <span class='var'>0F1(c,x)</span>
     </p></li>
     <li class="itemize">
     <!--l. 293--><p class="noindent" ><a 
 id="dx1-142005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sf_hyperg_U</span></span>&#x00A0;(<span class='args'>double a, double b, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the confluent hypergeometric function <span class='var'>U(a,b,x)</span> with <span class='var'>x &#x003E; 0</span></p></li></ul>
<!--l. 1--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">15   </span> <a 
 id="x1-14300015"></a>Some bindings</h3>
<!--l. 5--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">15.1   </span> <a 
 id="x1-14400015.1"></a>MPI bindings</h4>
                                                                                    

                                                                                    
<!--l. 6--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">15.1.1   </span> <a 
 id="x1-14500015.1.1"></a>Overview</h5>
<!--l. 8--><p class="noindent" >We provide some bindings for the MPI library to natively handle <span 
class="ec-lmri-10x-x-109">PnlObjects</span>.
</p><!--l. 10--><p class="noindent" >The functionnalities described in this chapter are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_mpi.h</span></span></span>.
</p><!--l. 12--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">15.1.2   </span> <a 
 id="x1-14600015.1.2"></a>Functions</h5>
<!--l. 14--><p class="noindent" >All the following functions return an error code as an integer value. This returned value should be
tested against <span class='var'>MPI_SUCCESS</span> to check that no error occurred.
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 19--><p class="noindent" ><a 
 id="dx1-146001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_pack_size</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Obj, MPI_Comm comm, int
     <span 
class="ts1-lmr10-x-x-109">*</span>size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute in <span class='var'>size</span> the amount of space needed to pack <span class='var'>Obj</span>.
     </p></li>
     <li class="itemize">
     <!--l. 22--><p class="noindent" ><a 
 id="dx1-146002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_pack</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Obj, void <span 
class="ts1-lmr10-x-x-109">*</span>buf, int bufsize, int <span 
class="ts1-lmr10-x-x-109">*</span>pos,
     MPI_Comm comm</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Pack <span class='var'>Obj</span> into <span class='var'>buf</span> which must be at least of length <span class='var'>size</span>. <span class='var'>size</span> must be at
     least equal to the value returned by <a 
href="#x1-14600015.1.2">pnl_object_mpi_pack_size</a>.
     </p></li>
     <li class="itemize">
     <!--l. 27--><p class="noindent" ><a 
 id="dx1-146003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_unpack</span></span>&#x00A0;(<span class='args'><a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Obj, void <span 
class="ts1-lmr10-x-x-109">*</span>buf, int bufsize, int <span 
class="ts1-lmr10-x-x-109">*</span>pos,
     MPI_Comm comm</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Unpack the content of <span class='var'>buf</span> starting at position <span class='var'>pos</span> (unless several objects
     have been packed contiguously, <span class='var'><span 
class="ts1-lmr10-x-x-109">*</span>pos</span> should be equal to <span class='var'>0</span>). <span class='var'>buf</span> is a contigous memery
     area of length <span class='var'>bufsize</span> (note that the size is counted in bytes). <span class='var'>pos</span> is incremented and
     is on output the first location in the input buffer after the locations occupied by the
     message that was unpacked. <span class='var'>pos</span> is properly set for a future call to <span 
class="ec-lmri-10x-x-109">MPI_Unpack </span>if any.
     </p></li>
     <li class="itemize">
     <!--l. 38--><p class="noindent" ><a 
 id="dx1-146004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_send</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Obj, int dest, int tag, MPI_Comm
     comm</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Perform a standard-mode blocking send of <span class='var'>Obj</span>. The object is sent to the
     process with rank <span class='var'>dest</span>.
     </p></li>
     <li class="itemize">
                                                                                    

                                                                                    
     <!--l. 43--><p class="noindent" ><a 
 id="dx1-146005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_ssend</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Obj, int dest, int tag, MPI_Comm
     comm</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Perform a standard-mode synchronous blocking send of <span class='var'>Obj</span>. The object
     is sent to the process with rank <span class='var'>dest</span>.
     </p></li>
     <li class="itemize">
     <!--l. 48--><p class="noindent" ><a 
 id="dx1-146006"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_recv</span></span>&#x00A0;(<span class='args'><a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Obj, int src, int tag, MPI_Comm comm,
     MPI_Status <span 
class="ts1-lmr10-x-x-109">*</span>status</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Perform a standard-mode blocking receive of <span class='var'>Obj</span>. The object is sent to
     the process with rank <span class='var'>dest</span>. Note that <span class='var'>Obj</span> should be an already allocated object and
     that its type should match the true type of the object to be received. <span class='var'>src</span> is the rank of
     the process who sent the object.
     </p></li>
     <li class="itemize">
     <!--l. 57--><p class="noindent" ><a 
 id="dx1-146007"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_bcast</span></span>&#x00A0;(<span class='args'><a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Obj, int root, MPI_Comm comm</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Broadcast the object <span class='var'>Obj</span> from the process with rank <span class='var'>root</span> to all other
     processes of the group <span class='var'>comm</span>.
     </p></li>
     <li class="itemize">
     <!--l. 62--><p class="noindent" ><a 
 id="dx1-146008"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_reduce</span></span>&#x00A0;(<span class='args'><a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Sendbuf, <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Recvbuf, MPI_Op
     op, int root, MPI_Comm comm</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Perform the reduction described by <span class='var'>op</span> on the objects <span class='var'>Sendbuf</span> and stores
     the result into <span class='var'>Recvbuf</span>. Note that <span class='var'>Recvbuf</span> and <span class='var'>Sendbuf</span> must be of the same type. The
     argument <span class='var'>root</span> is the index of the root process and <span class='var'>comm</span> is a communicator. Not all
     reductions are implemented for all types. Here is the list of compatible reductions
</p>
     <div class="center" 
>
<!--l. 71--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-13" class="tabular" 
 
><colgroup id="TBL-13-1g"><col 
id="TBL-13-1" /></colgroup><colgroup id="TBL-13-2g"><col 
id="TBL-13-2" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-13-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-13-1-1"  
class="td10">MPI_SUM                         </td><td  style="white-space:nowrap; text-align:left;" id="TBL-13-1-2"  
class="td01">PnlVect, PnlVectInt, PnlVectComplex,   </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-13-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-13-2-1"  
class="td10">                          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-13-2-2"  
class="td01">PnlMat, PnlMatInt, PnlMatComplex     </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-13-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-13-3-1"  
class="td10">MPI_PROD, MPI_MAX,      </td><td  style="white-space:nowrap; text-align:left;" id="TBL-13-3-2"  
class="td01">PnlVect, PnlVectInt, PnlMat, PnlMatInt</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-13-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-13-4-1"  
class="td10">MPI_MIN                           </td><td  style="white-space:nowrap; text-align:left;" id="TBL-13-4-2"  
class="td01">                                  </td>
</tr></table>                                                                                    </div></div>
     </li></ul>
<!--l. 83--><p class="noindent" >For more expect users, we provide the following nonblocking functions. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 85--><p class="noindent" ><a 
 id="dx1-146009"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_isend</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-120002.1"><span class='struct'>PnlObject</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Obj, int dest, int tag, MPI_Comm
     comm, MPI_Request <span 
class="ts1-lmr10-x-x-109">*</span>request</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Start a standard-mode, nonblocking send of object <span class='var'>Obj</span> to the process
     with rank <span class='var'>dest</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 91--><p class="noindent" ><a 
 id="dx1-146010"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_mpi_irecv</span></span>&#x00A0;(<span class='args'>void <span 
class="ts1-lmr10-x-x-109">**</span>buf, int <span 
class="ts1-lmr10-x-x-109">*</span>size, int src, int tag, MPI_Comm
     comm, int <span 
class="ts1-lmr10-x-x-109">*</span>flag, MPI_Request <span 
class="ts1-lmr10-x-x-109">*</span>request</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Start  a  standard-mode,  nonblocking  receive  of  object  <span class='var'>Obj</span>  from  the
     process with rank <span class='var'>root</span>. On output <span class='var'>flag</span> equals to <span class='var'>TRUE</span> if the object can be received
     and <span class='var'>FALSE</span> otherwise (this is the same as for <span 
class="ec-lmri-10x-x-109">MPI_Iprobe</span>).</p></li></ul>
<!--l. 100--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">15.2   </span> <a 
 id="x1-14700015.2"></a>The save/load interface</h4>
<!--l. 102--><p class="noindent" >The interface is only accessible when the MPI bindings are compiled since it is based on the
Packing/Unpacking facilities of MPI.
</p><!--l. 105--><p class="noindent" >The functionnalities described in this chapter are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_mpi.h</span></span></span>. </p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 107--><p class="noindent" ><a 
 id="dx1-147001"></a> <span class='ret'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">**</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_create_from_file</span></span>&#x00A0;(<span class='args'>char <span 
class="ts1-lmr10-x-x-109">*</span>str, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Load <span class='var'>n</span> rng from the file of name <span class='var'>str</span> and returns an array of <span class='var'>n</span> <a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> .
     </p></li>
     <li class="itemize">
     <!--l. 111--><p class="noindent" ><a 
 id="dx1-147002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_rng_save_to_file</span></span>&#x00A0;(<span class='args'><a 
href="#x1-1020006.1"><span class='struct'>PnlRng</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>rngtab, int n, char <span 
class="ts1-lmr10-x-x-109">*</span>str</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Save <span class='var'>n</span> rng stored in <span class='var'>rngtab</span> into the file of name <span class='var'>str</span>.
     </p></li>
     <li class="itemize">
     <!--l. 115--><p class="noindent" ><a 
 id="dx1-147003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_save</span></span>&#x00A0;(<span class='args'>PnlObject <span 
class="ts1-lmr10-x-x-109">*</span>O, FILE *stream</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Save the object <span class='var'>O</span> into the stream <span class='var'>stream</span>. <span class='var'>stream</span> is typically created by
     calling fopen with <span class='var'>mode="wb"</span>. This function can be called several times to save several
     objects in the same stream.
     </p></li>
     <li class="itemize">
     <!--l. 119--><p class="noindent" ><a 
 id="dx1-147004"></a> <span class='ret'>PnlObject<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_load</span></span>&#x00A0;(<span class='args'>FILE *stream</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Load an object from the stream <span class='var'>stream</span>. <span class='var'>stream</span> is typically created by
     calling fopen with <span class='var'>mode="rb"</span>. This function can be called several times to load several
     objects from the same stream. If <span class='var'>stream</span> was empty or it did not contain any PnlObjects,
     the function returns <span class='var'>NULL</span>.
     </p></li>
     <li class="itemize">
     <!--l. 124--><p class="noindent" ><a 
 id="dx1-147005"></a> <span class='ret'>PnlList<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_object_load_into_list</span></span>&#x00A0;(<span class='args'>FILE *stream</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Load as many objects as possible from the stream <span class='var'>stream</span> and stores
     them into a <a 
href="#x1-130002.2"><span class='struct'>PnlList</span></a> . <span class='var'>stream</span> is typically created by calling fopen with <span class='var'>mode="rb"</span>. If
     <span class='var'>stream</span> was empty or it did not contain any PnlObjects, the function returns <span class='var'>NULL</span>.</p></li></ul>
                                                                                    

                                                                                    
<!--l. 2--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">16   </span> <a 
 id="x1-14800016"></a>Financial functions</h3>
<!--l. 4--><p class="noindent" >The financial functions are defined in the header <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_finance.h</span></span></span>.<br 
class="newline" />
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 8--><p class="noindent" ><a 
 id="dx1-148001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cf_call_bs</span></span>&#x00A0;(<span class='args'>double s, double k, double T, double r, double divid, double
     sigma, double <span 
class="ts1-lmr10-x-x-109">*</span>ptprice, double <span 
class="ts1-lmr10-x-x-109">*</span>ptdelta</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the price and delta of a call option <span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">s</span></span><span 
class="lmsy-10x-x-109">-</span><span class='var'><span 
class="lmmi-10x-x-109">k</span></span><span 
class="rm-lmr-10x-x-109">)</span><sub><span 
class="rm-lmr-8">+</span></sub> in the Black-Scholes
     model with volatility <span class='var'>sigma</span>, instantaneous interest rate <span class='var'>r</span>, maturity <span class='var'>T</span> and dividend rate
     <span class='var'>divid</span>. The parameters <span class='var'>ptprice</span> and <span class='var'>ptdelta</span> are respectively set to the price and delta on
     output.
     </p></li>
     <li class="itemize">
     <!--l. 17--><p class="noindent" ><a 
 id="dx1-148002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cf_put_bs</span></span>&#x00A0;(<span class='args'>double s, double k, double T, double r, double divid, double
     sigma, double <span 
class="ts1-lmr10-x-x-109">*</span>ptprice, double <span 
class="ts1-lmr10-x-x-109">*</span>ptdelta</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the price and delta of a put option <span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">k</span></span><span 
class="lmsy-10x-x-109">-</span><span class='var'><span 
class="lmmi-10x-x-109">s</span></span><span 
class="rm-lmr-10x-x-109">)</span><sub><span 
class="rm-lmr-8">+</span></sub> in the Black-Scholes
     model with volatility <span class='var'>sigma</span>, instantaneous interest rate <span class='var'>r</span>, maturity <span class='var'>T</span> and dividend rate
     <span class='var'>divid</span>. The parameters <span class='var'>ptprice</span> and <span class='var'>ptdelta</span> are respectively set to the price and delta on
     output.
</p>
     </li></ul>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 30--><p class="noindent" ><a 
 id="dx1-148003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bs_call</span></span>&#x00A0;(<span class='args'>double s, double k, double T, double r, double divid, double
     sigma</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  price  of  a  call  option  with  spot  <span class='var'>s</span>  and  strike  <span class='var'>k</span>  in  the
     Black-Scholes model with volatility <span class='var'>sigma</span>, instantaneous interest rate <span class='var'>r</span>, maturity <span class='var'>T</span> and
     dividend rate <span class='var'>divid</span>.
     </p></li>
     <li class="itemize">
     <!--l. 38--><p class="noindent" ><a 
 id="dx1-148004"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bs_put</span></span>&#x00A0;(<span class='args'>double s, double k, double T, double r, double divid, double
     sigma</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  price  a  put  option  with  spot  <span class='var'>s</span>  and  strike  <span class='var'>k</span>  in  the
     Black-Scholes model with volatility <span class='var'>sigma</span>, instantaneous interest rate <span class='var'>r</span>, maturity <span class='var'>T</span> and
     dividend rate <span class='var'>divid</span>.
                                                                                    

                                                                                    
     </p></li>
     <li class="itemize">
     <!--l. 46--><p class="noindent" ><a 
 id="dx1-148005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bs_call_put</span></span>&#x00A0;(<span class='args'>int iscall, double s, double k, double T, double r, double
     divid, double sigma</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the price of a put option if <span class='var'>iscall=0</span> or a call option if <span class='var'>iscall=1</span>
     with spot <span class='var'>s</span> and strike <span class='var'>k</span> in the Black-Scholes model with volatility <span class='var'>sigma</span>, instantaneous
     interest rate <span class='var'>r</span>, maturity <span class='var'>T</span> and dividend rate <span class='var'>divid</span>.
     </p></li>
     <li class="itemize">
     <!--l. 54--><p class="noindent" ><a 
 id="dx1-148006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bs_vega</span></span>&#x00A0;(<span class='args'>double s, double k, double T, double r, double divid, double
     sigma</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the vega of a put or call option with spot <span class='var'>s</span> and strike <span class='var'>k</span> in the
     Black-Scholes model with volatility <span class='var'>sigma</span>, instantaneous interest rate <span class='var'>r</span>, maturity <span class='var'>T</span> and
     dividend rate <span class='var'>divid</span>.
     </p></li>
     <li class="itemize">
     <!--l. 62--><p class="noindent" ><a 
 id="dx1-148007"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bs_gamma</span></span>&#x00A0;(<span class='args'>double s, double k, double T, double r, double divid, double
     sigma</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the gamma of a put or call option with spot <span class='var'>s</span> and strike <span class='var'>k</span> in
     the Black-Scholes model with volatility <span class='var'>sigma</span>, instantaneous interest rate <span class='var'>r</span>, maturity
     <span class='var'>T</span> and dividend rate <span class='var'>divid</span>.</p></li></ul>
<!--l. 70--><p class="noindent" >Practitioners do not speak in terms of option prices, but rather compare prices in terms of their
implied Black &amp; Scholes volatilities. So this parameter is very useful in practice. Here, we propose
two functions to compute <span 
class="lmmi-10x-x-109">&#x03C3;</span><sub><span 
class="lmmi-8">impl</span></sub> : the first one is for one up-let, maturity, strike, option price. the
second function is for a list of strikes and maturities, a matrix of prices (with strikes varying
row-wise).
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 79--><p class="noindent" ><a 
 id="dx1-148008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bs_implicit_vol</span></span>&#x00A0;(<span class='args'>int is_call, double Price, double s, double K, double
     T, double r, double divid, int *error</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the implied volatility of a put option if <span class='var'>iscall=0</span> or a call option
     if <span class='var'>iscall=1</span> with spot <span class='var'>s</span> and strike <span class='var'>K</span> in the Black-Scholes model with instantaneous
     interest  rate  <span class='var'>r</span>,  maturity  <span class='var'>T</span>  and  dividend  rate  <span class='var'>divid</span>.  On  output  <span class='var'>error</span>  is  <span class='var'>OK</span>  if  the
     computation of the implied volatility succeeded or <span class='var'>FAIL</span> if it failed.
     </p></li>
     <li class="itemize">
     <!--l. 89--><p class="noindent" ><a 
 id="dx1-148009"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bs_matrix_implicit_vol</span></span>&#x00A0;(<span class='args'>const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMatInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>iscall, const <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Price,
     double s, double r, double divid, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>K, const <a 
href="#x1-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T, <a 
href="#x1-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Vol</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  matrix  of  implied  volatilities  <span class='var'>Vol(i,j)</span>  of  a  put  option
     if  <span class='var'>iscall(i,j)=0</span>  or  a  call  option  if  <span class='var'>iscall(i,j)=1</span>  with  spot  <span class='var'>s</span>  and  strike  <span class='var'>K(j)</span>  in  the
                                                                                    

                                                                                    
     Black-Scholes model with instantaneous interest rate <span class='var'>r</span>, maturity <span class='var'>T(j)</span> and dividend rate
     <span class='var'>divid</span>. This function returns the number of failures, when everything succeeded it returns
     <span 
class="rm-lmr-10x-x-109">0</span>.</p></li></ul>
                                                                                    

                                                                                    
<a 
 id="Q1-1-153"></a>
<h3 class="likesectionHead"><a 
 id="x1-149000"></a>Index</h3>
<div class="theindex"><span class="index-item">ABS, <a 
href="pnl-manual.html#dx1-18006" >1</a> <br /></span>
<p class="theindex">
<span class="index-item">C_op_amcb, <a 
href="pnl-manual.html#dx1-26046" >2</a> <br /></span>
<span class="index-item">C_op_amib, <a 
href="pnl-manual.html#dx1-26047" >3</a> <br /></span>
<span class="index-item">C_op_apcb, <a 
href="pnl-manual.html#dx1-26045" >4</a> <br /></span>
<span class="index-item">C_op_apib, <a 
href="pnl-manual.html#dx1-26044" >5</a> <br /></span>
<span class="index-item">C_op_damb, <a 
href="pnl-manual.html#dx1-26049" >6</a> <br /></span>
<span class="index-item">C_op_damcb, <a 
href="pnl-manual.html#dx1-26053" >7</a> <br /></span>
<span class="index-item">C_op_damib, <a 
href="pnl-manual.html#dx1-26051" >8</a> <br /></span>
<span class="index-item">C_op_dapb, <a 
href="pnl-manual.html#dx1-26048" >9</a> <br /></span>
<span class="index-item">C_op_dapcb, <a 
href="pnl-manual.html#dx1-26052" >10</a> <br /></span>
<span class="index-item">C_op_dapib, <a 
href="pnl-manual.html#dx1-26050" >11</a> <br /></span>
<span class="index-item">C_op_idamb, <a 
href="pnl-manual.html#dx1-26055" >12</a> <br /></span>
<span class="index-item">C_op_idamcb, <a 
href="pnl-manual.html#dx1-26057" >13</a> <br /></span>
<span class="index-item">C_op_idapb, <a 
href="pnl-manual.html#dx1-26054" >14</a> <br /></span>
<span class="index-item">C_op_idapcb, <a 
href="pnl-manual.html#dx1-26056" >15</a> <br /></span>
<span class="index-item">Cabs, <a 
href="pnl-manual.html#dx1-26022" >16</a> <br /></span>
<span class="index-item">Cadd, <a 
href="pnl-manual.html#dx1-26006" >17</a> <br /></span>
<span class="index-item">Carg, <a 
href="pnl-manual.html#dx1-26037" >18</a> <br /></span>
<span class="index-item">Ccos, <a 
href="pnl-manual.html#dx1-26029" >19</a> <br /></span>
<span class="index-item">Ccosh, <a 
href="pnl-manual.html#dx1-26033" >20</a> <br /></span>
<span class="index-item">Ccotan, <a 
href="pnl-manual.html#dx1-26032" >21</a> <br /></span>
<span class="index-item">Ccotanh, <a 
href="pnl-manual.html#dx1-26036" >22</a> <br /></span>
<span class="index-item">Cdiv, <a 
href="pnl-manual.html#dx1-26020" >23</a> <br /></span>
<span class="index-item">Cexp, <a 
href="pnl-manual.html#dx1-26025" >24</a> <br /></span>
<span class="index-item">CI, <a 
href="pnl-manual.html#dx1-25003" >25</a> <br /></span>
<span class="index-item">CIexp, <a 
href="pnl-manual.html#dx1-26026" >26</a> <br /></span>
<span class="index-item">Cimag, <a 
href="pnl-manual.html#dx1-26005" >27</a> <br /></span>
<span class="index-item">Cinv, <a 
href="pnl-manual.html#dx1-26019" >28</a> <br /></span>
<span class="index-item">Clgamma, <a 
href="pnl-manual.html#dx1-26039" >29</a> <br /></span>
<span class="index-item">Clog, <a 
href="pnl-manual.html#dx1-26024" >30</a> <br /></span>
<span class="index-item">Cminus, <a 
href="pnl-manual.html#dx1-26012" >31</a> <br /></span>
<span class="index-item">CMPLX, <a 
href="pnl-manual.html#dx1-26001" >32</a> <br /></span>
<span class="index-item">Cmul, <a 
href="pnl-manual.html#dx1-26013" >33</a> <br /></span>
<span class="index-item">Complex, <a 
href="pnl-manual.html#dx1-26002" >34</a> <br /></span>
<span class="index-item">Complex_polar, <a 
href="pnl-manual.html#dx1-26003" >35</a> <br /></span>
<span class="index-item">CONE, <a 
href="pnl-manual.html#dx1-25002" >36</a> <br /></span>
<span class="index-item">Conj, <a 
href="pnl-manual.html#dx1-26018" >37</a> <br /></span>
<span class="index-item">Cpow, <a 
href="pnl-manual.html#dx1-26027" >38</a> <br /></span>
<span class="index-item">Cpow_real, <a 
href="pnl-manual.html#dx1-26028" >39</a> <br /></span>
<span class="index-item">Cprintf, <a 
href="pnl-manual.html#dx1-26040" >40</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">CRadd, <a 
href="pnl-manual.html#dx1-26007" >41</a> <br /></span>
<span class="index-item">CRdiv, <a 
href="pnl-manual.html#dx1-26016" >42</a> <br /></span>
<span class="index-item">Creal, <a 
href="pnl-manual.html#dx1-26004" >43</a> <br /></span>
<span class="index-item">CRmul, <a 
href="pnl-manual.html#dx1-26015" >44</a> <br /></span>
<span class="index-item">CRsub, <a 
href="pnl-manual.html#dx1-26010" >45</a> <br /></span>
<span class="index-item">Csin, <a 
href="pnl-manual.html#dx1-26030" >46</a> <br /></span>
<span class="index-item">Csinh, <a 
href="pnl-manual.html#dx1-26034" >47</a> <br /></span>
<span class="index-item">Csqr_norm, <a 
href="pnl-manual.html#dx1-26021" >48</a> <br /></span>
<span class="index-item">Csqrt, <a 
href="pnl-manual.html#dx1-26023" >49</a> <br /></span>
<span class="index-item">Csub, <a 
href="pnl-manual.html#dx1-26009" >50</a> <br /></span>
<span class="index-item">Ctan, <a 
href="pnl-manual.html#dx1-26031" >51</a> <br /></span>
<span class="index-item">Ctanh, <a 
href="pnl-manual.html#dx1-26035" >52</a> <br /></span>
<span class="index-item">Ctgamma, <a 
href="pnl-manual.html#dx1-26038" >53</a> <br /></span>
<span class="index-item">CUB, <a 
href="pnl-manual.html#dx1-18009" >54</a> <br /></span>
<span class="index-item">CZERO, <a 
href="pnl-manual.html#dx1-25001" >55</a> <br /></span>
</p><p class="theindex">
<span class="index-item">DBL_EPSILON, <a 
href="pnl-manual.html#dx1-17023" >56</a> <br /></span>
<span class="index-item">DBL_MAX, <a 
href="pnl-manual.html#dx1-17021" >57</a> <br /></span>
<span class="index-item">DOUBLE_MAX, <a 
href="pnl-manual.html#dx1-17022" >58</a> <br /></span>
</p><p class="theindex">
<span class="index-item">GET, <a 
href="pnl-manual.html#dx1-34001" >59</a> <br /></span>
<span class="index-item">GET_COMPLEX, <a 
href="pnl-manual.html#dx1-34003" >60</a> <br /></span>
<span class="index-item">GET_IMAG, <a 
href="pnl-manual.html#dx1-42012" >61</a> <br /></span>
<span class="index-item">GET_INT, <a 
href="pnl-manual.html#dx1-34002" >62</a> <br /></span>
<span class="index-item">GET_REAL, <a 
href="pnl-manual.html#dx1-42011" >63</a> <br /></span>
</p><p class="theindex">
<span class="index-item">INT_MAX, <a 
href="pnl-manual.html#dx1-17019" >64</a> <br /></span>
</p><p class="theindex">
<span class="index-item">LET, <a 
href="pnl-manual.html#dx1-34004" >65</a> <br /></span>
<span class="index-item">LET_COMPLEX, <a 
href="pnl-manual.html#dx1-34006" >66</a> <br /></span>
<span class="index-item">LET_IMAG, <a 
href="pnl-manual.html#dx1-42014" >67</a> <br /></span>
<span class="index-item">LET_INT, <a 
href="pnl-manual.html#dx1-34005" >68</a> <br /></span>
<span class="index-item">LET_REAL, <a 
href="pnl-manual.html#dx1-42013" >69</a> <br /></span>
</p><p class="theindex">
<span class="index-item">M_1_PI, <a 
href="pnl-manual.html#dx1-17010" >70</a> <br /></span>
<span class="index-item">M_1_SQRT2PI, <a 
href="pnl-manual.html#dx1-17017" >71</a> <br /></span>
<span class="index-item">M_2_PI, <a 
href="pnl-manual.html#dx1-17011" >72</a> <br /></span>
<span class="index-item">M_2_SQRTPI, <a 
href="pnl-manual.html#dx1-17012" >73</a> <br /></span>
<span class="index-item">M_2PI, <a 
href="pnl-manual.html#dx1-17007" >74</a> <br /></span>
<span class="index-item">M_E, <a 
href="pnl-manual.html#dx1-17001" >75</a> <br /></span>
<span class="index-item">M_EULER, <a 
href="pnl-manual.html#dx1-17015" >76</a> <br /></span>
<span class="index-item">M_LN10, <a 
href="pnl-manual.html#dx1-17005" >77</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">M_LN2, <a 
href="pnl-manual.html#dx1-17004" >78</a> <br /></span>
<span class="index-item">M_LOG10E, <a 
href="pnl-manual.html#dx1-17003" >79</a> <br /></span>
<span class="index-item">M_LOG2E, <a 
href="pnl-manual.html#dx1-17002" >80</a> <br /></span>
<span class="index-item">M_PI, <a 
href="pnl-manual.html#dx1-17006" >81</a> <br /></span>
<span class="index-item">M_PI_2, <a 
href="pnl-manual.html#dx1-17008" >82</a> <br /></span>
<span class="index-item">M_PI_4, <a 
href="pnl-manual.html#dx1-17009" >83</a> <br /></span>
<span class="index-item">M_SQRT1_2, <a 
href="pnl-manual.html#dx1-17016" >84</a> <br /></span>
<span class="index-item">M_SQRT2, <a 
href="pnl-manual.html#dx1-17014" >85</a> <br /></span>
<span class="index-item">M_SQRT2_PI, <a 
href="pnl-manual.html#dx1-17018" >86</a> <br /></span>
<span class="index-item">M_SQRT2PI, <a 
href="pnl-manual.html#dx1-17013" >87</a> <br /></span>
<span class="index-item">MAX, <a 
href="pnl-manual.html#dx1-18005" >88</a> <br /></span>
<span class="index-item">MAX_INT, <a 
href="pnl-manual.html#dx1-17020" >89</a> <br /></span>
<span class="index-item">MGET, <a 
href="pnl-manual.html#dx1-50001" >90</a> <br /></span>
<span class="index-item">MGET_COMPLEX, <a 
href="pnl-manual.html#dx1-50003" >91</a> <br /></span>
<span class="index-item">MGET_INT, <a 
href="pnl-manual.html#dx1-50002" >92</a> <br /></span>
<span class="index-item">MIN, <a 
href="pnl-manual.html#dx1-18004" >93</a> <br /></span>
<span class="index-item">MLET, <a 
href="pnl-manual.html#dx1-50004" >94</a> <br /></span>
<span class="index-item">MLET_COMPLEX, <a 
href="pnl-manual.html#dx1-50006" >95</a> <br /></span>
<span class="index-item">MLET_INT, <a 
href="pnl-manual.html#dx1-50005" >96</a> <br /></span>
</p><p class="theindex">
<span class="index-item">NAN, <a 
href="pnl-manual.html#dx1-17027" >97</a> <br /></span>
</p><p class="theindex">
<span class="index-item">pnl_acosh, <a 
href="pnl-manual.html#dx1-21004" >98</a> <br /></span>
<span class="index-item">pnl_activate_mtherr, <a 
href="pnl-manual.html#dx1-134002" >99</a> <br /></span>
<span class="index-item">PNL_ALTERNATE, <a 
href="pnl-manual.html#dx1-18003" >100</a> <br /></span>
<span class="index-item">pnl_array_clone, <a 
href="pnl-manual.html#dx1-14005" >101</a> <br /></span>
<span class="index-item">pnl_array_copy, <a 
href="pnl-manual.html#dx1-14004" >102</a> <br /></span>
<span class="index-item">pnl_array_create, <a 
href="pnl-manual.html#dx1-14003" >103</a> <br /></span>
<span class="index-item">pnl_array_free, <a 
href="pnl-manual.html#dx1-14006" >104</a> <br /></span>
<span class="index-item">pnl_array_get, <a 
href="pnl-manual.html#dx1-14008" >105</a> <br /></span>
<span class="index-item">pnl_array_new, <a 
href="pnl-manual.html#dx1-14002" >106</a> <br /></span>
<span class="index-item">pnl_array_print, <a 
href="pnl-manual.html#dx1-14010" >107</a> <br /></span>
<span class="index-item">pnl_array_resize, <a 
href="pnl-manual.html#dx1-14007" >108</a> <br /></span>
<span class="index-item">pnl_array_set, <a 
href="pnl-manual.html#dx1-14009" >109</a> <br /></span>
<span class="index-item">pnl_asinh, <a 
href="pnl-manual.html#dx1-21005" >110</a> <br /></span>
<span class="index-item">pnl_atanh, <a 
href="pnl-manual.html#dx1-21006" >111</a> <br /></span>
<span class="index-item">pnl_band_mat_clone, <a 
href="pnl-manual.html#dx1-74005" >112</a> <br /></span>
<span class="index-item">pnl_band_mat_copy, <a 
href="pnl-manual.html#dx1-74006" >113</a> <br /></span>
<span class="index-item">pnl_band_mat_create, <a 
href="pnl-manual.html#dx1-74002" >114</a> <br /></span>
<span class="index-item">pnl_band_mat_create_from_mat, <a 
href="pnl-manual.html#dx1-74003" >115</a> <br /></span>
<span class="index-item">pnl_band_mat_div_band_mat_term, <a 
href="pnl-manual.html#dx1-76008" >116</a> <br /></span>
<span class="index-item">pnl_band_mat_div_scalar, <a 
href="pnl-manual.html#dx1-76003" >117</a> <br /></span>
<span class="index-item">pnl_band_mat_free, <a 
href="pnl-manual.html#dx1-74004" >118</a> <br /></span>
<span class="index-item">pnl_band_mat_get, <a 
href="pnl-manual.html#dx1-75002" >119</a> <br /></span>
<span class="index-item">pnl_band_mat_inv_term, <a 
href="pnl-manual.html#dx1-76007" >120</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_band_mat_lAxpby, <a 
href="pnl-manual.html#dx1-77001" >121</a> <br /></span>
<span class="index-item">pnl_band_mat_lget, <a 
href="pnl-manual.html#dx1-75003" >122</a> <br /></span>
<span class="index-item">pnl_band_mat_lu, <a 
href="pnl-manual.html#dx1-77005" >123</a> <br /></span>
<span class="index-item">pnl_band_mat_lu_syslin, <a 
href="pnl-manual.html#dx1-77007" >124</a> <br /></span>
<span class="index-item">pnl_band_mat_lu_syslin_inplace, <a 
href="pnl-manual.html#dx1-77006" >125</a> <br /></span>
<span class="index-item">pnl_band_mat_map, <a 
href="pnl-manual.html#dx1-76010" >126</a> <br /></span>
<span class="index-item">pnl_band_mat_map_band_mat_inplace, <a 
href="pnl-manual.html#dx1-76012" >127</a> <br /></span>
<span class="index-item">pnl_band_mat_map_inplace, <a 
href="pnl-manual.html#dx1-76011" >128</a> <br /></span>
<span class="index-item">pnl_band_mat_minus_band_mat, <a 
href="pnl-manual.html#dx1-76006" >129</a> <br /></span>
<span class="index-item">pnl_band_mat_minus_scalar, <a 
href="pnl-manual.html#dx1-76002" >130</a> <br /></span>
<span class="index-item">pnl_band_mat_mult_band_mat_term, <a 
href="pnl-manual.html#dx1-76009" >131</a> <br /></span>
<span class="index-item">pnl_band_mat_mult_scalar, <a 
href="pnl-manual.html#dx1-76004" >132</a> <br /></span>
<span class="index-item">pnl_band_mat_mult_vect_inplace, <a 
href="pnl-manual.html#dx1-77002" >133</a> <br /></span>
<span class="index-item">pnl_band_mat_new, <a 
href="pnl-manual.html#dx1-74001" >134</a> <br /></span>
<span class="index-item">PNL_BAND_MAT_OBJECT, <a 
href="pnl-manual.html#dx1-12008" >135</a> <br /></span>
<span class="index-item">pnl_band_mat_plus_band_mat, <a 
href="pnl-manual.html#dx1-76005" >136</a> <br /></span>
<span class="index-item">pnl_band_mat_plus_scalar, <a 
href="pnl-manual.html#dx1-76001" >137</a> <br /></span>
<span class="index-item">pnl_band_mat_print_as_full, <a 
href="pnl-manual.html#dx1-75005" >138</a> <br /></span>
<span class="index-item">pnl_band_mat_resize, <a 
href="pnl-manual.html#dx1-74008" >139</a> <br /></span>
<span class="index-item">pnl_band_mat_set, <a 
href="pnl-manual.html#dx1-75001" >140</a> <br /></span>
<span class="index-item">pnl_band_mat_set_all, <a 
href="pnl-manual.html#dx1-75004" >141</a> <br /></span>
<span class="index-item">pnl_band_mat_syslin, <a 
href="pnl-manual.html#dx1-77004" >142</a> <br /></span>
<span class="index-item">pnl_band_mat_syslin_inplace, <a 
href="pnl-manual.html#dx1-77003" >143</a> <br /></span>
<span class="index-item">pnl_band_mat_to_mat, <a 
href="pnl-manual.html#dx1-74007" >144</a> <br /></span>
<span class="index-item">pnl_basis_add_elt, <a 
href="pnl-manual.html#dx1-108016" >145</a> <br /></span>
<span class="index-item">pnl_basis_add_function, <a 
href="pnl-manual.html#dx1-108008" >146</a> <br /></span>
<span class="index-item">PNL_BASIS_CANONICAL, <a 
href="pnl-manual.html#dx1-106001" >147</a> <br /></span>
<span class="index-item">pnl_basis_clone, <a 
href="pnl-manual.html#dx1-108009" >148</a> <br /></span>
<span class="index-item">pnl_basis_copy, <a 
href="pnl-manual.html#dx1-108010" >149</a> <br /></span>
<span class="index-item">pnl_basis_create, <a 
href="pnl-manual.html#dx1-108004" >150</a> <br /></span>
<span class="index-item">pnl_basis_create_from_degree, <a 
href="pnl-manual.html#dx1-108005" >151</a> <br /></span>
<span class="index-item">pnl_basis_create_from_hyperbolic_degree, <a 
href="pnl-manual.html#dx1-108012" >152</a> <br /></span>
<span class="index-item">pnl_basis_create_from_prod_degree, <a 
href="pnl-manual.html#dx1-108006" >153</a> <br /></span>
<span class="index-item">pnl_basis_create_from_tensor, <a 
href="pnl-manual.html#dx1-108007" >154</a> <br /></span>
<span class="index-item">pnl_basis_del_elt, <a 
href="pnl-manual.html#dx1-108014" >155</a> <br /></span>
<span class="index-item">pnl_basis_del_elt_i, <a 
href="pnl-manual.html#dx1-108015" >156</a> <br /></span>
<span class="index-item">pnl_basis_eval, <a 
href="pnl-manual.html#dx1-108033" >157</a> <br /></span>
<span class="index-item">pnl_basis_eval_D, <a 
href="pnl-manual.html#dx1-108034" >158</a> <br /></span>
<span class="index-item">pnl_basis_eval_D2, <a 
href="pnl-manual.html#dx1-108035" >159</a> <br /></span>
<span class="index-item">pnl_basis_eval_D2_vect, <a 
href="pnl-manual.html#dx1-108028" >160</a> <br /></span>
<span class="index-item">pnl_basis_eval_D_vect, <a 
href="pnl-manual.html#dx1-108027" >161</a> <br /></span>
<span class="index-item">pnl_basis_eval_derivs, <a 
href="pnl-manual.html#dx1-108036" >162</a> <br /></span>
<span class="index-item">pnl_basis_eval_derivs_vect, <a 
href="pnl-manual.html#dx1-108025" >163</a> <br /></span>
<span class="index-item">pnl_basis_eval_vect, <a 
href="pnl-manual.html#dx1-108026" >164</a> <br /></span>
<span class="index-item">pnl_basis_fit_ls, <a 
href="pnl-manual.html#dx1-108020" >165</a> <br /></span>
<span class="index-item">pnl_basis_free, <a 
href="pnl-manual.html#dx1-108013" >166</a> <br /></span>
<span class="index-item">PNL_BASIS_HERMITE, <a 
href="pnl-manual.html#dx1-106002" >167</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_basis_i, <a 
href="pnl-manual.html#dx1-108030" >168</a> <br /></span>
<span class="index-item">pnl_basis_i_D, <a 
href="pnl-manual.html#dx1-108031" >169</a> <br /></span>
<span class="index-item">pnl_basis_i_D2, <a 
href="pnl-manual.html#dx1-108032" >170</a> <br /></span>
<span class="index-item">pnl_basis_i_D2_vect, <a 
href="pnl-manual.html#dx1-108024" >171</a> <br /></span>
<span class="index-item">pnl_basis_i_D_vect, <a 
href="pnl-manual.html#dx1-108023" >172</a> <br /></span>
<span class="index-item">pnl_basis_i_vect, <a 
href="pnl-manual.html#dx1-108022" >173</a> <br /></span>
<span class="index-item">pnl_basis_ik, <a 
href="pnl-manual.html#dx1-108029" >174</a> <br /></span>
<span class="index-item">pnl_basis_ik_vect, <a 
href="pnl-manual.html#dx1-108021" >175</a> <br /></span>
<span class="index-item">pnl_basis_new, <a 
href="pnl-manual.html#dx1-108002" >176</a> <br /></span>
<span class="index-item">PNL_BASIS_OBJECT, <a 
href="pnl-manual.html#dx1-12010" >177</a> <br /></span>
<span class="index-item">pnl_basis_print, <a 
href="pnl-manual.html#dx1-108003" >178</a> <br /></span>
<span class="index-item">pnl_basis_set_domain, <a 
href="pnl-manual.html#dx1-108018" >179</a> <br /></span>
<span class="index-item">pnl_basis_set_from_tensor, <a 
href="pnl-manual.html#dx1-108011" >180</a> <br /></span>
<span class="index-item">pnl_basis_set_reduced, <a 
href="pnl-manual.html#dx1-108019" >181</a> <br /></span>
<span class="index-item">PNL_BASIS_TCHEBYCHEV, <a 
href="pnl-manual.html#dx1-106003" >182</a> <br /></span>
<span class="index-item">pnl_basis_type_register, <a 
href="pnl-manual.html#dx1-108001" >183</a> <br /></span>
<span class="index-item">pnl_bessel_h1, <a 
href="pnl-manual.html#dx1-135010" >184</a> <br /></span>
<span class="index-item">pnl_bessel_h1_scaled, <a 
href="pnl-manual.html#dx1-135011" >185</a> <br /></span>
<span class="index-item">pnl_bessel_h2, <a 
href="pnl-manual.html#dx1-135012" >186</a> <br /></span>
<span class="index-item">pnl_bessel_h2_scaled, <a 
href="pnl-manual.html#dx1-135013" >187</a> <br /></span>
<span class="index-item">pnl_bessel_i, <a 
href="pnl-manual.html#dx1-135001" >188</a> <br /></span>
<span class="index-item">pnl_bessel_i_scaled, <a 
href="pnl-manual.html#dx1-135002" >189</a> <br /></span>
<span class="index-item">pnl_bessel_j, <a 
href="pnl-manual.html#dx1-135004" >190</a> <br /></span>
<span class="index-item">pnl_bessel_j_scaled, <a 
href="pnl-manual.html#dx1-135005" >191</a> <br /></span>
<span class="index-item">pnl_bessel_k, <a 
href="pnl-manual.html#dx1-135008" >192</a> <br /></span>
<span class="index-item">pnl_bessel_k_scaled, <a 
href="pnl-manual.html#dx1-135009" >193</a> <br /></span>
<span class="index-item">pnl_bessel_rati, <a 
href="pnl-manual.html#dx1-135003" >194</a> <br /></span>
<span class="index-item">pnl_bessel_y, <a 
href="pnl-manual.html#dx1-135006" >195</a> <br /></span>
<span class="index-item">pnl_bessel_y_scaled, <a 
href="pnl-manual.html#dx1-135007" >196</a> <br /></span>
<span class="index-item">pnl_bicg_solver_create, <a 
href="pnl-manual.html#dx1-97002" >197</a> <br /></span>
<span class="index-item">pnl_bicg_solver_free, <a 
href="pnl-manual.html#dx1-97004" >198</a> <br /></span>
<span class="index-item">pnl_bicg_solver_initialisation, <a 
href="pnl-manual.html#dx1-97003" >199</a> <br /></span>
<span class="index-item">pnl_bicg_solver_new, <a 
href="pnl-manual.html#dx1-97001" >200</a> <br /></span>
<span class="index-item">pnl_bicg_solver_solve, <a 
href="pnl-manual.html#dx1-97005" >201</a> <br /></span>
<span class="index-item">pnl_bs_call, <a 
href="pnl-manual.html#dx1-148003" >202</a> <br /></span>
<span class="index-item">pnl_bs_call_put, <a 
href="pnl-manual.html#dx1-148005" >203</a> <br /></span>
<span class="index-item">pnl_bs_gamma, <a 
href="pnl-manual.html#dx1-148007" >204</a> <br /></span>
<span class="index-item">pnl_bs_implicit_vol, <a 
href="pnl-manual.html#dx1-148008" >205</a> <br /></span>
<span class="index-item">pnl_bs_matrix_implicit_vol, <a 
href="pnl-manual.html#dx1-148009" >206</a> <br /></span>
<span class="index-item">pnl_bs_put, <a 
href="pnl-manual.html#dx1-148004" >207</a> <br /></span>
<span class="index-item">pnl_bs_vega, <a 
href="pnl-manual.html#dx1-148006" >208</a> <br /></span>
<span class="index-item">pnl_cdf2nor, <a 
href="pnl-manual.html#dx1-100016" >209</a> <br /></span>
<span class="index-item">pnl_cdf_bet, <a 
href="pnl-manual.html#dx1-100001" >210</a> <br /></span>
<span class="index-item">pnl_cdf_bin, <a 
href="pnl-manual.html#dx1-100002" >211</a> <br /></span>
<span class="index-item">pnl_cdf_chi, <a 
href="pnl-manual.html#dx1-100003" >212</a> <br /></span>
<span class="index-item">pnl_cdf_chn, <a 
href="pnl-manual.html#dx1-100004" >213</a> <br /></span>
<span class="index-item">pnl_cdf_f, <a 
href="pnl-manual.html#dx1-100005" >214</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_cdf_fnc, <a 
href="pnl-manual.html#dx1-100006" >215</a> <br /></span>
<span class="index-item">pnl_cdf_gam, <a 
href="pnl-manual.html#dx1-100007" >216</a> <br /></span>
<span class="index-item">pnl_cdf_nbn, <a 
href="pnl-manual.html#dx1-100008" >217</a> <br /></span>
<span class="index-item">pnl_cdf_nor, <a 
href="pnl-manual.html#dx1-100009" >218</a> <br /></span>
<span class="index-item">pnl_cdf_poi, <a 
href="pnl-manual.html#dx1-100010" >219</a> <br /></span>
<span class="index-item">pnl_cdf_t, <a 
href="pnl-manual.html#dx1-100011" >220</a> <br /></span>
<span class="index-item">pnl_cdfbchi2n, <a 
href="pnl-manual.html#dx1-100013" >221</a> <br /></span>
<span class="index-item">pnl_cdfchi2n, <a 
href="pnl-manual.html#dx1-100012" >222</a> <br /></span>
<span class="index-item">pnl_cdfnor, <a 
href="pnl-manual.html#dx1-100015" >223</a> <br /></span>
<span class="index-item">pnl_cell_free, <a 
href="pnl-manual.html#dx1-13008" >224</a> <br /></span>
<span class="index-item">pnl_cell_new, <a 
href="pnl-manual.html#dx1-13004" >225</a> <br /></span>
<span class="index-item">pnl_cf_call_bs, <a 
href="pnl-manual.html#dx1-148001" >226</a> <br /></span>
<span class="index-item">pnl_cf_put_bs, <a 
href="pnl-manual.html#dx1-148002" >227</a> <br /></span>
<span class="index-item">pnl_cg_solver_create, <a 
href="pnl-manual.html#dx1-96002" >228</a> <br /></span>
<span class="index-item">pnl_cg_solver_free, <a 
href="pnl-manual.html#dx1-96004" >229</a> <br /></span>
<span class="index-item">pnl_cg_solver_initialisation, <a 
href="pnl-manual.html#dx1-96003" >230</a> <br /></span>
<span class="index-item">pnl_cg_solver_new, <a 
href="pnl-manual.html#dx1-96001" >231</a> <br /></span>
<span class="index-item">pnl_cg_solver_solve, <a 
href="pnl-manual.html#dx1-96005" >232</a> <br /></span>
<span class="index-item">pnl_complex_bessel_h1, <a 
href="pnl-manual.html#dx1-136010" >233</a> <br /></span>
<span class="index-item">pnl_complex_bessel_h1_scaled, <a 
href="pnl-manual.html#dx1-136011" >234</a> <br /></span>
<span class="index-item">pnl_complex_bessel_h2, <a 
href="pnl-manual.html#dx1-136012" >235</a> <br /></span>
<span class="index-item">pnl_complex_bessel_h2_scaled, <a 
href="pnl-manual.html#dx1-136013" >236</a> <br /></span>
<span class="index-item">pnl_complex_bessel_i, <a 
href="pnl-manual.html#dx1-136001" >237</a> <br /></span>
<span class="index-item">pnl_complex_bessel_i_scaled, <a 
href="pnl-manual.html#dx1-136002" >238</a> <br /></span>
<span class="index-item">pnl_complex_bessel_j, <a 
href="pnl-manual.html#dx1-136004" >239</a> <br /></span>
<span class="index-item">pnl_complex_bessel_j_scaled, <a 
href="pnl-manual.html#dx1-136005" >240</a> <br /></span>
<span class="index-item">pnl_complex_bessel_k, <a 
href="pnl-manual.html#dx1-136008" >241</a> <br /></span>
<span class="index-item">pnl_complex_bessel_k_scaled, <a 
href="pnl-manual.html#dx1-136009" >242</a> <br /></span>
<span class="index-item">pnl_complex_bessel_rati, <a 
href="pnl-manual.html#dx1-136003" >243</a> <br /></span>
<span class="index-item">pnl_complex_bessel_y, <a 
href="pnl-manual.html#dx1-136006" >244</a> <br /></span>
<span class="index-item">pnl_complex_bessel_y_scaled, <a 
href="pnl-manual.html#dx1-136007" >245</a> <br /></span>
<span class="index-item">pnl_complex_isequal, <a 
href="pnl-manual.html#dx1-26043" >246</a> <br /></span>
<span class="index-item">pnl_complex_isequal_abs, <a 
href="pnl-manual.html#dx1-26041" >247</a> <br /></span>
<span class="index-item">pnl_complex_isequal_rel, <a 
href="pnl-manual.html#dx1-26042" >248</a> <br /></span>
<span class="index-item">pnl_cosm1, <a 
href="pnl-manual.html#dx1-21009" >249</a> <br /></span>
<span class="index-item">pnl_deactivate_mtherr, <a 
href="pnl-manual.html#dx1-134001" >250</a> <br /></span>
<span class="index-item">pnl_expm1, <a 
href="pnl-manual.html#dx1-21008" >251</a> <br /></span>
<span class="index-item">pnl_fact, <a 
href="pnl-manual.html#dx1-21001" >252</a> <br /></span>
<span class="index-item">pnl_fft, <a 
href="pnl-manual.html#dx1-116003" >253</a> <br /></span>
<span class="index-item">pnl_fft2, <a 
href="pnl-manual.html#dx1-116005" >254</a> <br /></span>
<span class="index-item">pnl_fft2d, <a 
href="pnl-manual.html#dx1-116015" >255</a> <br /></span>
<span class="index-item">pnl_fft2d_inplace, <a 
href="pnl-manual.html#dx1-116013" >256</a> <br /></span>
<span class="index-item">pnl_fft_alloc_wspace, <a 
href="pnl-manual.html#dx1-117001" >257</a> <br /></span>
<span class="index-item">pnl_fft_inplace, <a 
href="pnl-manual.html#dx1-116001" >258</a> <br /></span>
<span class="index-item">pnl_fft_inplace_with_wspace, <a 
href="pnl-manual.html#dx1-117002" >259</a> <br /></span>
<span class="index-item">PNL_GET_PARENT_TYPE, <a 
href="pnl-manual.html#dx1-12016" >260</a> <br /></span>
<span class="index-item">PNL_GET_TYPE, <a 
href="pnl-manual.html#dx1-12015" >261</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">PNL_GET_TYPENAME, <a 
href="pnl-manual.html#dx1-12014" >262</a> <br /></span>
<span class="index-item">pnl_gmres_solver_create, <a 
href="pnl-manual.html#dx1-98002" >263</a> <br /></span>
<span class="index-item">pnl_gmres_solver_free, <a 
href="pnl-manual.html#dx1-98004" >264</a> <br /></span>
<span class="index-item">pnl_gmres_solver_initialisation, <a 
href="pnl-manual.html#dx1-98003" >265</a> <br /></span>
<span class="index-item">pnl_gmres_solver_new, <a 
href="pnl-manual.html#dx1-98001" >266</a> <br /></span>
<span class="index-item">pnl_gmres_solver_solve, <a 
href="pnl-manual.html#dx1-98005" >267</a> <br /></span>
<span class="index-item">pnl_hmat_clone, <a 
href="pnl-manual.html#dx1-89007" >268</a> <br /></span>
<span class="index-item">pnl_hmat_copy, <a 
href="pnl-manual.html#dx1-89006" >269</a> <br /></span>
<span class="index-item">pnl_hmat_create, <a 
href="pnl-manual.html#dx1-89002" >270</a> <br /></span>
<span class="index-item">pnl_hmat_create_from_ptr, <a 
href="pnl-manual.html#dx1-89004" >271</a> <br /></span>
<span class="index-item">pnl_hmat_create_from_scalar, <a 
href="pnl-manual.html#dx1-89003" >272</a> <br /></span>
<span class="index-item">pnl_hmat_free, <a 
href="pnl-manual.html#dx1-89005" >273</a> <br /></span>
<span class="index-item">pnl_hmat_get, <a 
href="pnl-manual.html#dx1-90002" >274</a> <br /></span>
<span class="index-item">pnl_hmat_lget, <a 
href="pnl-manual.html#dx1-90003" >275</a> <br /></span>
<span class="index-item">pnl_hmat_mult_scalar, <a 
href="pnl-manual.html#dx1-92002" >276</a> <br /></span>
<span class="index-item">pnl_hmat_new, <a 
href="pnl-manual.html#dx1-89001" >277</a> <br /></span>
<span class="index-item">PNL_HMAT_OBJECT, <a 
href="pnl-manual.html#dx1-12007" >278</a> <br /></span>
<span class="index-item">pnl_hmat_plus_hmat, <a 
href="pnl-manual.html#dx1-92001" >279</a> <br /></span>
<span class="index-item">pnl_hmat_print, <a 
href="pnl-manual.html#dx1-91001" >280</a> <br /></span>
<span class="index-item">pnl_hmat_resize, <a 
href="pnl-manual.html#dx1-89008" >281</a> <br /></span>
<span class="index-item">pnl_hmat_set, <a 
href="pnl-manual.html#dx1-90001" >282</a> <br /></span>
<span class="index-item">pnl_ifft, <a 
href="pnl-manual.html#dx1-116004" >283</a> <br /></span>
<span class="index-item">pnl_ifft2, <a 
href="pnl-manual.html#dx1-116006" >284</a> <br /></span>
<span class="index-item">pnl_ifft2d, <a 
href="pnl-manual.html#dx1-116016" >285</a> <br /></span>
<span class="index-item">pnl_ifft2d_inplace, <a 
href="pnl-manual.html#dx1-116014" >286</a> <br /></span>
<span class="index-item">pnl_ifft_inplace, <a 
href="pnl-manual.html#dx1-116002" >287</a> <br /></span>
<span class="index-item">pnl_ifft_inplace_with_wspace, <a 
href="pnl-manual.html#dx1-117003" >288</a> <br /></span>
<span class="index-item">pnl_ilap_cdf_euler, <a 
href="pnl-manual.html#dx1-118003" >289</a> <br /></span>
<span class="index-item">pnl_ilap_euler, <a 
href="pnl-manual.html#dx1-118002" >290</a> <br /></span>
<span class="index-item">pnl_ilap_fft, <a 
href="pnl-manual.html#dx1-118004" >291</a> <br /></span>
<span class="index-item">pnl_ilap_gs, <a 
href="pnl-manual.html#dx1-118005" >292</a> <br /></span>
<span class="index-item">pnl_ilap_gs_basic, <a 
href="pnl-manual.html#dx1-118006" >293</a> <br /></span>
<span class="index-item">PNL_INF, <a 
href="pnl-manual.html#dx1-17026" >294</a> <br /></span>
<span class="index-item">pnl_integration, <a 
href="pnl-manual.html#dx1-111001" >295</a> <br /></span>
<span class="index-item">pnl_integration_2d, <a 
href="pnl-manual.html#dx1-111002" >296</a> <br /></span>
<span class="index-item">pnl_integration_GK, <a 
href="pnl-manual.html#dx1-111004" >297</a> <br /></span>
<span class="index-item">pnl_integration_GK2D, <a 
href="pnl-manual.html#dx1-111006" >298</a> <br /></span>
<span class="index-item">pnl_integration_qag, <a 
href="pnl-manual.html#dx1-111007" >299</a> <br /></span>
<span class="index-item">pnl_integration_qagp, <a 
href="pnl-manual.html#dx1-111008" >300</a> <br /></span>
<span class="index-item">pnl_integration_qng, <a 
href="pnl-manual.html#dx1-111003" >301</a> <br /></span>
<span class="index-item">pnl_integration_qng_2d, <a 
href="pnl-manual.html#dx1-111005" >302</a> <br /></span>
<span class="index-item">pnl_inv_cdfnor, <a 
href="pnl-manual.html#dx1-100017" >303</a> <br /></span>
<span class="index-item">pnl_iround, <a 
href="pnl-manual.html#dx1-20005" >304</a> <br /></span>
<span class="index-item">PNL_IS_EVEN, <a 
href="pnl-manual.html#dx1-18002" >305</a> <br /></span>
<span class="index-item">PNL_IS_ODD, <a 
href="pnl-manual.html#dx1-18001" >306</a> <br /></span>
<span class="index-item">pnl_isequal, <a 
href="pnl-manual.html#dx1-22003" >307</a> <br /></span>
<span class="index-item">pnl_isequal_abs, <a 
href="pnl-manual.html#dx1-22002" >308</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_isequal_rel, <a 
href="pnl-manual.html#dx1-22001" >309</a> <br /></span>
<span class="index-item">pnl_isfinite, <a 
href="pnl-manual.html#dx1-19006" >310</a> <br /></span>
<span class="index-item">pnl_isinf, <a 
href="pnl-manual.html#dx1-19005" >311</a> <br /></span>
<span class="index-item">pnl_isnan, <a 
href="pnl-manual.html#dx1-19004" >312</a> <br /></span>
<span class="index-item">pnl_itrunc, <a 
href="pnl-manual.html#dx1-20001" >313</a> <br /></span>
<span class="index-item">pnl_lgamma, <a 
href="pnl-manual.html#dx1-21002" >314</a> <br /></span>
<span class="index-item">PNL_LIST_ARRAY, <a 
href="pnl-manual.html#dx1-12013" >315</a> <br /></span>
<span class="index-item">pnl_list_clone, <a 
href="pnl-manual.html#dx1-13006" >316</a> <br /></span>
<span class="index-item">pnl_list_concat, <a 
href="pnl-manual.html#dx1-13015" >317</a> <br /></span>
<span class="index-item">pnl_list_copy, <a 
href="pnl-manual.html#dx1-13005" >318</a> <br /></span>
<span class="index-item">pnl_list_free, <a 
href="pnl-manual.html#dx1-13007" >319</a> <br /></span>
<span class="index-item">pnl_list_get, <a 
href="pnl-manual.html#dx1-13009" >320</a> <br /></span>
<span class="index-item">pnl_list_insert_first, <a 
href="pnl-manual.html#dx1-13010" >321</a> <br /></span>
<span class="index-item">pnl_list_insert_last, <a 
href="pnl-manual.html#dx1-13011" >322</a> <br /></span>
<span class="index-item">pnl_list_new, <a 
href="pnl-manual.html#dx1-13003" >323</a> <br /></span>
<span class="index-item">PNL_LIST_OBJECT, <a 
href="pnl-manual.html#dx1-12012" >324</a> <br /></span>
<span class="index-item">pnl_list_print, <a 
href="pnl-manual.html#dx1-13017" >325</a> <br /></span>
<span class="index-item">pnl_list_remove_first, <a 
href="pnl-manual.html#dx1-13013" >326</a> <br /></span>
<span class="index-item">pnl_list_remove_i, <a 
href="pnl-manual.html#dx1-13014" >327</a> <br /></span>
<span class="index-item">pnl_list_remove_last, <a 
href="pnl-manual.html#dx1-13012" >328</a> <br /></span>
<span class="index-item">pnl_list_resize, <a 
href="pnl-manual.html#dx1-13016" >329</a> <br /></span>
<span class="index-item">pnl_log1p, <a 
href="pnl-manual.html#dx1-21007" >330</a> <br /></span>
<span class="index-item">pnl_lround, <a 
href="pnl-manual.html#dx1-20006" >331</a> <br /></span>
<span class="index-item">pnl_ltrunc, <a 
href="pnl-manual.html#dx1-20002" >332</a> <br /></span>
<span class="index-item">pnl_mat_add_row, <a 
href="pnl-manual.html#dx1-50024" >333</a> <br /></span>
<span class="index-item">pnl_mat_axpy, <a 
href="pnl-manual.html#dx1-56007" >334</a> <br /></span>
<span class="index-item">pnl_mat_bicg_solver_solve, <a 
href="pnl-manual.html#dx1-99002" >335</a> <br /></span>
<span class="index-item">pnl_mat_cg_solver_solve, <a 
href="pnl-manual.html#dx1-99001" >336</a> <br /></span>
<span class="index-item">pnl_mat_chol, <a 
href="pnl-manual.html#dx1-57001" >337</a> <br /></span>
<span class="index-item">pnl_mat_chol_syslin, <a 
href="pnl-manual.html#dx1-57006" >338</a> <br /></span>
<span class="index-item">pnl_mat_chol_syslin_inplace, <a 
href="pnl-manual.html#dx1-57007" >339</a> <br /></span>
<span class="index-item">pnl_mat_chol_syslin_mat, <a 
href="pnl-manual.html#dx1-57013" >340</a> <br /></span>
<span class="index-item">pnl_mat_clone, <a 
href="pnl-manual.html#dx1-49014" >341</a> <br /></span>
<span class="index-item">pnl_mat_col_permute, <a 
href="pnl-manual.html#dx1-61010" >342</a> <br /></span>
<span class="index-item">pnl_mat_complex_create_from_mat, <a 
href="pnl-manual.html#dx1-60001" >343</a> <br /></span>
<span class="index-item">pnl_mat_copy, <a 
href="pnl-manual.html#dx1-49007" >344</a> <br /></span>
<span class="index-item">pnl_mat_create, <a 
href="pnl-manual.html#dx1-49002" >345</a> <br /></span>
<span class="index-item">pnl_mat_create_diag, <a 
href="pnl-manual.html#dx1-49009" >346</a> <br /></span>
<span class="index-item">pnl_mat_create_diag_from_ptr, <a 
href="pnl-manual.html#dx1-49008" >347</a> <br /></span>
<span class="index-item">pnl_mat_create_from_file, <a 
href="pnl-manual.html#dx1-49010" >348</a> <br /></span>
<span class="index-item">pnl_mat_create_from_list, <a 
href="pnl-manual.html#dx1-49006" >349</a> <br /></span>
<span class="index-item">pnl_mat_create_from_ptr, <a 
href="pnl-manual.html#dx1-49005" >350</a> <br /></span>
<span class="index-item">pnl_mat_create_from_scalar, <a 
href="pnl-manual.html#dx1-49003" >351</a> <br /></span>
<span class="index-item">pnl_mat_create_from_sp_mat, <a 
href="pnl-manual.html#dx1-81007" >352</a> <br /></span>
<span class="index-item">pnl_mat_create_from_zero, <a 
href="pnl-manual.html#dx1-49004" >353</a> <br /></span>
<span class="index-item">pnl_mat_cross, <a 
href="pnl-manual.html#dx1-56013" >354</a> <br /></span>
<span class="index-item">pnl_mat_cumprod, <a 
href="pnl-manual.html#dx1-53014" >355</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_mat_cumsum, <a 
href="pnl-manual.html#dx1-53011" >356</a> <br /></span>
<span class="index-item">pnl_mat_del_row, <a 
href="pnl-manual.html#dx1-50025" >357</a> <br /></span>
<span class="index-item">pnl_mat_dgemm, <a 
href="pnl-manual.html#dx1-56016" >358</a> <br /></span>
<span class="index-item">pnl_mat_dgemv, <a 
href="pnl-manual.html#dx1-56015" >359</a> <br /></span>
<span class="index-item">pnl_mat_dger, <a 
href="pnl-manual.html#dx1-56008" >360</a> <br /></span>
<span class="index-item">pnl_mat_div_mat_term, <a 
href="pnl-manual.html#dx1-53002" >361</a> <br /></span>
<span class="index-item">pnl_mat_div_scalar, <a 
href="pnl-manual.html#dx1-52004" >362</a> <br /></span>
<span class="index-item">pnl_mat_eigen, <a 
href="pnl-manual.html#dx1-56022" >363</a> <br /></span>
<span class="index-item">pnl_mat_exp, <a 
href="pnl-manual.html#dx1-56020" >364</a> <br /></span>
<span class="index-item">pnl_mat_extract_subblock, <a 
href="pnl-manual.html#dx1-49018" >365</a> <br /></span>
<span class="index-item">pnl_mat_find, <a 
href="pnl-manual.html#dx1-55009" >366</a> <br /></span>
<span class="index-item">pnl_mat_fprint, <a 
href="pnl-manual.html#dx1-51002" >367</a> <br /></span>
<span class="index-item">pnl_mat_fprint_nsp, <a 
href="pnl-manual.html#dx1-51004" >368</a> <br /></span>
<span class="index-item">pnl_mat_free, <a 
href="pnl-manual.html#dx1-49011" >369</a> <br /></span>
<span class="index-item">pnl_mat_get, <a 
href="pnl-manual.html#dx1-50008" >370</a> <br /></span>
<span class="index-item">pnl_mat_get_col, <a 
href="pnl-manual.html#dx1-50016" >371</a> <br /></span>
<span class="index-item">pnl_mat_get_row, <a 
href="pnl-manual.html#dx1-50015" >372</a> <br /></span>
<span class="index-item">pnl_mat_gmres_solver_solve, <a 
href="pnl-manual.html#dx1-99003" >373</a> <br /></span>
<span class="index-item">pnl_mat_inverse, <a 
href="pnl-manual.html#dx1-57017" >374</a> <br /></span>
<span class="index-item">pnl_mat_inverse_with_chol, <a 
href="pnl-manual.html#dx1-57018" >375</a> <br /></span>
<span class="index-item">pnl_mat_isequal, <a 
href="pnl-manual.html#dx1-54001" >376</a> <br /></span>
<span class="index-item">pnl_mat_isequal_abs, <a 
href="pnl-manual.html#dx1-54002" >377</a> <br /></span>
<span class="index-item">pnl_mat_isequal_rel, <a 
href="pnl-manual.html#dx1-54003" >378</a> <br /></span>
<span class="index-item">pnl_mat_kron_mat, <a 
href="pnl-manual.html#dx1-53004" >379</a> <br /></span>
<span class="index-item">pnl_mat_kron_mat_inplace, <a 
href="pnl-manual.html#dx1-53003" >380</a> <br /></span>
<span class="index-item">pnl_mat_lAxpby, <a 
href="pnl-manual.html#dx1-56014" >381</a> <br /></span>
<span class="index-item">pnl_mat_lget, <a 
href="pnl-manual.html#dx1-50009" >382</a> <br /></span>
<span class="index-item">pnl_mat_log, <a 
href="pnl-manual.html#dx1-56021" >383</a> <br /></span>
<span class="index-item">pnl_mat_lower_inverse, <a 
href="pnl-manual.html#dx1-57016" >384</a> <br /></span>
<span class="index-item">pnl_mat_lower_syslin, <a 
href="pnl-manual.html#dx1-57005" >385</a> <br /></span>
<span class="index-item">pnl_mat_ls, <a 
href="pnl-manual.html#dx1-59003" >386</a> <br /></span>
<span class="index-item">pnl_mat_ls_mat, <a 
href="pnl-manual.html#dx1-59004" >387</a> <br /></span>
<span class="index-item">pnl_mat_lu, <a 
href="pnl-manual.html#dx1-57003" >388</a> <br /></span>
<span class="index-item">pnl_mat_lu_syslin, <a 
href="pnl-manual.html#dx1-57008" >389</a> <br /></span>
<span class="index-item">pnl_mat_lu_syslin_inplace, <a 
href="pnl-manual.html#dx1-57009" >390</a> <br /></span>
<span class="index-item">pnl_mat_lu_syslin_mat, <a 
href="pnl-manual.html#dx1-57014" >391</a> <br /></span>
<span class="index-item">pnl_mat_map, <a 
href="pnl-manual.html#dx1-53006" >392</a> <br /></span>
<span class="index-item">pnl_mat_map_inplace, <a 
href="pnl-manual.html#dx1-53005" >393</a> <br /></span>
<span class="index-item">pnl_mat_map_mat, <a 
href="pnl-manual.html#dx1-53008" >394</a> <br /></span>
<span class="index-item">pnl_mat_map_mat_inplace, <a 
href="pnl-manual.html#dx1-53007" >395</a> <br /></span>
<span class="index-item">pnl_mat_max, <a 
href="pnl-manual.html#dx1-55001" >396</a> <br /></span>
<span class="index-item">pnl_mat_max_index, <a 
href="pnl-manual.html#dx1-55005" >397</a> <br /></span>
<span class="index-item">pnl_mat_min, <a 
href="pnl-manual.html#dx1-55002" >398</a> <br /></span>
<span class="index-item">pnl_mat_min_index, <a 
href="pnl-manual.html#dx1-55004" >399</a> <br /></span>
<span class="index-item">pnl_mat_minmax, <a 
href="pnl-manual.html#dx1-55003" >400</a> <br /></span>
<span class="index-item">pnl_mat_minmax_index, <a 
href="pnl-manual.html#dx1-55006" >401</a> <br /></span>
<span class="index-item">pnl_mat_minus_mat, <a 
href="pnl-manual.html#dx1-56002" >402</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_mat_minus_scalar, <a 
href="pnl-manual.html#dx1-52002" >403</a> <br /></span>
<span class="index-item">pnl_mat_mult_mat, <a 
href="pnl-manual.html#dx1-56017" >404</a> <br /></span>
<span class="index-item">pnl_mat_mult_mat_inplace, <a 
href="pnl-manual.html#dx1-56018" >405</a> <br /></span>
<span class="index-item">pnl_mat_mult_mat_term, <a 
href="pnl-manual.html#dx1-53001" >406</a> <br /></span>
<span class="index-item">pnl_mat_mult_scalar, <a 
href="pnl-manual.html#dx1-52003" >407</a> <br /></span>
<span class="index-item">pnl_mat_mult_vect, <a 
href="pnl-manual.html#dx1-56009" >408</a> <br /></span>
<span class="index-item">pnl_mat_mult_vect_inplace, <a 
href="pnl-manual.html#dx1-56010" >409</a> <br /></span>
<span class="index-item">pnl_mat_mult_vect_transpose, <a 
href="pnl-manual.html#dx1-56011" >410</a> <br /></span>
<span class="index-item">pnl_mat_mult_vect_transpose_inplace, <a 
href="pnl-manual.html#dx1-56012" >411</a> <br /></span>
<span class="index-item">pnl_mat_new, <a 
href="pnl-manual.html#dx1-49001" >412</a> <br /></span>
<span class="index-item">PNL_MAT_OBJECT, <a 
href="pnl-manual.html#dx1-12005" >413</a> <br /></span>
<span class="index-item">pnl_mat_pchol, <a 
href="pnl-manual.html#dx1-57002" >414</a> <br /></span>
<span class="index-item">pnl_mat_plus_mat, <a 
href="pnl-manual.html#dx1-56001" >415</a> <br /></span>
<span class="index-item">pnl_mat_plus_scalar, <a 
href="pnl-manual.html#dx1-52001" >416</a> <br /></span>
<span class="index-item">pnl_mat_print, <a 
href="pnl-manual.html#dx1-51001" >417</a> <br /></span>
<span class="index-item">pnl_mat_print_nsp, <a 
href="pnl-manual.html#dx1-51003" >418</a> <br /></span>
<span class="index-item">pnl_mat_prod, <a 
href="pnl-manual.html#dx1-53012" >419</a> <br /></span>
<span class="index-item">pnl_mat_prod_vect, <a 
href="pnl-manual.html#dx1-53013" >420</a> <br /></span>
<span class="index-item">pnl_mat_qr, <a 
href="pnl-manual.html#dx1-59001" >421</a> <br /></span>
<span class="index-item">pnl_mat_qr_syslin, <a 
href="pnl-manual.html#dx1-59002" >422</a> <br /></span>
<span class="index-item">pnl_mat_qsort, <a 
href="pnl-manual.html#dx1-55007" >423</a> <br /></span>
<span class="index-item">pnl_mat_qsort_index, <a 
href="pnl-manual.html#dx1-55008" >424</a> <br /></span>
<span class="index-item">pnl_mat_rand_normal, <a 
href="pnl-manual.html#dx1-103021" >425</a> <br /></span>
<span class="index-item">pnl_mat_rand_uni, <a 
href="pnl-manual.html#dx1-103019" >426</a> <br /></span>
<span class="index-item">pnl_mat_rand_uni2, <a 
href="pnl-manual.html#dx1-103020" >427</a> <br /></span>
<span class="index-item">pnl_mat_resize, <a 
href="pnl-manual.html#dx1-49015" >428</a> <br /></span>
<span class="index-item">pnl_mat_rng_bernoulli, <a 
href="pnl-manual.html#dx1-102040" >429</a> <br /></span>
<span class="index-item">pnl_mat_rng_normal, <a 
href="pnl-manual.html#dx1-102039" >430</a> <br /></span>
<span class="index-item">pnl_mat_rng_poisson, <a 
href="pnl-manual.html#dx1-102041" >431</a> <br /></span>
<span class="index-item">pnl_mat_rng_uni, <a 
href="pnl-manual.html#dx1-102037" >432</a> <br /></span>
<span class="index-item">pnl_mat_rng_uni2, <a 
href="pnl-manual.html#dx1-102038" >433</a> <br /></span>
<span class="index-item">pnl_mat_row_permute, <a 
href="pnl-manual.html#dx1-61011" >434</a> <br /></span>
<span class="index-item">pnl_mat_scalar_prod, <a 
href="pnl-manual.html#dx1-56019" >435</a> <br /></span>
<span class="index-item">pnl_mat_set, <a 
href="pnl-manual.html#dx1-50007" >436</a> <br /></span>
<span class="index-item">pnl_mat_set_all, <a 
href="pnl-manual.html#dx1-50010" >437</a> <br /></span>
<span class="index-item">pnl_mat_set_col, <a 
href="pnl-manual.html#dx1-50020" >438</a> <br /></span>
<span class="index-item">pnl_mat_set_col_from_ptr, <a 
href="pnl-manual.html#dx1-50021" >439</a> <br /></span>
<span class="index-item">pnl_mat_set_diag, <a 
href="pnl-manual.html#dx1-50013" >440</a> <br /></span>
<span class="index-item">pnl_mat_set_from_ptr, <a 
href="pnl-manual.html#dx1-50014" >441</a> <br /></span>
<span class="index-item">pnl_mat_set_id, <a 
href="pnl-manual.html#dx1-50012" >442</a> <br /></span>
<span class="index-item">pnl_mat_set_row, <a 
href="pnl-manual.html#dx1-50022" >443</a> <br /></span>
<span class="index-item">pnl_mat_set_row_from_ptr, <a 
href="pnl-manual.html#dx1-50023" >444</a> <br /></span>
<span class="index-item">pnl_mat_set_subblock, <a 
href="pnl-manual.html#dx1-49019" >445</a> <br /></span>
<span class="index-item">pnl_mat_set_zero, <a 
href="pnl-manual.html#dx1-50011" >446</a> <br /></span>
<span class="index-item">pnl_mat_sq_transpose, <a 
href="pnl-manual.html#dx1-56003" >447</a> <br /></span>
<span class="index-item">pnl_mat_sum, <a 
href="pnl-manual.html#dx1-53009" >448</a> <br /></span>
<span class="index-item">pnl_mat_sum_vect, <a 
href="pnl-manual.html#dx1-53010" >449</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_mat_swap_rows, <a 
href="pnl-manual.html#dx1-50019" >450</a> <br /></span>
<span class="index-item">pnl_mat_syslin, <a 
href="pnl-manual.html#dx1-57010" >451</a> <br /></span>
<span class="index-item">pnl_mat_syslin_inplace, <a 
href="pnl-manual.html#dx1-57011" >452</a> <br /></span>
<span class="index-item">pnl_mat_syslin_mat, <a 
href="pnl-manual.html#dx1-57012" >453</a> <br /></span>
<span class="index-item">pnl_mat_tr, <a 
href="pnl-manual.html#dx1-56005" >454</a> <br /></span>
<span class="index-item">pnl_mat_trace, <a 
href="pnl-manual.html#dx1-56006" >455</a> <br /></span>
<span class="index-item">pnl_mat_transpose, <a 
href="pnl-manual.html#dx1-56004" >456</a> <br /></span>
<span class="index-item">pnl_mat_upper_inverse, <a 
href="pnl-manual.html#dx1-57015" >457</a> <br /></span>
<span class="index-item">pnl_mat_upper_syslin, <a 
href="pnl-manual.html#dx1-57004" >458</a> <br /></span>
<span class="index-item">pnl_mat_wrap_array, <a 
href="pnl-manual.html#dx1-49012" >459</a> <br /></span>
<span class="index-item">pnl_mat_wrap_hmat, <a 
href="pnl-manual.html#dx1-90004" >460</a> <br /></span>
<span class="index-item">pnl_mat_wrap_mat_rows, <a 
href="pnl-manual.html#dx1-50018" >461</a> <br /></span>
<span class="index-item">pnl_mat_wrap_vect, <a 
href="pnl-manual.html#dx1-49013" >462</a> <br /></span>
<span class="index-item">pnl_multiroot_newton, <a 
href="pnl-manual.html#dx1-133001" >463</a> <br /></span>
<span class="index-item">pnl_nan, <a 
href="pnl-manual.html#dx1-19001" >464</a> <br /></span>
<span class="index-item">PNL_NEGINF, <a 
href="pnl-manual.html#dx1-17024" >465</a> <br /></span>
<span class="index-item">pnl_neginf, <a 
href="pnl-manual.html#dx1-19003" >466</a> <br /></span>
<span class="index-item">pnl_normal_density, <a 
href="pnl-manual.html#dx1-100014" >467</a> <br /></span>
<span class="index-item">PNL_OBJECT, <a 
href="pnl-manual.html#dx1-12003" >468</a> <br /></span>
<span class="index-item">pnl_object_create, <a 
href="pnl-manual.html#dx1-12017" >469</a> <br /></span>
<span class="index-item">pnl_object_load, <a 
href="pnl-manual.html#dx1-147004" >470</a> <br /></span>
<span class="index-item">pnl_object_load_into_list, <a 
href="pnl-manual.html#dx1-147005" >471</a> <br /></span>
<span class="index-item">pnl_object_mpi_bcast, <a 
href="pnl-manual.html#dx1-146007" >472</a> <br /></span>
<span class="index-item">pnl_object_mpi_irecv, <a 
href="pnl-manual.html#dx1-146010" >473</a> <br /></span>
<span class="index-item">pnl_object_mpi_isend, <a 
href="pnl-manual.html#dx1-146009" >474</a> <br /></span>
<span class="index-item">pnl_object_mpi_pack, <a 
href="pnl-manual.html#dx1-146002" >475</a> <br /></span>
<span class="index-item">pnl_object_mpi_pack_size, <a 
href="pnl-manual.html#dx1-146001" >476</a> <br /></span>
<span class="index-item">pnl_object_mpi_recv, <a 
href="pnl-manual.html#dx1-146006" >477</a> <br /></span>
<span class="index-item">pnl_object_mpi_reduce, <a 
href="pnl-manual.html#dx1-146008" >478</a> <br /></span>
<span class="index-item">pnl_object_mpi_send, <a 
href="pnl-manual.html#dx1-146004" >479</a> <br /></span>
<span class="index-item">pnl_object_mpi_ssend, <a 
href="pnl-manual.html#dx1-146005" >480</a> <br /></span>
<span class="index-item">pnl_object_mpi_unpack, <a 
href="pnl-manual.html#dx1-146003" >481</a> <br /></span>
<span class="index-item">pnl_object_save, <a 
href="pnl-manual.html#dx1-147003" >482</a> <br /></span>
<span class="index-item">pnl_ode_rkf45, <a 
href="pnl-manual.html#dx1-121001" >483</a> <br /></span>
<span class="index-item">pnl_ode_rkf45_step, <a 
href="pnl-manual.html#dx1-121002" >484</a> <br /></span>
<span class="index-item">pnl_optim_intpoints_bfgs_solve, <a 
href="pnl-manual.html#dx1-128001" >485</a> <br /></span>
<span class="index-item">pnl_optim_linprog, <a 
href="pnl-manual.html#dx1-125001" >486</a> <br /></span>
<span class="index-item">pnl_optim_linprog_sp, <a 
href="pnl-manual.html#dx1-125002" >487</a> <br /></span>
<span class="index-item">pnl_permutation_create, <a 
href="pnl-manual.html#dx1-61003" >488</a> <br /></span>
<span class="index-item">pnl_permutation_fprint, <a 
href="pnl-manual.html#dx1-61012" >489</a> <br /></span>
<span class="index-item">pnl_permutation_free, <a 
href="pnl-manual.html#dx1-61004" >490</a> <br /></span>
<span class="index-item">pnl_permutation_inverse, <a 
href="pnl-manual.html#dx1-61005" >491</a> <br /></span>
<span class="index-item">pnl_permutation_new, <a 
href="pnl-manual.html#dx1-61002" >492</a> <br /></span>
<span class="index-item">pnl_permutation_print, <a 
href="pnl-manual.html#dx1-61013" >493</a> <br /></span>
<span class="index-item">PNL_POSINF, <a 
href="pnl-manual.html#dx1-17025" >494</a> <br /></span>
<span class="index-item">pnl_posinf, <a 
href="pnl-manual.html#dx1-19002" >495</a> <br /></span>
<span class="index-item">pnl_pow_i, <a 
href="pnl-manual.html#dx1-21010" >496</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_rand_bernoulli, <a 
href="pnl-manual.html#dx1-103005" >497</a> <br /></span>
<span class="index-item">pnl_rand_bessel, <a 
href="pnl-manual.html#dx1-103014" >498</a> <br /></span>
<span class="index-item">pnl_rand_chi2, <a 
href="pnl-manual.html#dx1-103013" >499</a> <br /></span>
<span class="index-item">pnl_rand_exp, <a 
href="pnl-manual.html#dx1-103007" >500</a> <br /></span>
<span class="index-item">pnl_rand_gamma, <a 
href="pnl-manual.html#dx1-103012" >501</a> <br /></span>
<span class="index-item">pnl_rand_gauss, <a 
href="pnl-manual.html#dx1-103022" >502</a> <br /></span>
<span class="index-item">pnl_rand_init, <a 
href="pnl-manual.html#dx1-103001" >503</a> <br /></span>
<span class="index-item">pnl_rand_name, <a 
href="pnl-manual.html#dx1-103004" >504</a> <br /></span>
<span class="index-item">pnl_rand_normal, <a 
href="pnl-manual.html#dx1-103010" >505</a> <br /></span>
<span class="index-item">pnl_rand_or_quasi, <a 
href="pnl-manual.html#dx1-103002" >506</a> <br /></span>
<span class="index-item">pnl_rand_poisson, <a 
href="pnl-manual.html#dx1-103006" >507</a> <br /></span>
<span class="index-item">pnl_rand_poisson1, <a 
href="pnl-manual.html#dx1-103011" >508</a> <br /></span>
<span class="index-item">pnl_rand_sseed, <a 
href="pnl-manual.html#dx1-103003" >509</a> <br /></span>
<span class="index-item">pnl_rand_uni, <a 
href="pnl-manual.html#dx1-103008" >510</a> <br /></span>
<span class="index-item">pnl_rand_uni_ab, <a 
href="pnl-manual.html#dx1-103009" >511</a> <br /></span>
<span class="index-item">pnl_real_fft, <a 
href="pnl-manual.html#dx1-116007" >512</a> <br /></span>
<span class="index-item">pnl_real_fft2, <a 
href="pnl-manual.html#dx1-116011" >513</a> <br /></span>
<span class="index-item">pnl_real_fft2d, <a 
href="pnl-manual.html#dx1-116017" >514</a> <br /></span>
<span class="index-item">pnl_real_fft_inplace, <a 
href="pnl-manual.html#dx1-116009" >515</a> <br /></span>
<span class="index-item">pnl_real_fft_inplace_with_wspace, <a 
href="pnl-manual.html#dx1-117004" >516</a> <br /></span>
<span class="index-item">pnl_real_fft_with_wspace, <a 
href="pnl-manual.html#dx1-117006" >517</a> <br /></span>
<span class="index-item">pnl_real_ifft, <a 
href="pnl-manual.html#dx1-116008" >518</a> <br /></span>
<span class="index-item">pnl_real_ifft2, <a 
href="pnl-manual.html#dx1-116012" >519</a> <br /></span>
<span class="index-item">pnl_real_ifft2d, <a 
href="pnl-manual.html#dx1-116018" >520</a> <br /></span>
<span class="index-item">pnl_real_ifft_inplace, <a 
href="pnl-manual.html#dx1-116010" >521</a> <br /></span>
<span class="index-item">pnl_real_ifft_inplace_with_wspace, <a 
href="pnl-manual.html#dx1-117005" >522</a> <br /></span>
<span class="index-item">pnl_real_ifft_with_wspace, <a 
href="pnl-manual.html#dx1-117007" >523</a> <br /></span>
<span class="index-item">pnl_rng_bernoulli, <a 
href="pnl-manual.html#dx1-102014" >524</a> <br /></span>
<span class="index-item">pnl_rng_bessel, <a 
href="pnl-manual.html#dx1-102027" >525</a> <br /></span>
<span class="index-item">pnl_rng_chi2, <a 
href="pnl-manual.html#dx1-102025" >526</a> <br /></span>
<span class="index-item">pnl_rng_clone, <a 
href="pnl-manual.html#dx1-102007" >527</a> <br /></span>
<span class="index-item">pnl_rng_copy, <a 
href="pnl-manual.html#dx1-102006" >528</a> <br /></span>
<span class="index-item">pnl_rng_create, <a 
href="pnl-manual.html#dx1-102003" >529</a> <br /></span>
<span class="index-item">pnl_rng_create_from_file, <a 
href="pnl-manual.html#dx1-147001" >530</a> <br /></span>
<span class="index-item">pnl_rng_dblexp, <a 
href="pnl-manual.html#dx1-102017" >531</a> <br /></span>
<span class="index-item">pnl_rng_dcmt_create_array, <a 
href="pnl-manual.html#dx1-102010" >532</a> <br /></span>
<span class="index-item">pnl_rng_dcmt_create_array_id, <a 
href="pnl-manual.html#dx1-102009" >533</a> <br /></span>
<span class="index-item">pnl_rng_dcmt_create_id, <a 
href="pnl-manual.html#dx1-102008" >534</a> <br /></span>
<span class="index-item">pnl_rng_exp, <a 
href="pnl-manual.html#dx1-102016" >535</a> <br /></span>
<span class="index-item">pnl_rng_free, <a 
href="pnl-manual.html#dx1-102002" >536</a> <br /></span>
<span class="index-item">pnl_rng_gamma, <a 
href="pnl-manual.html#dx1-102024" >537</a> <br /></span>
<span class="index-item">pnl_rng_gauss, <a 
href="pnl-manual.html#dx1-102028" >538</a> <br /></span>
<span class="index-item">pnl_rng_get_from_id, <a 
href="pnl-manual.html#dx1-102013" >539</a> <br /></span>
<span class="index-item">pnl_rng_init, <a 
href="pnl-manual.html#dx1-102012" >540</a> <br /></span>
<span class="index-item">pnl_rng_invgauss, <a 
href="pnl-manual.html#dx1-102022" >541</a> <br /></span>
<span class="index-item">pnl_rng_lognormal, <a 
href="pnl-manual.html#dx1-102021" >542</a> <br /></span>
<span class="index-item">pnl_rng_ncchi2, <a 
href="pnl-manual.html#dx1-102026" >543</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_rng_new, <a 
href="pnl-manual.html#dx1-102011" >544</a> <br /></span>
<span class="index-item">pnl_rng_normal, <a 
href="pnl-manual.html#dx1-102020" >545</a> <br /></span>
<span class="index-item">PNL_RNG_OBJECT, <a 
href="pnl-manual.html#dx1-12011" >546</a> <br /></span>
<span class="index-item">pnl_rng_poisson, <a 
href="pnl-manual.html#dx1-102015" >547</a> <br /></span>
<span class="index-item">pnl_rng_poisson1, <a 
href="pnl-manual.html#dx1-102023" >548</a> <br /></span>
<span class="index-item">pnl_rng_save_to_file, <a 
href="pnl-manual.html#dx1-147002" >549</a> <br /></span>
<span class="index-item">pnl_rng_sdim, <a 
href="pnl-manual.html#dx1-102005" >550</a> <br /></span>
<span class="index-item">pnl_rng_sseed, <a 
href="pnl-manual.html#dx1-102004" >551</a> <br /></span>
<span class="index-item">pnl_rng_uni, <a 
href="pnl-manual.html#dx1-102018" >552</a> <br /></span>
<span class="index-item">pnl_rng_uni_ab, <a 
href="pnl-manual.html#dx1-102019" >553</a> <br /></span>
<span class="index-item">pnl_root_bisection, <a 
href="pnl-manual.html#dx1-132004" >554</a> <br /></span>
<span class="index-item">pnl_root_brent, <a 
href="pnl-manual.html#dx1-132001" >555</a> <br /></span>
<span class="index-item">pnl_root_fsolve, <a 
href="pnl-manual.html#dx1-133002" >556</a> <br /></span>
<span class="index-item">pnl_root_fsolve_lsq, <a 
href="pnl-manual.html#dx1-133003" >557</a> <br /></span>
<span class="index-item">pnl_root_newton, <a 
href="pnl-manual.html#dx1-132003" >558</a> <br /></span>
<span class="index-item">pnl_root_newton_bisection, <a 
href="pnl-manual.html#dx1-132002" >559</a> <br /></span>
<span class="index-item">pnl_round, <a 
href="pnl-manual.html#dx1-20004" >560</a> <br /></span>
<span class="index-item">pnl_sf_choose, <a 
href="pnl-manual.html#dx1-138005" >561</a> <br /></span>
<span class="index-item">pnl_sf_complex_dawson, <a 
href="pnl-manual.html#dx1-137012" >562</a> <br /></span>
<span class="index-item">pnl_sf_complex_erf, <a 
href="pnl-manual.html#dx1-137002" >563</a> <br /></span>
<span class="index-item">pnl_sf_complex_erfc, <a 
href="pnl-manual.html#dx1-137004" >564</a> <br /></span>
<span class="index-item">pnl_sf_complex_erfcx, <a 
href="pnl-manual.html#dx1-137006" >565</a> <br /></span>
<span class="index-item">pnl_sf_complex_erfi, <a 
href="pnl-manual.html#dx1-137010" >566</a> <br /></span>
<span class="index-item">pnl_sf_dawson, <a 
href="pnl-manual.html#dx1-137011" >567</a> <br /></span>
<span class="index-item">pnl_sf_erf, <a 
href="pnl-manual.html#dx1-137001" >568</a> <br /></span>
<span class="index-item">pnl_sf_erfc, <a 
href="pnl-manual.html#dx1-137003" >569</a> <br /></span>
<span class="index-item">pnl_sf_erfcx, <a 
href="pnl-manual.html#dx1-137005" >570</a> <br /></span>
<span class="index-item">pnl_sf_erfi, <a 
href="pnl-manual.html#dx1-137009" >571</a> <br /></span>
<span class="index-item">pnl_sf_expint_En, <a 
href="pnl-manual.html#dx1-141001" >572</a> <br /></span>
<span class="index-item">pnl_sf_fact, <a 
href="pnl-manual.html#dx1-138001" >573</a> <br /></span>
<span class="index-item">pnl_sf_gamma, <a 
href="pnl-manual.html#dx1-138002" >574</a> <br /></span>
<span class="index-item">pnl_sf_gamma_inc, <a 
href="pnl-manual.html#dx1-140001" >575</a> <br /></span>
<span class="index-item">pnl_sf_gamma_inc_P, <a 
href="pnl-manual.html#dx1-140002" >576</a> <br /></span>
<span class="index-item">pnl_sf_gamma_inc_Q, <a 
href="pnl-manual.html#dx1-140003" >577</a> <br /></span>
<span class="index-item">pnl_sf_hyperg_0F1, <a 
href="pnl-manual.html#dx1-142004" >578</a> <br /></span>
<span class="index-item">pnl_sf_hyperg_1F1, <a 
href="pnl-manual.html#dx1-142002" >579</a> <br /></span>
<span class="index-item">pnl_sf_hyperg_2F0, <a 
href="pnl-manual.html#dx1-142003" >580</a> <br /></span>
<span class="index-item">pnl_sf_hyperg_2F1, <a 
href="pnl-manual.html#dx1-142001" >581</a> <br /></span>
<span class="index-item">pnl_sf_hyperg_U, <a 
href="pnl-manual.html#dx1-142005" >582</a> <br /></span>
<span class="index-item">pnl_sf_log_erf, <a 
href="pnl-manual.html#dx1-137013" >583</a> <br /></span>
<span class="index-item">pnl_sf_log_erfc, <a 
href="pnl-manual.html#dx1-137014" >584</a> <br /></span>
<span class="index-item">pnl_sf_log_gamma, <a 
href="pnl-manual.html#dx1-138003" >585</a> <br /></span>
<span class="index-item">pnl_sf_log_gamma_sgn, <a 
href="pnl-manual.html#dx1-138004" >586</a> <br /></span>
<span class="index-item">pnl_sf_psi, <a 
href="pnl-manual.html#dx1-139001" >587</a> <br /></span>
<span class="index-item">pnl_sf_w, <a 
href="pnl-manual.html#dx1-137007" >588</a> <br /></span>
<span class="index-item">pnl_sf_w_im, <a 
href="pnl-manual.html#dx1-137008" >589</a> <br /></span>
<span class="index-item">PNL_SIGN, <a 
href="pnl-manual.html#dx1-18007" >590</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_sp_mat_clone, <a 
href="pnl-manual.html#dx1-81003" >591</a> <br /></span>
<span class="index-item">pnl_sp_mat_copy, <a 
href="pnl-manual.html#dx1-81004" >592</a> <br /></span>
<span class="index-item">pnl_sp_mat_create, <a 
href="pnl-manual.html#dx1-81002" >593</a> <br /></span>
<span class="index-item">pnl_sp_mat_create_from_file, <a 
href="pnl-manual.html#dx1-81009" >594</a> <br /></span>
<span class="index-item">pnl_sp_mat_create_from_mat, <a 
href="pnl-manual.html#dx1-81008" >595</a> <br /></span>
<span class="index-item">pnl_sp_mat_div_scalar, <a 
href="pnl-manual.html#dx1-83004" >596</a> <br /></span>
<span class="index-item">pnl_sp_mat_fprint, <a 
href="pnl-manual.html#dx1-84001" >597</a> <br /></span>
<span class="index-item">pnl_sp_mat_free, <a 
href="pnl-manual.html#dx1-81005" >598</a> <br /></span>
<span class="index-item">pnl_sp_mat_get, <a 
href="pnl-manual.html#dx1-82002" >599</a> <br /></span>
<span class="index-item">pnl_sp_mat_isequal, <a 
href="pnl-manual.html#dx1-85001" >600</a> <br /></span>
<span class="index-item">pnl_sp_mat_isequal_abs, <a 
href="pnl-manual.html#dx1-85002" >601</a> <br /></span>
<span class="index-item">pnl_sp_mat_isequal_rel, <a 
href="pnl-manual.html#dx1-85003" >602</a> <br /></span>
<span class="index-item">pnl_sp_mat_kron, <a 
href="pnl-manual.html#dx1-84008" >603</a> <br /></span>
<span class="index-item">pnl_sp_mat_kron_inplace, <a 
href="pnl-manual.html#dx1-84007" >604</a> <br /></span>
<span class="index-item">pnl_sp_mat_lAxpby, <a 
href="pnl-manual.html#dx1-84004" >605</a> <br /></span>
<span class="index-item">pnl_sp_mat_minus_scalar, <a 
href="pnl-manual.html#dx1-83002" >606</a> <br /></span>
<span class="index-item">pnl_sp_mat_mult_scalar, <a 
href="pnl-manual.html#dx1-83003" >607</a> <br /></span>
<span class="index-item">pnl_sp_mat_mult_vect, <a 
href="pnl-manual.html#dx1-84003" >608</a> <br /></span>
<span class="index-item">pnl_sp_mat_new, <a 
href="pnl-manual.html#dx1-81001" >609</a> <br /></span>
<span class="index-item">PNL_SP_MAT_OBJECT, <a 
href="pnl-manual.html#dx1-12006" >610</a> <br /></span>
<span class="index-item">pnl_sp_mat_plus_scalar, <a 
href="pnl-manual.html#dx1-83001" >611</a> <br /></span>
<span class="index-item">pnl_sp_mat_plus_sp_mat_inplace, <a 
href="pnl-manual.html#dx1-84005" >612</a> <br /></span>
<span class="index-item">pnl_sp_mat_print, <a 
href="pnl-manual.html#dx1-84002" >613</a> <br /></span>
<span class="index-item">pnl_sp_mat_resize, <a 
href="pnl-manual.html#dx1-81006" >614</a> <br /></span>
<span class="index-item">pnl_sp_mat_set, <a 
href="pnl-manual.html#dx1-82001" >615</a> <br /></span>
<span class="index-item">pnl_sp_mat_sp_mat, <a 
href="pnl-manual.html#dx1-84006" >616</a> <br /></span>
<span class="index-item">pnl_tgamma, <a 
href="pnl-manual.html#dx1-21003" >617</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_clone, <a 
href="pnl-manual.html#dx1-65009" >618</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_copy, <a 
href="pnl-manual.html#dx1-65008" >619</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_create, <a 
href="pnl-manual.html#dx1-65002" >620</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_create_from_mat, <a 
href="pnl-manual.html#dx1-65006" >621</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_create_from_ptr, <a 
href="pnl-manual.html#dx1-65005" >622</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_create_from_scalar, <a 
href="pnl-manual.html#dx1-65003" >623</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_create_from_two_scalar, <a 
href="pnl-manual.html#dx1-65004" >624</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_div_scalar, <a 
href="pnl-manual.html#dx1-68006" >625</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_div_tridiag_mat_term, <a 
href="pnl-manual.html#dx1-69002" >626</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_fprint, <a 
href="pnl-manual.html#dx1-67001" >627</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_free, <a 
href="pnl-manual.html#dx1-65010" >628</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_get, <a 
href="pnl-manual.html#dx1-66002" >629</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lAxpby, <a 
href="pnl-manual.html#dx1-70003" >630</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lget, <a 
href="pnl-manual.html#dx1-66003" >631</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lu_clone, <a 
href="pnl-manual.html#dx1-70010" >632</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lu_compute, <a 
href="pnl-manual.html#dx1-70013" >633</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lu_copy, <a 
href="pnl-manual.html#dx1-70009" >634</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lu_create, <a 
href="pnl-manual.html#dx1-70008" >635</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lu_free, <a 
href="pnl-manual.html#dx1-70011" >636</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lu_new, <a 
href="pnl-manual.html#dx1-70007" >637</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_tridiag_mat_lu_resize, <a 
href="pnl-manual.html#dx1-70012" >638</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lu_syslin, <a 
href="pnl-manual.html#dx1-70015" >639</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_lu_syslin_inplace, <a 
href="pnl-manual.html#dx1-70014" >640</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_map_inplace, <a 
href="pnl-manual.html#dx1-69003" >641</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_map_tridiag_mat_inplace, <a 
href="pnl-manual.html#dx1-69004" >642</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_minus_scalar, <a 
href="pnl-manual.html#dx1-68004" >643</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_minus_tridiag_mat, <a 
href="pnl-manual.html#dx1-68002" >644</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_mult_scalar, <a 
href="pnl-manual.html#dx1-68005" >645</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_mult_tridiag_mat_term, <a 
href="pnl-manual.html#dx1-69001" >646</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_mult_vect, <a 
href="pnl-manual.html#dx1-70002" >647</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_mult_vect_inplace, <a 
href="pnl-manual.html#dx1-70001" >648</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_new, <a 
href="pnl-manual.html#dx1-65001" >649</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_plus_scalar, <a 
href="pnl-manual.html#dx1-68003" >650</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_plus_tridiag_mat, <a 
href="pnl-manual.html#dx1-68001" >651</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_print, <a 
href="pnl-manual.html#dx1-67002" >652</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_resize, <a 
href="pnl-manual.html#dx1-65011" >653</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_scalar_prod, <a 
href="pnl-manual.html#dx1-70004" >654</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_set, <a 
href="pnl-manual.html#dx1-66001" >655</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_syslin, <a 
href="pnl-manual.html#dx1-70006" >656</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_syslin_inplace, <a 
href="pnl-manual.html#dx1-70005" >657</a> <br /></span>
<span class="index-item">pnl_tridiag_mat_to_mat, <a 
href="pnl-manual.html#dx1-65007" >658</a> <br /></span>
<span class="index-item">PNL_TRIDIAGMAT_OBJECT, <a 
href="pnl-manual.html#dx1-12009" >659</a> <br /></span>
<span class="index-item">pnl_trunc, <a 
href="pnl-manual.html#dx1-20003" >660</a> <br /></span>
<span class="index-item">pnl_vect_axpby, <a 
href="pnl-manual.html#dx1-37010" >661</a> <br /></span>
<span class="index-item">pnl_vect_clone, <a 
href="pnl-manual.html#dx1-32010" >662</a> <br /></span>
<span class="index-item">pnl_vect_compact_copy, <a 
href="pnl-manual.html#dx1-45005" >663</a> <br /></span>
<span class="index-item">pnl_vect_compact_create, <a 
href="pnl-manual.html#dx1-45002" >664</a> <br /></span>
<span class="index-item">pnl_vect_compact_create_from_ptr, <a 
href="pnl-manual.html#dx1-45003" >665</a> <br /></span>
<span class="index-item">pnl_vect_compact_free, <a 
href="pnl-manual.html#dx1-45006" >666</a> <br /></span>
<span class="index-item">pnl_vect_compact_get, <a 
href="pnl-manual.html#dx1-45008" >667</a> <br /></span>
<span class="index-item">pnl_vect_compact_new, <a 
href="pnl-manual.html#dx1-45001" >668</a> <br /></span>
<span class="index-item">pnl_vect_compact_resize, <a 
href="pnl-manual.html#dx1-45004" >669</a> <br /></span>
<span class="index-item">pnl_vect_compact_set_all, <a 
href="pnl-manual.html#dx1-45009" >670</a> <br /></span>
<span class="index-item">pnl_vect_compact_set_ptr, <a 
href="pnl-manual.html#dx1-45010" >671</a> <br /></span>
<span class="index-item">pnl_vect_compact_to_pnl_vect, <a 
href="pnl-manual.html#dx1-45007" >672</a> <br /></span>
<span class="index-item">pnl_vect_complex_create_from_array, <a 
href="pnl-manual.html#dx1-42002" >673</a> <br /></span>
<span class="index-item">pnl_vect_complex_get_imag, <a 
href="pnl-manual.html#dx1-42006" >674</a> <br /></span>
<span class="index-item">pnl_vect_complex_get_real, <a 
href="pnl-manual.html#dx1-42005" >675</a> <br /></span>
<span class="index-item">pnl_vect_complex_lget_imag, <a 
href="pnl-manual.html#dx1-42008" >676</a> <br /></span>
<span class="index-item">pnl_vect_complex_lget_real, <a 
href="pnl-manual.html#dx1-42007" >677</a> <br /></span>
<span class="index-item">pnl_vect_complex_mult_double, <a 
href="pnl-manual.html#dx1-42001" >678</a> <br /></span>
<span class="index-item">pnl_vect_complex_set_imag, <a 
href="pnl-manual.html#dx1-42010" >679</a> <br /></span>
<span class="index-item">pnl_vect_complex_set_real, <a 
href="pnl-manual.html#dx1-42009" >680</a> <br /></span>
<span class="index-item">pnl_vect_complex_split_in_array, <a 
href="pnl-manual.html#dx1-42003" >681</a> <br /></span>
<span class="index-item">pnl_vect_complex_split_in_vect, <a 
href="pnl-manual.html#dx1-42004" >682</a> <br /></span>
<span class="index-item">pnl_vect_copy, <a 
href="pnl-manual.html#dx1-32009" >683</a> <br /></span>
<span class="index-item">pnl_vect_create, <a 
href="pnl-manual.html#dx1-32002" >684</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_vect_create_from_file, <a 
href="pnl-manual.html#dx1-32008" >685</a> <br /></span>
<span class="index-item">pnl_vect_create_from_list, <a 
href="pnl-manual.html#dx1-32007" >686</a> <br /></span>
<span class="index-item">pnl_vect_create_from_mat, <a 
href="pnl-manual.html#dx1-32006" >687</a> <br /></span>
<span class="index-item">pnl_vect_create_from_ptr, <a 
href="pnl-manual.html#dx1-32005" >688</a> <br /></span>
<span class="index-item">pnl_vect_create_from_scalar, <a 
href="pnl-manual.html#dx1-32004" >689</a> <br /></span>
<span class="index-item">pnl_vect_create_from_zero, <a 
href="pnl-manual.html#dx1-32003" >690</a> <br /></span>
<span class="index-item">pnl_vect_create_submat, <a 
href="pnl-manual.html#dx1-49016" >691</a> <br /></span>
<span class="index-item">pnl_vect_create_subvect, <a 
href="pnl-manual.html#dx1-32013" >692</a> <br /></span>
<span class="index-item">pnl_vect_create_subvect_with_ind, <a 
href="pnl-manual.html#dx1-32011" >693</a> <br /></span>
<span class="index-item">pnl_vect_cross, <a 
href="pnl-manual.html#dx1-38005" >694</a> <br /></span>
<span class="index-item">pnl_vect_cumprod, <a 
href="pnl-manual.html#dx1-37014" >695</a> <br /></span>
<span class="index-item">pnl_vect_cumsum, <a 
href="pnl-manual.html#dx1-37012" >696</a> <br /></span>
<span class="index-item">pnl_vect_dist, <a 
href="pnl-manual.html#dx1-38006" >697</a> <br /></span>
<span class="index-item">pnl_vect_div_scalar, <a 
href="pnl-manual.html#dx1-36005" >698</a> <br /></span>
<span class="index-item">pnl_vect_div_vect_term, <a 
href="pnl-manual.html#dx1-37004" >699</a> <br /></span>
<span class="index-item">pnl_vect_eq_all, <a 
href="pnl-manual.html#dx1-39004" >700</a> <br /></span>
<span class="index-item">pnl_vect_extract_submat, <a 
href="pnl-manual.html#dx1-49017" >701</a> <br /></span>
<span class="index-item">pnl_vect_extract_subvect, <a 
href="pnl-manual.html#dx1-32014" >702</a> <br /></span>
<span class="index-item">pnl_vect_extract_subvect_with_ind, <a 
href="pnl-manual.html#dx1-32012" >703</a> <br /></span>
<span class="index-item">pnl_vect_find, <a 
href="pnl-manual.html#dx1-40009" >704</a> <br /></span>
<span class="index-item">pnl_vect_fprint, <a 
href="pnl-manual.html#dx1-35002" >705</a> <br /></span>
<span class="index-item">pnl_vect_fprint_asrow, <a 
href="pnl-manual.html#dx1-35004" >706</a> <br /></span>
<span class="index-item">pnl_vect_fprint_nsp, <a 
href="pnl-manual.html#dx1-35006" >707</a> <br /></span>
<span class="index-item">pnl_vect_free, <a 
href="pnl-manual.html#dx1-32016" >708</a> <br /></span>
<span class="index-item">pnl_vect_get, <a 
href="pnl-manual.html#dx1-34008" >709</a> <br /></span>
<span class="index-item">pnl_vect_inv_term, <a 
href="pnl-manual.html#dx1-37003" >710</a> <br /></span>
<span class="index-item">pnl_vect_isequal, <a 
href="pnl-manual.html#dx1-39001" >711</a> <br /></span>
<span class="index-item">pnl_vect_isequal_abs, <a 
href="pnl-manual.html#dx1-39002" >712</a> <br /></span>
<span class="index-item">pnl_vect_isequal_rel, <a 
href="pnl-manual.html#dx1-39003" >713</a> <br /></span>
<span class="index-item">pnl_vect_lget, <a 
href="pnl-manual.html#dx1-34009" >714</a> <br /></span>
<span class="index-item">pnl_vect_map, <a 
href="pnl-manual.html#dx1-37006" >715</a> <br /></span>
<span class="index-item">pnl_vect_map_inplace, <a 
href="pnl-manual.html#dx1-37007" >716</a> <br /></span>
<span class="index-item">pnl_vect_map_vect, <a 
href="pnl-manual.html#dx1-37008" >717</a> <br /></span>
<span class="index-item">pnl_vect_map_vect_inplace, <a 
href="pnl-manual.html#dx1-37009" >718</a> <br /></span>
<span class="index-item">pnl_vect_max, <a 
href="pnl-manual.html#dx1-40001" >719</a> <br /></span>
<span class="index-item">pnl_vect_max_index, <a 
href="pnl-manual.html#dx1-40005" >720</a> <br /></span>
<span class="index-item">pnl_vect_min, <a 
href="pnl-manual.html#dx1-40002" >721</a> <br /></span>
<span class="index-item">pnl_vect_min_index, <a 
href="pnl-manual.html#dx1-40004" >722</a> <br /></span>
<span class="index-item">pnl_vect_minmax, <a 
href="pnl-manual.html#dx1-40003" >723</a> <br /></span>
<span class="index-item">pnl_vect_minmax_index, <a 
href="pnl-manual.html#dx1-40006" >724</a> <br /></span>
<span class="index-item">pnl_vect_minus, <a 
href="pnl-manual.html#dx1-36001" >725</a> <br /></span>
<span class="index-item">pnl_vect_minus_scalar, <a 
href="pnl-manual.html#dx1-36003" >726</a> <br /></span>
<span class="index-item">pnl_vect_minus_vect, <a 
href="pnl-manual.html#dx1-37002" >727</a> <br /></span>
<span class="index-item">pnl_vect_mult_scalar, <a 
href="pnl-manual.html#dx1-36004" >728</a> <br /></span>
<span class="index-item">pnl_vect_mult_vect_term, <a 
href="pnl-manual.html#dx1-37005" >729</a> <br /></span>
<span class="index-item">pnl_vect_new, <a 
href="pnl-manual.html#dx1-32001" >730</a> <br /></span>
<span class="index-item">pnl_vect_norm_infty, <a 
href="pnl-manual.html#dx1-38003" >731</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">pnl_vect_norm_one, <a 
href="pnl-manual.html#dx1-38002" >732</a> <br /></span>
<span class="index-item">pnl_vect_norm_two, <a 
href="pnl-manual.html#dx1-38001" >733</a> <br /></span>
<span class="index-item">PNL_VECT_OBJECT, <a 
href="pnl-manual.html#dx1-12004" >734</a> <br /></span>
<span class="index-item">pnl_vect_permute, <a 
href="pnl-manual.html#dx1-61006" >735</a> <br /></span>
<span class="index-item">pnl_vect_permute_inplace, <a 
href="pnl-manual.html#dx1-61007" >736</a> <br /></span>
<span class="index-item">pnl_vect_permute_inverse, <a 
href="pnl-manual.html#dx1-61008" >737</a> <br /></span>
<span class="index-item">pnl_vect_permute_inverse_inplace, <a 
href="pnl-manual.html#dx1-61009" >738</a> <br /></span>
<span class="index-item">pnl_vect_plus_scalar, <a 
href="pnl-manual.html#dx1-36002" >739</a> <br /></span>
<span class="index-item">pnl_vect_plus_vect, <a 
href="pnl-manual.html#dx1-37001" >740</a> <br /></span>
<span class="index-item">pnl_vect_print, <a 
href="pnl-manual.html#dx1-35001" >741</a> <br /></span>
<span class="index-item">pnl_vect_print_asrow, <a 
href="pnl-manual.html#dx1-35003" >742</a> <br /></span>
<span class="index-item">pnl_vect_print_nsp, <a 
href="pnl-manual.html#dx1-35005" >743</a> <br /></span>
<span class="index-item">pnl_vect_prod, <a 
href="pnl-manual.html#dx1-37013" >744</a> <br /></span>
<span class="index-item">pnl_vect_qsort, <a 
href="pnl-manual.html#dx1-40007" >745</a> <br /></span>
<span class="index-item">pnl_vect_qsort_index, <a 
href="pnl-manual.html#dx1-40008" >746</a> <br /></span>
<span class="index-item">pnl_vect_rand_normal, <a 
href="pnl-manual.html#dx1-103016" >747</a> <br /></span>
<span class="index-item">pnl_vect_rand_normal_d, <a 
href="pnl-manual.html#dx1-103018" >748</a> <br /></span>
<span class="index-item">pnl_vect_rand_uni, <a 
href="pnl-manual.html#dx1-103015" >749</a> <br /></span>
<span class="index-item">pnl_vect_rand_uni_d, <a 
href="pnl-manual.html#dx1-103017" >750</a> <br /></span>
<span class="index-item">pnl_vect_resize, <a 
href="pnl-manual.html#dx1-33001" >751</a> <br /></span>
<span class="index-item">pnl_vect_resize_from_ptr, <a 
href="pnl-manual.html#dx1-33003" >752</a> <br /></span>
<span class="index-item">pnl_vect_resize_from_scalar, <a 
href="pnl-manual.html#dx1-33002" >753</a> <br /></span>
<span class="index-item">pnl_vect_reverse, <a 
href="pnl-manual.html#dx1-41002" >754</a> <br /></span>
<span class="index-item">pnl_vect_rng_bernoulli, <a 
href="pnl-manual.html#dx1-102029" >755</a> <br /></span>
<span class="index-item">pnl_vect_rng_bernoulli_d, <a 
href="pnl-manual.html#dx1-102030" >756</a> <br /></span>
<span class="index-item">pnl_vect_rng_normal, <a 
href="pnl-manual.html#dx1-102034" >757</a> <br /></span>
<span class="index-item">pnl_vect_rng_normal_d, <a 
href="pnl-manual.html#dx1-102036" >758</a> <br /></span>
<span class="index-item">pnl_vect_rng_poisson, <a 
href="pnl-manual.html#dx1-102031" >759</a> <br /></span>
<span class="index-item">pnl_vect_rng_poisson_d, <a 
href="pnl-manual.html#dx1-102032" >760</a> <br /></span>
<span class="index-item">pnl_vect_rng_uni, <a 
href="pnl-manual.html#dx1-102033" >761</a> <br /></span>
<span class="index-item">pnl_vect_rng_uni_d, <a 
href="pnl-manual.html#dx1-102035" >762</a> <br /></span>
<span class="index-item">pnl_vect_scalar_prod, <a 
href="pnl-manual.html#dx1-38004" >763</a> <br /></span>
<span class="index-item">pnl_vect_set, <a 
href="pnl-manual.html#dx1-34007" >764</a> <br /></span>
<span class="index-item">pnl_vect_set_all, <a 
href="pnl-manual.html#dx1-34010" >765</a> <br /></span>
<span class="index-item">pnl_vect_set_subblock, <a 
href="pnl-manual.html#dx1-32015" >766</a> <br /></span>
<span class="index-item">pnl_vect_set_zero, <a 
href="pnl-manual.html#dx1-34011" >767</a> <br /></span>
<span class="index-item">pnl_vect_sum, <a 
href="pnl-manual.html#dx1-37011" >768</a> <br /></span>
<span class="index-item">pnl_vect_swap_elements, <a 
href="pnl-manual.html#dx1-41001" >769</a> <br /></span>
<span class="index-item">pnl_vect_wrap_array, <a 
href="pnl-manual.html#dx1-32017" >770</a> <br /></span>
<span class="index-item">pnl_vect_wrap_hmat, <a 
href="pnl-manual.html#dx1-90005" >771</a> <br /></span>
<span class="index-item">pnl_vect_wrap_mat, <a 
href="pnl-manual.html#dx1-32020" >772</a> <br /></span>
<span class="index-item">pnl_vect_wrap_mat_row, <a 
href="pnl-manual.html#dx1-50017" >773</a> <br /></span>
<span class="index-item">pnl_vect_wrap_subvect, <a 
href="pnl-manual.html#dx1-32018" >774</a> <br /></span>
<span class="index-item">pnl_vect_wrap_subvect_with_last, <a 
href="pnl-manual.html#dx1-32019" >775</a> <br /></span>
</p><p class="theindex">
<span class="index-item">RCadd, <a 
href="pnl-manual.html#dx1-26008" >776</a> <br /></span>
                                                                                    

                                                                                    
<span class="index-item">RCdiv, <a 
href="pnl-manual.html#dx1-26017" >777</a> <br /></span>
<span class="index-item">RCmul, <a 
href="pnl-manual.html#dx1-26014" >778</a> <br /></span>
<span class="index-item">RCsub, <a 
href="pnl-manual.html#dx1-26011" >779</a> <br /></span>
</p><p class="theindex">
<span class="index-item">SQR, <a 
href="pnl-manual.html#dx1-18008" >780</a> <br /></span>
<span class="index-item">Structs <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlArray, <a 
href="pnl-manual.html#dx1-14001" >781</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlBandMat, <a 
href="pnl-manual.html#dx1-72001" >782</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlBasis, <a 
href="pnl-manual.html#dx1-105001" >783</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlBicgSolver, <a 
href="pnl-manual.html#dx1-94003" >784</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlCell, <a 
href="pnl-manual.html#dx1-13002" >785</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlCgSolver, <a 
href="pnl-manual.html#dx1-94002" >786</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlCmplxFunc, <a 
href="pnl-manual.html#dx1-118001" >787</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlFunc, <a 
href="pnl-manual.html#dx1-130001" >788</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlFunc2D, <a 
href="pnl-manual.html#dx1-130002" >789</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlFuncDFunc, <a 
href="pnl-manual.html#dx1-130003" >790</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlGmresSolver, <a 
href="pnl-manual.html#dx1-94004" >791</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlHmat, <a 
href="pnl-manual.html#dx1-87001" >792</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlHmatComplex, <a 
href="pnl-manual.html#dx1-87003" >793</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlHmatInt, <a 
href="pnl-manual.html#dx1-87002" >794</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlIterationBase, <a 
href="pnl-manual.html#dx1-94001" >795</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlList, <a 
href="pnl-manual.html#dx1-13001" >796</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlMat, <a 
href="pnl-manual.html#dx1-47001" >797</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlMatComplex, <a 
href="pnl-manual.html#dx1-47003" >798</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlMatInt, <a 
href="pnl-manual.html#dx1-47002" >799</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlObject, <a 
href="pnl-manual.html#dx1-12001" >800</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlODEFunc, <a 
href="pnl-manual.html#dx1-120001" >801</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlPermutation, <a 
href="pnl-manual.html#dx1-61001" >802</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlRnFuncR, <a 
href="pnl-manual.html#dx1-130004" >803</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlRnFuncRm, <a 
href="pnl-manual.html#dx1-130005" >804</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlRnFuncRmDFunc, <a 
href="pnl-manual.html#dx1-130007" >805</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlRnFuncRn, <a 
href="pnl-manual.html#dx1-130006" >806</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlRnFuncRnDFunc, <a 
href="pnl-manual.html#dx1-130008" >807</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlRng, <a 
href="pnl-manual.html#dx1-102001" >808</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlSpMat, <a 
href="pnl-manual.html#dx1-79001" >809</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlSpMatComplex, <a 
href="pnl-manual.html#dx1-79003" >810</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlSpMatInt, <a 
href="pnl-manual.html#dx1-79002" >811</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlTridiagMat, <a 
href="pnl-manual.html#dx1-63001" >812</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlTridiagMatLU, <a 
href="pnl-manual.html#dx1-63002" >813</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVect, <a 
href="pnl-manual.html#dx1-29001" >814</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVectCompact, <a 
href="pnl-manual.html#dx1-44001" >815</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVectComplex, <a 
href="pnl-manual.html#dx1-29003" >816</a> <br /></span>
<span class="index-subitem">&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVectInt, <a 
href="pnl-manual.html#dx1-29002" >817</a> <br /></span>
</p></div>
 
</body></html> 

                                                                                    


