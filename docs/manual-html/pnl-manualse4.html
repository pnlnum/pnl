<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  
<!--http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd-->  
<html xmlns="http://www.w3.org/1999/xhtml"  
> 
<head><title>Linear Algebra</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="originator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<!-- xhtml,uni-html4,2,subsection+,next,html --> 
<meta name="src" content="pnl-manual.tex" /> 
<link rel="stylesheet" type="text/css" href="pnl-manual.css" /> 
</head><body 
>
<!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="pnl-manualse5.html" >next</a>] [<a 
href="pnl-manualse3.html" >prev</a>] [<a 
href="pnl-manualse3.html#tailpnl-manualse3.html" >prev-tail</a>] [<a 
href="#tailpnl-manualse4.html">tail</a>] [<a 
href="pnl-manual.html#pnl-manualse4.html" >up</a>] </p></div>
<h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x6-270004"></a>Linear Algebra</h3>
<!--l. 4--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.1   </span> <a 
 id="x6-280004.1"></a>Vectors</h4>
<!--l. 5--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.1.1   </span> <a 
 id="x6-290004.1.1"></a>Overview</h5>
<!--l. 7--><p class="noindent" >The structures and functions related to vectors are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_vector.h</span></span></span>.
</p><!--l. 11--><p class="noindent" >Vectors are declared for several basic types : double, int, and dcomplex. In the following
declarations, <span 
class="ec-lmtt-10x-x-109">BASE </span>must be replaced by one the previous types and the corresponding vector
structures are respectively named PnlVect, PnlVectInt, PnlVectComplex <a 
 id="dx6-29001"></a><a 
 id="dx6-29002"></a><a 
 id="dx6-29003"></a>
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-15">
typedef&#x00A0;struct&#x00A0;_PnlVect&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVect&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;vector&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlVect;
&#x00A0;<br />
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;_PnlVectInt&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVectInt&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;vector&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlVectInt;
&#x00A0;<br />
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;_PnlVectComplex&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVectComplex&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;vector&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;dcomplex&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlVectComplex;
</div>
<!--l. 53--><p class="nopar" ><span class='var'>size</span> is the size of the vector, <span class='var'>array</span> is a pointer containing the data and <span class='var'>owner</span> is an integer to know
if the vector owns its <span class='var'>array</span> pointer (<span class='var'>owner=1</span>) or shares it with another structure (<span class='var'>owner=0</span>).
<span class='var'>mem_size</span> is the number of elements the vector can hold at most.
</p><!--l. 59--><p class="noindent" >
                                                                                    

                                                                                    
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.1.2   </span> <a 
 id="x6-300004.1.2"></a>Functions</h5>
<!--l. 61--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-310004.1.2"></a><span 
class="ec-lmbx-10x-x-109">General functions</span></span>
These functions exist for all types of vector no matter what the basic type is. The following
conventions are used to name functions operating on vectors. Here is the table of prefixes used for
the different basic types.
</p>
<div class="center" 
>
<!--l. 66--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-6" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-6-1g"><col 
id="TBL-6-1" /><col 
id="TBL-6-2" /><col 
id="TBL-6-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-6-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-1"  
class="td11">type      </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-2"  
class="td11">prefix                 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-3"  
class="td11">BASE    </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-1"  
class="td11">double    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-2"  
class="td11">pnl_vect             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-3"  
class="td11">double    </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-1"  
class="td11">int         </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-2"  
class="td11">pnl_vect_int       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-3"  
class="td11">int         </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-1"  
class="td11">dcomplex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-2"  
class="td11">pnl_vect_complex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-3"  
class="td11">dcomplex</td></tr></table></div></div>
<!--l. 78--><p class="noindent" >In this paragraph, we present the functions operating on <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> which exist for all types. To
deduce the prototypes of these functions for other basic types, one must replace <span 
class="ec-lmtt-10x-x-109">pnl_vect </span>and
<span 
class="ec-lmtt-10x-x-109">double </span>according the above table.
</p>
<!--l. 82--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-320004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
There are no special functions to access the size of a vector, instead the field <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">size</span></span></span> should be
accessed directly.
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-32001"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> of size 0.
     </li>
     <li class="itemize"><a 
 id="dx6-32002"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create</span></span>&#x00A0;(<span class='args'>int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> pointer.
     </li>
     <li class="itemize"><a 
 id="dx6-32003"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_zero</span></span>&#x00A0;(<span class='args'>int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> pointer and sets it to zero.
     </li>
     <li class="itemize"><a 
 id="dx6-32004"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_scalar</span></span>&#x00A0;(<span class='args'>int size, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> pointer and sets all elements t <span class='var'>x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-32005"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_ptr</span></span>&#x00A0;(<span class='args'>int size, const double <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> pointer and copies <span class='var'>x</span> to <span class='var'>array</span>.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-32006"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_mat</span></span>&#x00A0;(<span class='args'> const PnlMat *M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> pointer of size <span class='var'>M-&#x003E;mn</span> and copy the content of <span class='var'>M</span>
     row wise.
     </li>
     <li class="itemize"><a 
 id="dx6-32007"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_list</span></span>&#x00A0;(<span class='args'>int size, ...</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create  a  new  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  pointer  of  length  <span class='var'>size</span>  filled  with  the  extra
     arguments  passed  to  the  function.  The  number  of  extra  arguments  passed  must
     be  equal  to  <span class='var'>size</span>  and  they  must  be  of  the  type  BASE.  Example:  To  create  a
     vector  {1.,  2.},  you  should  enter  pnl_vect_create_from_list(2,  1.0,  2.0)  and  NOT
     pnl_vect_create_from_list(2,  1.0,  2)  or  pnl_vect_create_from_list(2,  1,  2.0).  Be
     aware that this cannot be checked inside the function.
     </li>
     <li class="itemize"><a 
 id="dx6-32008"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_from_file</span></span>&#x00A0;(<span class='args'>const char <span 
class="ts1-lmr10-x-x-109">*</span>file</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Read a vector from a file and creates the corresponding <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> . The
     data might be stored as a row or column vector. Entries can be separated by spaces,
     tabs, commas or semicolons. Anything after a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">#</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">%</span></span></span> is ignored up to the end of the
     line.
     </li>
     <li class="itemize"><a 
 id="dx6-32009"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>This is a copying constructor. It creates a copy of a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-32010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> . <span class='var'>clone</span> must be an already existing <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> . It is resized
     to match the size of <span class='var'>v</span> and the data are copied. Future modifications to <span class='var'>v</span> will not affect
     <span class='var'>clone</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-32011"></a>   <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_subvect_with_ind</span></span>&#x00A0;(<span class='args'>const   <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>V,   const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>ind</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new vector containing <span class='var'>V(ind(:))</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-32012"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_extract_subvect_with_ind</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>V_sub,  const  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>V, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>ind</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>V_sub = V(ind(:))</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-32013"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_subvect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int i, int len</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new vector containing <span class='var'>V(i:i+len-1)</span>. The elements are copied.
     </li>
     <li class="itemize"><a 
 id="dx6-32014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_extract_subvect</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V_sub, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int i, int
     len</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>V_sub = V(i:i+len-1)</span>. The elements are copied.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-32015"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> pointer and set the data pointer to NULL
     </li>
     <li class="itemize"><a 
 id="dx6-32016"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_array</span></span>&#x00A0;(<span class='args'>const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> containing the data <span class='var'>x</span>. No copy is made. It is just a
     container.
     </li>
     <li class="itemize"><a 
 id="dx6-32017"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_subvect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int s</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> containing <span class='var'>x(i:i+s-1)</span>. No copy is made. It is just a
     container. The returned <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> has <span class='var'>size=s</span> and <span class='var'>owner=0</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-32018"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_subvect_with_last</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> containing <span class='var'>x(i:j)</span>. No copy is made. It is just a container.
     </li>
     <li class="itemize"><a 
 id="dx6-32019"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> (not a pointer) whose array is the row wise array of <span class='var'>M</span>.
     The new vector shares its data with the matrix <span class='var'>M</span>, which means that any modification
     to one of them will affect the other.</li></ul>
<!--l. 171--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-330004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Resizing vectors</span></span> </p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-33001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> . It copies as much of the old data to fit in the resized
     object.
     </li>
     <li class="itemize"><a 
 id="dx6-33002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_resize_from_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size, double <span 
class="ts1-lmr10-x-x-109">*</span>t</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> and uses <span class='var'>t</span> to fill the vector. <span class='var'>t</span> must be of size <span class='var'>size</span>.</li></ul>
<!--l. 182--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-340004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements</span></span>
If it is supported by the compiler, the following functions are declared inline. To speed up these
functions, you can define the macro <span 
class="ec-lmtt-10x-x-109">PNL_RANGE_CHECK_OFF</span>, see Section&#x00A0;<a 
href="pnl-manualse1.html#x3-100001.3.2">1.3.2<!--tex4ht:ref: sec:inline --></a> for an
explanation.
</p><!--l. 188--><p class="noindent" >Accessing elements of a vector is faster using the following macros </p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-34001"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>v[i]</span> for reading, eg. <span class='var'>x=GET(v,i)</span>
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-34002"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET_INT</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x6-340004.1.2">GET</a> but for an integer vector.
     </li>
     <li class="itemize"><a 
 id="dx6-34003"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET_COMPLEX</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x6-340004.1.2">GET</a> but for a complex vector.
     </li>
     <li class="itemize"><a 
 id="dx6-34004"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>v[i]</span> as a lvalue for writing, eg. <span class='var'>LET(v,i)=x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-34005"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET_INT</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x6-340004.1.2">LET</a> but for an integer vector.
     </li>
     <li class="itemize"><a 
 id="dx6-34006"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET_COMPLEX</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x6-340004.1.2">LET</a> but for a complex vector.</li></ul>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-34007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_set</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set v[i]=x.
     </li>
     <li class="itemize"><a 
 id="dx6-34008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the value of v[i].
     </li>
     <li class="itemize"><a 
 id="dx6-34009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address of v[i].
     </li>
     <li class="itemize"><a 
 id="dx6-34010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_set_all</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements to x.
     </li>
     <li class="itemize"><a 
 id="dx6-34011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_set_zero</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements to zero.</li></ul>
<!--l. 219--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-350004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Printing vector</span></span> </p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-35001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> as a column vector
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-35002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> in file <span class='var'>fic</span> as a column vector. The file can be read by
     <a 
href="#x6-320004.1.2">pnl_vect_create_from_file</a>.
     </li>
     <li class="itemize"><a 
 id="dx6-35003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_print_asrow</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> as a row vector
     </li>
     <li class="itemize"><a 
 id="dx6-35004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_fprint_asrow</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print  a  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  in  file  <span class='var'>fic</span>  as  a  row  vector.  The  file  can  be  read  by
     <a 
href="#x6-320004.1.2">pnl_vect_create_from_file</a>.
     </li>
     <li class="itemize"><a 
 id="dx6-35005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_print_nsp</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a vector to the standard output in a format compatible with Nsp.
     </li>
     <li class="itemize"><a 
 id="dx6-35006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_fprint_nsp</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a vector to a file in a format compatible with Nsp.</li></ul>
<!--l. 239--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-360004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Applying external operation to vectors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-36001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minus</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place unary minus
     </li>
     <li class="itemize"><a 
 id="dx6-36002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector scalar addition
     </li>
     <li class="itemize"><a 
 id="dx6-36003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector scalar substraction
     </li>
     <li class="itemize"><a 
 id="dx6-36004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector scalar multiplication
     </li>
     <li class="itemize"><a 
 id="dx6-36005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector scalar division</li></ul>
                                                                                    

                                                                                    
<!--l. 254--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-370004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Element wise operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-37001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_plus_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector vector addition
     </li>
     <li class="itemize"><a 
 id="dx6-37002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minus_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector vector substraction
     </li>
     <li class="itemize"><a 
 id="dx6-37003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_inv_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term vector inversion
     </li>
     <li class="itemize"><a 
 id="dx6-37004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_div_vect_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term vector division
     </li>
     <li class="itemize"><a 
 id="dx6-37005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_mult_vect_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place vector vector term by term multiplication
     </li>
     <li class="itemize"><a 
 id="dx6-37006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_map</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs)</span>
     </li>
     <li class="itemize"><a 
 id="dx6-37007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_map_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs)</span>
     </li>
     <li class="itemize"><a 
 id="dx6-37008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_map_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs1, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double, double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs1, rhs2)</span>
     </li>
     <li class="itemize"><a 
 id="dx6-37009"></a>       <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_map_vect_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>       <span 
class="ts1-lmr10-x-x-109">*</span>lhs,       <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>       <span 
class="ts1-lmr10-x-x-109">*</span>rhs,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double,double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs,rhs)</span>
     </li>
     <li class="itemize"><a 
 id="dx6-37010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_axpby</span></span>&#x00A0;(<span class='args'>double a, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double b, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>y : = a x + b y</span>. When <span class='var'>b==0</span>, the content of <span class='var'>y</span> is not used on
     input and instead <span class='var'>y</span> is resized to match <span class='var'>x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-37011"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_sum</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the sum of all the elements of a vector
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-37012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_cumsum</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the cumulative sum of all the elements of a vector. The original
     vector is modified
     </li>
     <li class="itemize"><a 
 id="dx6-37013"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_prod</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the product of all the elements of a vector
     </li>
     <li class="itemize"><a 
 id="dx6-37014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_cumprod</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the cumulative product of all the elements of a vector. The
     original vector is modified</li></ul>
<!--l. 312--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-380004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Scalar products and norms</span></span> </p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-38001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_norm_two</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the two norm of a vector
     </li>
     <li class="itemize"><a 
 id="dx6-38002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_norm_one</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the one norm of a vector
     </li>
     <li class="itemize"><a 
 id="dx6-38003"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_norm_infty</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the infinity norm of a vector
     </li>
     <li class="itemize"><a 
 id="dx6-38004"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_scalar_prod</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs1, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the scalar product between 2 vectors
     </li>
     <li class="itemize"><a 
 id="dx6-38005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_cross</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the cross product of <span class='var'>x</span> and <span class='var'>y</span> and store the result in <span class='var'>lhs</span>. The
     vectors <span class='var'>x</span> and <span class='var'>y</span> must be of size 3 and FAIL is returned otherwise.
     </li>
     <li class="itemize"><a 
 id="dx6-38006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_dist</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the distance between <span class='var'>x</span> and <span class='var'>y</span>, ie <img 
src="pnl-manual15x.png" alt="&#x2218; &#x2211;-----------
    i|xi - yi|2"  class="sqrt"  />.
     </li></ul>
<!--l. 338--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-390004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Comparison functions</span></span>
</p>
                                                                                    

                                                                                    
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-39001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_isequal</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V1, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V2, double err</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two vectors are equal up to <span class='var'>err</span> component&#8211;wise. The error <span class='var'>err</span>
     is either relative or absolute depending on the magnitude of the components. Return
     <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-39002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_isequal_abs</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V1, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V2, double abserr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test   if   two   vectors   are   equal   up   to   an   absolute   error   <span class='var'>abserr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-39003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_isequal_rel</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V1, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V2, double relerr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two vectors are equal up to a relative error <span class='var'>relerr</span> component&#8211;wise.
     Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-39004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_eq_all</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if all the components of <span class='var'>v</span> are equal to <span class='var'>x</span>. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.</li></ul>
<!--l. 352--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-400004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Ordering functions</span></span> The following functions are not defined for PnlVectComplex because there is
no total ordering on Complex numbers
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-40001"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_max</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the maximum of a a vector
     </li>
     <li class="itemize"><a 
 id="dx6-40002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_min</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the minimum of a vector
     </li>
     <li class="itemize"><a 
 id="dx6-40003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minmax</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>m, double <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the minimum and maximum of a vector which are returned in
     <span class='var'>m</span> and <span class='var'>M</span> respectively.
     </li>
     <li class="itemize"><a 
 id="dx6-40004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_min_index</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>m, int <span 
class="ts1-lmr10-x-x-109">*</span>im, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the minimum of a vector and its index stored in sets <span class='var'>m</span> and <span class='var'>im</span>
     respectively.
     </li>
     <li class="itemize"><a 
 id="dx6-40005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_max_index</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>M, int <span 
class="ts1-lmr10-x-x-109">*</span>iM, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the maximum of a vector and its index stored in sets <span class='var'>m</span> and
     <span class='var'>im</span> respectively.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-40006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_minmax_index</span></span>&#x00A0;(<span class='args'>double <span 
class="ts1-lmr10-x-x-109">*</span>m, double <span 
class="ts1-lmr10-x-x-109">*</span>M, int <span 
class="ts1-lmr10-x-x-109">*</span>im, int <span 
class="ts1-lmr10-x-x-109">*</span>iM, const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the minimum and maximum of a vector and the corresponding
     indices stored respectively in <span class='var'>m</span>, <span class='var'>M</span>, <span class='var'>im</span> and <span class='var'>iM</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-40007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_qsort</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, char order</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sort a vector using a quick sort algorithm according to <span class='var'>order</span> (<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;i&#8217;</span></span></span> for
     increasing or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;d&#8217;</span></span></span> for decreasing).
     </li>
     <li class="itemize"><a 
 id="dx6-40008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_qsort_index</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> *index, char order</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sort a vector using a quick sort algorithm according to <span class='var'>order</span> (<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;i&#8217;</span></span></span> for
     increasing or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;d&#8217;</span></span></span> for decreasing ). On output, <span class='var'>index</span> contains the permutation used to
     sort the vector.
     </li>
     <li class="itemize"><a 
 id="dx6-40009"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_find</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>ind, char <span 
class="ts1-lmr10-x-x-109">*</span>type, int(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double <span 
class="ts1-lmr10-x-x-109">*</span>t), &#x2026;</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>f</span> is a function taking a C array as argument and returning an integer. <span class='var'>type</span> is a
     string composed by the letters &#8217;r&#8217; and &#8217;v&#8217; and is used to describe the types of the arguments
     appearing after <span class='var'>f</span>. This function aims at simulating Scilab&#8217;s <span class='var'>find</span> function. Here
     are a few examples (capital letters are used for vectors and small letters for real
     values)
          <ul class="itemize2">
          <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">ind</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;a</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;)</span></span></span>
                                                                                    

                                                                                    
          <div class="verbatim" id="verbatim-16">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;isless&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)&#x00A0;{&#x00A0;return&#x00A0;t[0]&#x00A0;&#x003C;&#x00A0;t[1];&#x00A0;}
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_vect_find&#x00A0;(&#x00A0;ind,&#x00A0;"rv",&#x00A0;isless,&#x00A0;a,&#x00A0;X&#x00A0;);
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</div>
          <!--l. 404--><p class="nopar" >
          </p></li>
          <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">ind</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;Y)</span></span></span>
                                                                                    

                                                                                    
          <div class="verbatim" id="verbatim-17">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;isless&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)&#x00A0;{&#x00A0;return&#x00A0;t[0]&#x00A0;&#x003C;=&#x00A0;t[1];&#x00A0;}
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_vect_find&#x00A0;(&#x00A0;ind,&#x00A0;"vv",&#x00A0;isless,&#x00A0;X,&#x00A0;Y&#x00A0;);
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</div>
          <!--l. 409--><p class="nopar" >
          </p></li>
          <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">ind</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;((a</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;X)</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&amp;&amp;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;Y))</span></span></span>
                                                                                    

                                                                                    
          <div class="verbatim" id="verbatim-18">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;cmp&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;(t[0]&#x00A0;&#x003C;=&#x00A0;t[1])&#x00A0;&amp;&amp;&#x00A0;(t[1]&#x00A0;&#x003C;=&#x00A0;t[2]);
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_vect_find&#x00A0;(&#x00A0;ind,&#x00A0;"rvv",&#x00A0;cmp,&#x00A0;a,&#x00A0;X,&#x00A0;Y&#x00A0;);
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</div>
          <!--l. 417--><p class="nopar" ></p></li></ul>
     <!--l. 419--><p class="noindent" ><span class='var'>ind</span> contains on exit the indices <span class='var'>i</span> for which the function <span class='var'>f</span> returned <span class='var'>1</span>. This function returns <span class='var'>OK</span>
     or <span class='var'>FAIL</span> when something went wrong (size mismatch between matrices, invalid string
     type).
</p>
     </li></ul>
<!--l. 426--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-410004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Misc</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-41001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_swap_elements</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Exchange <span class='var'>v[i]</span> and <span class='var'>v[j]</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-41002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_reverse</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Perform a mirror operation on v. On output <span class='var'>v[i] = v[n-1-i]</span> for <span class='var'>i=0,&#x2026;,n-1</span>
     where <span class='var'>n</span> is the length of the vector.</li></ul>
<!--l. 438--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-420004.1.2"></a><span 
class="ec-lmbx-10x-x-109">Complex vector functions</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-42001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_mult_double</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place multiplication by a double.
     </li>
     <li class="itemize"><a 
 id="dx6-42002"></a>   <span class='ret'>PnlVectComplex<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_create_from_array</span></span>&#x00A0;(<span class='args'>int   size,   const
     double <span 
class="ts1-lmr10-x-x-109">*</span>re, const double <span 
class="ts1-lmr10-x-x-109">*</span>im</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create  a  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a>  given  the  arrays  of  the  real  parts  <span class='var'>re</span>  and
     imaginary parts <span class='var'>im</span>.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-42003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_split_in_array</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, double <span 
class="ts1-lmr10-x-x-109">*</span>re,
     double <span 
class="ts1-lmr10-x-x-109">*</span>im</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Split a complex vector into two C arrays : the real parts of the elements
     of <span class='var'>v</span> are stored into <span class='var'>re</span> and the imaginary parts into <span class='var'>im</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-42004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_split_in_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>re,
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>im</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Split a complex vector into two <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> &#8217;s : the real parts of the elements
     of <span class='var'>v</span> are stored into <span class='var'>re</span> and the imaginary parts into <span class='var'>im</span>.</li></ul>
<!--l. 461--><p class="noindent" >There exist functions to directly access the real or imaginary parts of an element of a complex
vector. These functions also have inlined versions that are used if the variable <span class='var'>HAVE_INLINE</span> was
declared at compilation time.
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-42005"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_get_real</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the real part of <span class='var'>v[i]</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-42006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_get_imag</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the imaginary part of <span class='var'>v[i]</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-42007"></a> <span class='ret'>double<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_lget_real</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the real part of <span class='var'>v[i]</span> as a lvalue.
     </li>
     <li class="itemize"><a 
 id="dx6-42008"></a> <span class='ret'>double<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_lget_imag</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the imaginary part of <span class='var'>v[i]</span> as a lvalue.
     </li>
     <li class="itemize"><a 
 id="dx6-42009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_set_real</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i, double re</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the real part of <span class='var'>v[i]</span> to <span class='var'>re</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-42010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_complex_set_imag</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int i, double im</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the imaginary part of <span class='var'>v[i]</span> to <span class='var'>im</span>.</li></ul>
<!--l. 491--><p class="noindent" >Equivalently to these functions, there exist macros. When the compiler is able to handle inline
code, there is no gain in using macros instead of inlined functions at least in principle.
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-42011"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET_REAL</span></span>&#x00A0;(<span class='args'>v, i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the real part of <span class='var'>v[i]</span>.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-42012"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">GET_IMAG</span></span>&#x00A0;(<span class='args'>v, i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the imaginary part of <span class='var'>v[i]</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-42013"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET_REAL</span></span>&#x00A0;(<span class='args'>v, i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the real part of <span class='var'>v[i]</span> as a lvalue.
     </li>
     <li class="itemize"><a 
 id="dx6-42014"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">LET_IMAG</span></span>&#x00A0;(<span class='args'>v, i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the imaginary part of <span class='var'>v[i]</span> as a lvalue.</li></ul>
<!--l. 508--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.2   </span> <a 
 id="x6-430004.2"></a>Compact Vectors</h4>
<!--l. 509--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.2.1   </span> <a 
 id="x6-440004.2.1"></a>Short description</h5>
<a 
 id="dx6-44001"></a>
                                                                                    

                                                                                    
<div class="verbatim" id="verbatim-19">
typedef&#x00A0;struct&#x00A0;PnlVectCompact&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVectCompact&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;vector&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;val;&#x00A0;/*&#x00A0;single&#x00A0;value&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*&#x00A0;Pointer&#x00A0;to&#x00A0;double&#x00A0;values&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;char&#x00A0;convert;&#x00A0;/*&#x00A0;&#8217;a&#8217;,&#x00A0;&#8217;d&#8217;&#x00A0;:&#x00A0;array,&#x00A0;double&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlVectCompact;
</div>
<!--l. 524--><p class="nopar" >
</p><!--l. 526--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.2.2   </span> <a 
 id="x6-450004.2.2"></a>Functions</h5>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-45001"></a> <span class='ret'><a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> of size 0.
     </li>
     <li class="itemize"><a 
 id="dx6-45002"></a> <span class='ret'><a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_create</span></span>&#x00A0;(<span class='args'>int n, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> filled in with <span class='var'>x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-45003"></a> <span class='ret'><a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_create_from_ptr</span></span>&#x00A0;(<span class='args'>int n, double *x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> filled in with the content of <span class='var'>x</span>. Note that <span class='var'>x</span>
     must have at least <span class='var'>n</span> elements.
     </li>
     <li class="itemize"><a 
 id="dx6-45004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-45005"></a> <span class='ret'><a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy a <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a>
     </li>
     <li class="itemize"><a 
 id="dx6-45006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a>
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-45007"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_to_pnl_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Convert a <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> pointer to a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> pointer.
     </li>
     <li class="itemize"><a 
 id="dx6-45008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Access function
     </li>
     <li class="itemize"><a 
 id="dx6-45009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_set_all</span></span>&#x00A0;(<span class='args'><a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements of <span class='var'>C</span> to <span class='var'>x</span>. <span class='var'>C</span> is converted to a compact storage.
     </li>
     <li class="itemize"><a 
 id="dx6-45010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_compact_set_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x6-440004.2.1"><span class='struct'>PnlVectCompact</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C, double <span 
class="ts1-lmr10-x-x-109">*</span>ptr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy the array <span class='var'>ptr</span> into <span class='var'>C</span>. We assume that the sizes match. <span class='var'>C</span> is converted
     to a non compact storage.</li></ul>
<!--l. 569--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.3   </span> <a 
 id="x6-460004.3"></a>Matrices</h4>
<!--l. 570--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.1   </span> <a 
 id="x6-470004.3.1"></a>Overview</h5>
<!--l. 572--><p class="noindent" >The structures and functions related to matrices are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_matrix.h</span></span></span>.
<a 
 id="dx6-47001"></a>
<a 
 id="dx6-47002"></a>
<a 
 id="dx6-47003"></a>
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-20">
typedef&#x00A0;struct&#x00A0;_PnlMat{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;m*n&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;row-wise&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlMat;
&#x00A0;<br />
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;_PnlMatInt{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlMatInt&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;m*n&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;row-wise&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlMatInt;
&#x00A0;<br />
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;_PnlMatComplex{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlMatComplex&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;m*n&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mem_size;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;dcomplex&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;row-wise&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;owner;&#x00A0;/*!&#x003C;&#x00A0;1&#x00A0;if&#x00A0;the&#x00A0;object&#x00A0;owns&#x00A0;its&#x00A0;array&#x00A0;member,&#x00A0;0&#x00A0;otherwise&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlMatComplex;
                                                                                    

                                                                                    
</div>
<!--l. 619--><p class="nopar" ><span class='var'>m</span> is the number of rows, <span class='var'>n</span> is the number of columns. <span class='var'>array</span> is a pointer containing the data of
the matrix stored line wise, The element <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">(i,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;j)</span></span></span> of the matrix is <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">array[i*m+j]</span></span></span>. <span class='var'>owner</span>
is an integer to know if the matrix owns its <span class='var'>array</span> pointer (<span class='var'>owner=1</span>) or shares it with
another structure (<span class='var'>owner=0</span>). <span class='var'>mem_size</span> is the number of elements the matrix can hold at
most.
</p><!--l. 627--><p class="noindent" >The following operations are implemented on matrices and vectors. <span class='var'>alpha</span>
and <span class='var'>beta</span> are numbers, <span class='var'>A</span> and <span class='var'>B</span> are matrices and <span class='var'>x</span> and <span class='var'>y</span> are vectors.
<!--tex4ht:inline--></p><div class="tabular"> <table id="TBL-7" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-7-1g"><col 
id="TBL-7-1" /><col 
id="TBL-7-2" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-7-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-1-1"  
class="td11"><a 
href="#x6-560004.3.2">pnl_mat_axpy</a>                                 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-1-2"  
class="td11"><span class='var'>B := alpha * A + B</span>                            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-2-1"  
class="td11"><a 
href="#x6-560004.3.2">pnl_mat_scalar_prod</a>                        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-2-2"  
class="td11"><span class='var'>x&#8217; A y</span>                                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-3-1"  
class="td11"><a 
href="#x6-560004.3.2">pnl_mat_dgemm</a>                              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-3-2"  
class="td11"><span class='var'>C := alpha * op (A) * op (B) + beta * C</span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-4-1"  
class="td11"><a 
href="#x6-560004.3.2">pnl_mat_mult_vect_transpose_inplace</a></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-4-2"  
class="td11"><span class='var'>y = A&#8217; * x</span>                                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-5-1"  
class="td11"><a 
href="#x6-560004.3.2">pnl_mat_mult_vect_inplace</a>               </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-5-2"  
class="td11"><span class='var'>y = A * x</span>                                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-6-1"  
class="td11"><a 
href="#x6-560004.3.2">pnl_mat_lAxpby</a>                              </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-6-2"  
class="td11"><span class='var'>y := lambda * A * x + beta * y</span>            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-7-1"  
class="td11"><a 
href="#x6-560004.3.2">pnl_mat_dgemv</a>                               </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-7-2"  
class="td11"><span class='var'>y := alpha * op (A) * x + beta * y</span>        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-8-1"  
class="td11"><a 
href="#x6-560004.3.2">pnl_mat_dger</a>                                  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-8-2"  
class="td11"><span class='var'>A := alpha x * y&#8217; + A</span>                         </td></tr></table></div>
<!--l. 642--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.2   </span> <a 
 id="x6-480004.3.2"></a>Generic Functions</h5>
<!--l. 643--><p class="noindent" >These functions exist for all types of matrices no matter what the basic type is. The following
conventions are used to name functions operating on matrices. Here is the table of prefixes used for
the different basic types.
</p>
<div class="center" 
>
<!--l. 647--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-8" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-8-1g"><col 
id="TBL-8-1" /><col 
id="TBL-8-2" /><col 
id="TBL-8-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-8-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-1"  
class="td11">type      </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-2"  
class="td11">prefix                 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-3"  
class="td11">BASE    </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-1"  
class="td11">double    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-2"  
class="td11">pnl_mat             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-3"  
class="td11">double    </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-1"  
class="td11">int         </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-2"  
class="td11">pnl_mat_int       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-3"  
class="td11">int         </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-1"  
class="td11">dcomplex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-2"  
class="td11">pnl_mat_complex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-3"  
class="td11">dcomplex</td></tr></table></div></div>
<!--l. 659--><p class="noindent" >In this paragraph we present the functions operating on <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> which exist for all types. To deduce
the prototypes of these functions for other basic types, one must replace <span 
class="ec-lmtt-10x-x-109">pnl_mat </span>and <span 
class="ec-lmtt-10x-x-109">double</span>
according the above table.
</p>
<!--l. 664--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-490004.3.2"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
There are no special functions to access the sizes of a matrix, instead the fields <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">m</span></span></span>, <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">n</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">mn</span></span></span> give
direct access to the number of rows, columns and the size of the matrix.
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-49001"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> of size 0
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-49002"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create</span></span>&#x00A0;(<span class='args'>int m, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> with <span class='var'>m</span> rows and <span class='var'>n</span> columns.
     </li>
     <li class="itemize"><a 
 id="dx6-49003"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_scalar</span></span>&#x00A0;(<span class='args'>int m, int n, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> with <span class='var'>m</span> rows and <span class='var'>n</span> columns and sets all the elements
     to <span class='var'>x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-49004"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_zero</span></span>&#x00A0;(<span class='args'>int m, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> with <span class='var'>m</span> rows and <span class='var'>n</span> columns and sets all elements to 0.
     </li>
     <li class="itemize"><a 
 id="dx6-49005"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_ptr</span></span>&#x00A0;(<span class='args'>int m, int n, const double <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> with <span class='var'>m</span> rows and <span class='var'>n</span> columns and copies the array <span class='var'>x</span> to
     the new vector. Be sure that <span class='var'>x</span> is long enough to fill all the vector because it cannot be
     checked inside the function.
     </li>
     <li class="itemize"><a 
 id="dx6-49006"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_list</span></span>&#x00A0;(<span class='args'>int m, int n, ...</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> pointer of size <span class='var'>m x n</span> filled with the extra arguments
     passed to the function. The number of extra arguments passed must be equal to <span class='var'>m x n</span>,
     be aware that this cannot be checked inside the function.
     </li>
     <li class="itemize"><a 
 id="dx6-49007"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> which is a copy of <span class='var'>M</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-49008"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_diag_from_ptr</span></span>&#x00A0;(<span class='args'>const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new squared <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> by specifying its size and diagonal terms
     as an array.
     </li>
     <li class="itemize"><a 
 id="dx6-49009"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_diag</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create  a  new  squared  <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>  by  specifying  its  diagonal  terms  in  a
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-49010"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_file</span></span>&#x00A0;(<span class='args'>const char <span 
class="ts1-lmr10-x-x-109">*</span>file</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Read a matrix from a file and creates the corresponding <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> . One
     row of the matrix corresponds to one line of the file and the elements of a row can be
     separated by spaces, tabs, commas or semicolons. Anything after a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">#</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">%</span></span></span> is ignored up
     to the end of the line.
     </li>
     <li class="itemize"><a 
 id="dx6-49011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> and sets <span class='var'><span 
class="ts1-lmr10-x-x-109">*</span>M</span> to <span class='var'>NULL</span>
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-49012"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_wrap_array</span></span>&#x00A0;(<span class='args'>const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int m, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> of size <span class='var'>m x n</span> which contains <span class='var'>x</span>. No copy is made. It is
     just a container.
     </li>
     <li class="itemize"><a 
 id="dx6-49013"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_wrap_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> (not a pointer) whose array is the array of <span class='var'>V</span>. The new
     matrix shares its data with the vector <span class='var'>V</span>, which means that any modification to one of
     them will affect the other.
     </li>
     <li class="itemize"><a 
 id="dx6-49014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone <span class='var'>M</span> into <span class='var'>clone</span>. No no new <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> is created.
     </li>
     <li class="itemize"><a 
 id="dx6-49015"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int m, int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> . The new matrix is of size <span class='var'>m x n</span>. The old data are lost.
     </li>
     <li class="itemize"><a 
 id="dx6-49016"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_create_submat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indi,
     const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indj</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new vector containing the values <span class='var'>M(indi(:), indj(:))</span>. <span class='var'>indi</span> and
     <span class='var'>indj</span> must be of the same size.
     </li>
     <li class="itemize"><a 
 id="dx6-49017"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_extract_submat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>V_sub,  const  <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>M,  const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indi, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indj</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>V_sub = M(indi(:), indj(:))</span>. <span class='var'>indi</span> and <span class='var'>indj</span> must be of the same
     size.
     </li>
     <li class="itemize"><a 
 id="dx6-49018"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_extract_subblock</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M_sub, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int
     len_i, int j, int len_j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>M_sub = M(i:i+len_i-1, j:j+len_j-1)</span>. <span class='var'>len_i</span> (resp. <span class='var'>len_j</span>) is the number
     of rows (resp. columns) to be extracted.
     </li>
     <li class="itemize"><a 
 id="dx6-49019"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_subblock</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>block, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>If <span class='var'>block</span> is a matrix of size <span class='var'>m_block x n_block</span>, the dimensions of <span class='var'>M</span>
     must satisfy that <span class='var'>M-&#x003E;m &#x003E;= i + m_block</span> and <span class='var'>M-&#x003E;n &#x003E;= j + n_block</span>. On output
     <span class='var'>M(i:i+m_block-1, j:j+n_block-1) = block</span>.</li></ul>
<!--l. 764--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-500004.3.2"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements.</span></span>
If it is supported by the compiler, the following functions are declared inline. To speed up these
functions, you can define the macro <span 
class="ec-lmtt-10x-x-109">PNL_RANGE_CHECK_OFF</span>, see Section&#x00A0;<a 
href="pnl-manualse1.html#x3-100001.3.2">1.3.2<!--tex4ht:ref: sec:inline --></a> for an
explanation.
</p><!--l. 770--><p class="noindent" >Accessing elements of a matrix is faster using the following macros </p>
                                                                                    

                                                                                    
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-50001"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MGET</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>M[i,j]</span> for reading, eg. <span class='var'>x=MGET(M,i,j)</span>
     </li>
     <li class="itemize"><a 
 id="dx6-50002"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MGET_INT</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMatInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x6-500004.3.2">MGET</a> but for an integer matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-50003"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MGET_COMPLEX</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x6-500004.3.2">MGET</a> but for a complex matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-50004"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MLET</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>M[i,j]</span> as a lvalue for writing, eg. <span class='var'>MLET(M,i,j)=x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-50005"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MLET_INT</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMatInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x6-500004.3.2">MLET</a> but for an integer matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-50006"></a> <span class='ret'></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">MLET_COMPLEX</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x6-500004.3.2">MLET</a> but for a complex matrix.</li></ul>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-50007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the value of M[i, j]=x
     </li>
     <li class="itemize"><a 
 id="dx6-50008"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Get the value of M[i, j]
     </li>
     <li class="itemize"><a 
 id="dx6-50009"></a> <span class='ret'>double <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address of M[i, j] for use as a lvalue.
     </li>
     <li class="itemize"><a 
 id="dx6-50010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_all</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements of <span class='var'>M</span> to <span class='var'>x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-50011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_zero</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all elements of <span class='var'>M</span> to <span class='var'>0</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-50012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_id</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the matrix <span class='var'>M</span> to the identity matrix. <span class='var'>M</span> must be a square matrix.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-50013"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_diag</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x, int d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'><span 
class="lmmi-10x-x-109">d</span></span><sup>th</sup> diagonal terms of the matrix <span class='var'>M</span> to the value <span class='var'>x</span>. <span class='var'>M</span> must be a
     square matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-50014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_from_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const double <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set <span class='var'>M</span> row&#8211;wise with the values given by <span class='var'>x</span>. The array <span class='var'>x</span> must be at least
     M-&#x003E;mn long.
     </li>
     <li class="itemize"><a 
 id="dx6-50015"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_get_row</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Extract and copies the <span class='var'>i</span>-th row of <span class='var'>M</span> into <span class='var'>V</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-50016"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_get_col</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Extract and copies the <span class='var'>j</span>-th column of <span class='var'>M</span> into <span class='var'>V</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-50017"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_mat_row</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> (not a pointer) whose array is the <span class='var'>i</span>-th row of <span class='var'>M</span>. The
     new vector shares its data with the matrix <span class='var'>M</span>, which means that any modification to
     one of them will affect the other.
     </li>
     <li class="itemize"><a 
 id="dx6-50018"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_wrap_mat_rows</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i_start, int i_end</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> (not a pointer) holding rows from <span class='var'>i_start</span> to <span class='var'>i_end</span>
     (included) of <span class='var'>M</span>. The new matrix shares its data with the matrix <span class='var'>M</span>, which means that
     any modification to one of them will affect the other.
     </li>
     <li class="itemize"><a 
 id="dx6-50019"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_swap_rows</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Swap two rows of a matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-50020"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_col</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'>i</span>-th column of a matrix <span class='var'>M</span> with the content of <span class='var'>V</span>
     </li>
     <li class="itemize"><a 
 id="dx6-50021"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_col_from_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'>i</span>-th column of <span class='var'>M</span> with the content of <span class='var'>x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-50022"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_row</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>V, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'>i</span>-th row of <span class='var'>M</span> with the content of <span class='var'>V</span>
     </li>
     <li class="itemize"><a 
 id="dx6-50023"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_set_row_from_ptr</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const double <span 
class="ts1-lmr10-x-x-109">*</span>x, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the <span class='var'>i</span>-th row of <span class='var'>M</span> with the content of <span class='var'>x</span>
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-50024"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_add_row</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>r</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Add a row in matrix <span class='var'>M</span> before position <span class='var'>i</span> and fill it with the content of <span class='var'>r</span>.
     If <span class='var'>r == NULL</span>, row <span class='var'>i</span> is left uninitialized. The index <span class='var'>i</span> may vary between <span class='var'>0</span> &#8212; add a row
     at the top of the matrix &#8212; and <span class='var'>M-&#x003E;m</span> &#8212; add a row after all rows.
     </li>
     <li class="itemize"><a 
 id="dx6-50025"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_del_row</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Delete the row with index <span class='var'>i</span> (between <span class='var'>0</span> and <span class='var'>M-&#x003E;m-1</span>) of the matrix <span class='var'>M</span>.
     </li></ul>
<!--l. 866--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-510004.3.2"></a><span 
class="ec-lmbx-10x-x-109">Printing Matrices</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-51001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a matrix to the standard output.
     </li>
     <li class="itemize"><a 
 id="dx6-51002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a matrix to a file. The saved matrix can be reloaded by the function
     <a 
href="#x6-490004.3.2">pnl_mat_create_from_file</a>.
     </li>
     <li class="itemize"><a 
 id="dx6-51003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_print_nsp</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a matrix to the standard output in a format compatible with Nsp.
     </li>
     <li class="itemize"><a 
 id="dx6-51004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_fprint_nsp</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a matrix to a file in a format compatible with Nsp.</li></ul>
<!--l. 886--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-520004.3.2"></a><span 
class="ec-lmbx-10x-x-109">Applying external operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-52001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar addition
     </li>
     <li class="itemize"><a 
 id="dx6-52002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar substraction
     </li>
     <li class="itemize"><a 
 id="dx6-52003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar multiplication
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-52004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar division
     </li></ul>
<!--l. 902--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-530004.3.2"></a><span 
class="ec-lmbx-10x-x-109">Element wise operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-53001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix term by term product
     </li>
     <li class="itemize"><a 
 id="dx6-53002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_div_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix term by term division
     </li>
     <li class="itemize"><a 
 id="dx6-53003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_map_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs)</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-53004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_map</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs)</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-53005"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_map_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>lhs,    const    <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>rhs,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double, double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs, rhs)</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-53006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_map_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs1, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double, double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs1, rhs2)</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-53007"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_sum</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sum matrix component-wise
     </li>
     <li class="itemize"><a 
 id="dx6-53008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_sum_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char c</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sum matrix column or row wise. Argument <span class='var'>c</span> can be either &#8217;r&#8217; (to get a
     row vector) or &#8217;c&#8217; (to get a column vector). When <span class='var'>c=&#8217;r&#8217;</span>, <span 
class="lmmi-10x-x-109">y</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="lmex-10">&#x2211;</span>
  <sub><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> and when <span class='var'>c=&#8217;rc</span>,
     <span 
class="lmmi-10x-x-109">y</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="lmex-10">&#x2211;</span>
  <sub><span 
class="lmmi-8">j</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub>.
     </li>
     <li class="itemize"><a 
 id="dx6-53009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_cumsum</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char c</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative sum over the rows or columns. Argument <span class='var'>c</span> can be either &#8217;r&#8217;
                                                                                    

                                                                                    
     to sum over the rows or &#8217;c&#8217; to sum over the columns. When <span class='var'>c=&#8217;r&#8217;</span>, <span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="lmex-10">&#x2211;</span>
  <sub><span 
class="rm-lmr-8">1</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">k</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">kj</span></sub>
     and when <span class='var'>c=&#8217;rc</span>, <span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="lmex-10">&#x2211;</span>
  <sub><span 
class="rm-lmr-8">1</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">k</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">j</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ik</span></sub>.
     </li>
     <li class="itemize"><a 
 id="dx6-53010"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_prod</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Product matrix component-wise
     </li>
     <li class="itemize"><a 
 id="dx6-53011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_prod_vect</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char c</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Prod matrix column or row wise. Argument <span class='var'>c</span> can be either &#8217;r&#8217; (to get a
     row vector) or &#8217;c&#8217; (to get a column vector). When <span class='var'>c=&#8217;r&#8217;</span>, <span 
class="lmmi-10x-x-109">y</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> and when <span class='var'>c=&#8217;rc</span>,
     <span 
class="lmmi-10x-x-109">y</span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="lmmi-8">j</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub>.
     </li>
     <li class="itemize"><a 
 id="dx6-53012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_cumprod</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char c</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Cumulative prod over the rows or columns. Argument <span class='var'>c</span> can be either &#8217;r&#8217;
     to prod over the rows or &#8217;c&#8217; to prod over the columns. When <span class='var'>c=&#8217;r&#8217;</span>, <span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="rm-lmr-8">1</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">k</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">i</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">kj</span></sub>
     and when <span class='var'>c=&#8217;rc</span>, <span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ij</span></sub> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="rm-lmr-8">1</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">k</span><span 
class="lmsy8-">&#x2264;</span><span 
class="lmmi-8">j</span></sub><span 
class="lmmi-10x-x-109">A</span><sub><span 
class="lmmi-8">ik</span></sub>.</li></ul>
<!--l. 965--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-540004.3.2"></a><span 
class="ec-lmbx-10x-x-109">Comparison functions</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-54001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_isequal</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, double err</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two matrices are equal up to <span class='var'>err</span> component&#8211;wise. The error <span class='var'>err</span>
     is either relative or absolute depending on the magnitude of the components. Return
     <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-54002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_isequal_abs</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, double abserr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test  if  two  matrices  are  equal  up  to  an  absolute  error  <span class='var'>abserr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-54003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_isequal_rel</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, double relerr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test   if   two   matrices   are   equal   up   to   a   relative   error   <span class='var'>relerr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.</li></ul>
<!--l. 976--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-550004.3.2"></a><span 
class="ec-lmbx-10x-x-109">Ordering operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-55001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_max</span></span>&#x00A0;(<span class='args'> <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'><span 
class="lmmi-10x-x-109">M</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">)) </span>when <span class='var'>d=&#8217;c&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">M</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j,i</span><span 
class="rm-lmr-10x-x-109">))</span>
     when <span class='var'>d=&#8217;r&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">M</span><span 
class="rm-lmr-10x-x-109">(0)</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">=</span><span class='var'> <span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">) </span>when <span class='var'>d=&#8217;*&#8217;</span>.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-55002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_min</span></span>&#x00A0;(<span class='args'> <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>m,const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'><span 
class="lmmi-10x-x-109">m</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">)  =</span>  <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">)) </span>when <span class='var'>d=&#8217;c&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">m</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">)  =</span>  <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j,i</span><span 
class="rm-lmr-10x-x-109">))</span>
     when <span class='var'>d=&#8217;r&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">M</span><span 
class="rm-lmr-10x-x-109">(0)</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">=</span><span class='var'> <span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">) </span>when <span class='var'>d=&#8217;*&#8217;</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-55003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_minmax</span></span>&#x00A0;(<span class='args'> <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>m, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'><span 
class="lmmi-10x-x-109">m</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">)) </span>and <span class='var'><span 
class="lmmi-10x-x-109">M</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">)) </span>when <span class='var'>d=&#8217;c&#8217;</span>
     and <span class='var'><span 
class="lmmi-10x-x-109">m</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j,i</span><span 
class="rm-lmr-10x-x-109">)) </span>and <span class='var'><span 
class="lmmi-10x-x-109">M</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">) =</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">j</span></sub><span 
class="rm-lmr-10x-x-109">(</span><span class='var'><span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">j,i</span><span 
class="rm-lmr-10x-x-109">)) </span>when <span class='var'>d=&#8217;r&#8217;</span> and <span class='var'><span 
class="lmmi-10x-x-109">M</span><span 
class="rm-lmr-10x-x-109">(0)</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">max</span> <sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">=</span>
     <span class='var'> <span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">) </span>and <span class='var'><span 
class="lmmi-10x-x-109">m</span><span 
class="rm-lmr-10x-x-109">(0)</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">=</span><span class='var'> <span 
class="lmmi-10x-x-109">A</span></span><span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">i,j</span><span 
class="rm-lmr-10x-x-109">) </span>when <span class='var'>d=&#8217;*&#8217;</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-55004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_min_index</span></span>&#x00A0;(<span class='args'> <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>m, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>im, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char
     d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Idem as <a 
href="#x6-550004.3.2">pnl_mat_min</a> and <span class='var'>index</span> contains the indices of the minima. If
     <span class='var'>index==NULL</span>, the indices are not computed.
     </li>
     <li class="itemize"><a 
 id="dx6-55005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_max_index</span></span>&#x00A0;(<span class='args'> <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>iM, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char
     d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Idem as <a 
href="#x6-550004.3.2">pnl_mat_max</a> and <span class='var'>index</span> contains the indices of the maxima. If
     <span class='var'>index==NULL</span>, the indices are not computed.
     </li>
     <li class="itemize"><a 
 id="dx6-55006"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_minmax_index</span></span>&#x00A0;(<span class='args'>  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>m,  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>M,  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>im,
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>iM, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, char d</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Idem as <a 
href="#x6-550004.3.2">pnl_mat_minmax</a> and <span class='var'>im</span> contains the indices of the minima
     and <span class='var'>iM</span> contains the indices of the minima. If <span class='var'>im==NULL</span> (resp. <span class='var'>iM==NULL</span>, the
     indices of the minima (resp. maxima) are not computed.
     </li>
     <li class="itemize"><a 
 id="dx6-55007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_qsort</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, char dir, char order</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sort a matrix using a quick sort algorithm according to <span class='var'>order</span> (<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;i&#8217;</span></span></span> for
     increasing or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;d&#8217;</span></span></span> for decreasing). The parameter <span class='var'>dir</span> determines whether the matrix is
     sorted by rows or columns. If <span class='var'>dir=&#8217;c&#8217;</span>, each row is sorted independently of the others
     whereas if <span class='var'>dir=&#8217;r&#8217;</span>, each column is sorted independently of the others.
     </li>
     <li class="itemize"><a 
 id="dx6-55008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_qsort_index</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, <a 
href="#x6-470004.3.1"><span class='struct'>PnlMatInt</span></a> *index, char dir, char order</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Sort a matrix using a quick sort algorithm according to <span class='var'>order</span> (<span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;i&#8217;</span></span></span> for
     increasing or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">&#8217;d&#8217;</span></span></span> for decreasing). The parameter <span class='var'>dir</span> determines whether the matrix is
     sorted by rows or columns. If <span class='var'>dir=&#8217;c&#8217;</span>, each row is sorted independently of the others
     whereas if <span class='var'>dir=&#8217;r&#8217;</span>, each column is sorted independently of the others. In addition to the
     function <a 
href="#x6-550004.3.2">pnl_mat_qsort</a>, the permutation index is computed and stored into <span class='var'>index</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-55009"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_find</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>indi, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> indj, char <span 
class="ts1-lmr10-x-x-109">*</span>type, int(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double <span 
class="ts1-lmr10-x-x-109">*</span>t),
     &#x2026;</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>f</span> is a function taking a C array as argument and returning an integer. <span class='var'>type</span> is a
                                                                                    

                                                                                    
     string composed by the letters &#8217;r&#8217; and &#8217;m&#8217; and is used to describe the types of the arguments
     appearing after <span class='var'>f</span> : &#8217;r&#8217; for real numbers and &#8217;m&#8217; for matrices. This function aims at simulating
     Scilab&#8217;s <span class='var'>find</span> function. Here are a few examples (capital letters are used for matrices and small
     letters for real values)
          <ul class="itemize2">
          <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">[indi,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;indj]</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;a</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;)</span></span></span>
                                                                                    

                                                                                    
          <div class="verbatim" id="verbatim-21">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;isless&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)&#x00A0;{&#x00A0;return&#x00A0;t[0]&#x00A0;&#x003C;&#x00A0;t[1];&#x00A0;}
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_mat_find&#x00A0;(&#x00A0;indi,&#x00A0;indj,&#x00A0;"rm",&#x00A0;isless,&#x00A0;a,&#x00A0;X&#x00A0;);
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</div>
          <!--l. 1047--><p class="nopar" >
          </p></li>
          <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">ind</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;Y)</span></span></span>
                                                                                    

                                                                                    
          <div class="verbatim" id="verbatim-22">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;isless&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)&#x00A0;{&#x00A0;return&#x00A0;t[0]&#x00A0;&#x003C;=&#x00A0;t[1];&#x00A0;}
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_mat_find&#x00A0;(&#x00A0;ind,&#x00A0;"mm",&#x00A0;isless,&#x00A0;X,&#x00A0;Y&#x00A0;);
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</div>
          <!--l. 1052--><p class="nopar" >
          </p></li>
          <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">[indi,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;indj]</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;find</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;((a</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;X)</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&amp;&amp;</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;(X</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;&#x003C;=</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;Y))</span></span></span>
                                                                                    

                                                                                    
          <div class="verbatim" id="verbatim-23">
          &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;cmp&#x00A0;(&#x00A0;double&#x00A0;*t&#x00A0;)
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;(t[0]&#x00A0;&#x003C;=&#x00A0;t[1])&#x00A0;&amp;&amp;&#x00A0;(t[1]&#x00A0;&#x003C;=&#x00A0;t[2]);
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pnl_mat_find&#x00A0;(&#x00A0;indi,&#x00A0;indj,&#x00A0;"rmm",&#x00A0;cmp,&#x00A0;a,&#x00A0;X,&#x00A0;Y&#x00A0;);
          &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;
</div>
          <!--l. 1060--><p class="nopar" ></p></li></ul>
     <!--l. 1062--><p class="noindent" ><span class='var'>(indi, indj)</span> contains on exit the indices <span class='var'>(i,j)</span> for which the function <span class='var'>f</span> returned <span class='var'>1</span>. Note that if
     <span class='var'>indj == NULL</span> on entry, a linear indexing is used for matrices, which means that matrices
     are seen as large vectors built up be stacking rows. This function returns <span class='var'>OK</span> or
     <span class='var'>FAIL</span> if something went wrong (size mismatch between matrices, invalid string
     type).</p></li></ul>
<!--l. 1070--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-560004.3.2"></a><span 
class="ec-lmbx-10x-x-109">Standard matrix operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-56001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_plus_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix addition
     </li>
     <li class="itemize"><a 
 id="dx6-56002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_minus_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix substraction
     </li>
     <li class="itemize"><a 
 id="dx6-56003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_sq_transpose</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>M</span> is transposed
     </li>
     <li class="itemize"><a 
 id="dx6-56004"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_transpose</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new matrix which is the transposition of <span class='var'>M</span>
     </li>
     <li class="itemize"><a 
 id="dx6-56005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_tr</span></span>&#x00A0;(<span class='args'> <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>tM, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>On exit, <span class='var'>tM = M&#8217;</span>
     </li>
     <li class="itemize"><a 
 id="dx6-56006"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_trace</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the trace of a square matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-56007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_axpy</span></span>&#x00A0;(<span class='args'>double alpha, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>B := alpha * A + B</span>
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-56008"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_dger</span></span>&#x00A0;(<span class='args'>double alpha, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>A := alpha x * y&#8217; + A</span>
     </li>
     <li class="itemize"><a 
 id="dx6-56009"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_vect</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Matrix vector multiplication <span class='var'>A * x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-56010"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_vect_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In place matrix vector multiplication <span class='var'>y = A * x</span>. You cannot use the
     same vector for <span class='var'>x</span> and <span class='var'>y</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-56011"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_vect_transpose</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Matrix vector multiplication <span class='var'>A&#8217; * x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-56012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_vect_transpose_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A,
     const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In place matrix vector multiplication <span class='var'>y = A&#8217; * x</span>. You cannot use the
     same vector for <span class='var'>x</span> and <span class='var'>y</span>. The vectors <span class='var'>x</span> and <span class='var'>y</span> must be different.
     </li>
     <li class="itemize"><a 
 id="dx6-56013"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_cross</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the cross products of the vectors given in matrices <span class='var'>A</span> and <span class='var'>B</span>
     which must have either 3 rows or 3 columns. A row wise computation is first tried, then
     a column wise approach is tested. <span class='var'>FAIL</span> is returned in case no dimension equals 3.
     </li>
     <li class="itemize"><a 
 id="dx6-56014"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lAxpby</span></span>&#x00A0;(<span class='args'>double lambda, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double
     b, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>y := lambda A x + b y</span>. When <span class='var'>b=0</span>, the content of <span class='var'>y</span> is not
     used on input and instead <span class='var'>y</span> is resized to match <span class='var'>A*x</span>. The vectors <span class='var'>x</span> and <span class='var'>y</span> must be
     different.
     </li>
     <li class="itemize"><a 
 id="dx6-56015"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_dgemv</span></span>&#x00A0;(<span class='args'>char trans, double lambda, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x, double mu, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>b := lambda op(A) x + mu b</span>, where <span class='var'>op (X) = X</span> or <span class='var'>op (X) =
     X&#8217;</span>. If <span class='var'>trans=&#8217;N&#8217;</span> or <span class='var'>trans=&#8217;n&#8217;</span>, <span class='var'>op (A) = A</span>, whereas if <span class='var'>trans=&#8217;T&#8217;</span> or <span class='var'>trans=&#8217;t&#8217;</span>, <span class='var'>op (A)
     = A&#8217;</span>.When <span class='var'>mu==0</span>, the content of <span class='var'>b</span> is not used and instead <span class='var'>b</span> is resized to match
     <span class='var'>op(A)*x</span>. The vectors <span class='var'>x</span> and <span class='var'>b</span> must be different.
     </li>
     <li class="itemize"><a 
 id="dx6-56016"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_dgemm</span></span>&#x00A0;(<span class='args'>char transA, char transB, double alpha, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A,
     const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, double beta, <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>C</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>C := alpha * op(A) * op (B) + beta * C</span>. When beta=0, the
     content of <span class='var'>C</span> is unused and instead <span class='var'>C</span> is resized to store <span class='var'>alpha A <span 
class="ts1-lmr10-x-x-109">*</span>B</span>. If <span class='var'>transA=&#8217;N&#8217;</span> or
                                                                                    

                                                                                    
     <span class='var'>transA=&#8217;n&#8217;</span>, <span class='var'>op (A) = A</span>, whereas if <span class='var'>transA=&#8217;T&#8217;</span> or <span class='var'>transA=&#8217;t&#8217;</span>, <span class='var'>op (A) = A&#8217;</span>. The same
     holds for <span class='var'>transB</span>. The matrix <span class='var'>C</span> must be different from <span class='var'>A</span> and <span class='var'>B</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-56017"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs1, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Matrix multiplication <span class='var'>rhs1 * rhs2</span>
     </li>
     <li class="itemize"><a 
 id="dx6-56018"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_mult_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>lhs,  const  <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>rhs1,  const
     <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs2</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix multiplication <span class='var'>lhs = rhs1 * rhs2</span>. The matrix <span class='var'>lhs</span> must be
     different from <span class='var'>rhs1</span> and <span class='var'>rhs2</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-56019"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_scalar_prod</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>x&#8217; * A * y</span>
     </li>
     <li class="itemize"><a 
 id="dx6-56020"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_exp</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the matrix exponential <span class='var'>B = exp(A)</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-56021"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_log</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the matrix logarithm <span class='var'>B = log(A)</span>. For the moment, this function
     only works if <span class='var'>A</span> is diagonalizable.
     </li>
     <li class="itemize"><a 
 id="dx6-56022"></a>   <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_eigen</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>   *v,   <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>P,   const   <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>A,   int
     with_eigenvector</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the eigenvalues (stored in <span class='var'>v</span>) and optionally the eigenvectors
     stored  column  wise  in  <span class='var'>P</span>  when  <span class='var'>with_eigenvector==TRUE</span>.  If  <span class='var'>A</span>  is  symmetric  or
     Hermitian in the complex case, <span class='var'>P</span> is orthonormal. When <span class='var'>with_eigenvector=FALSE</span>, <span class='var'>P</span>
     can be <span class='var'>NULL</span>.</li></ul>
<!--l. 1191--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-570004.3.2"></a><span 
class="ec-lmbx-10x-x-109">Linear systems and matrix decompositions</span></span>
The following functions are designed to solve linear system of the from <span class='var'>A x = b</span> where <span class='var'>A</span> is a matrix
and <span class='var'>b</span> is a vector except in the functions <a 
href="#x6-570004.3.2">pnl_mat_syslin_mat</a>, <a 
href="#x6-570004.3.2">pnl_mat_lu_syslin_mat</a> and
<a 
href="#x6-570004.3.2">pnl_mat_chol_syslin_mat</a> which expect the right hand side member to be a matrix too. Whenever
the vector <span class='var'>b</span> is not needed once the system is solved, you should consider using &#8220;inplace&#8221;
functions.
</p><!--l. 1201--><p class="noindent" >All the functions described in this paragraph return <span class='var'>OK</span> if the computations have been carried out
successfully and <span class='var'>FAIL</span> otherwise.
</p>
                                                                                    

                                                                                    
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-57001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_chol</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the Cholesky decomposition of <span class='var'>M</span>. <span class='var'>M</span> must be symmetric, the
     positivity is tested in the algorithm. <span class='var'>M = L * L&#8217;</span>. On exit, the lower part of <span class='var'>M</span> contains
     the Cholesky decomposition L and the upper part is set to zero.
     </li>
     <li class="itemize"><a 
 id="dx6-57002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_pchol</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double tol, int <span 
class="ts1-lmr10-x-x-109">*</span>rank, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the Cholesky decomposition of <span class='var'>M</span> with complete pivoting. <span class='var'>P&#8217;
     * A * P = L * L&#8217;</span>. <span class='var'>M</span> must be symmetric positive semi-definite. On exit, the lower part
     of <span class='var'>M</span> contains the Cholesky decomposition <span class='var'>L</span> and the upper part is set to zero. The
     permutation matrix is stored in an integer vector <span class='var'>p</span> : the only non zero elements of <span class='var'>P</span>
     are <span class='var'>P(p(k),k) = 1</span>
     </li>
     <li class="itemize"><a 
 id="dx6-57003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lu</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute a P A = LU factorization. <span class='var'>P</span> must be an already allocated
     <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> . On exit the decomposition is stored in <span class='var'>A</span>, the lower part of <span class='var'>A</span> contains
     L while the upper part (including the diagonal terms) contains U. Remember that the
     diagonal elements of <span class='var'>L</span> are all 1. Row <span class='var'>i</span> of <span class='var'>A</span> was interchanged with row <span class='var'>p(i)</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-57004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_upper_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>U, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve an upper triangular linear system <span class='var'>U x = b</span>
     </li>
     <li class="itemize"><a 
 id="dx6-57005"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lower_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>L, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a lower triangular linear system <span class='var'>L x = b</span>
     </li>
     <li class="itemize"><a 
 id="dx6-57006"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_chol_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>chol, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a symmetric definite positive linear system A x = b, in which <span class='var'>chol</span>
     is assumed to be the Cholesky decomposition of A computed by <a 
href="#x6-570004.3.2">pnl_mat_chol</a>
     </li>
     <li class="itemize"><a 
 id="dx6-57007"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_chol_syslin_inplace</span></span>&#x00A0;(<span class='args'> const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>chol, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a symmetric definite positive linear system A x = b, in which <span class='var'>chol</span>
     is assumed to be the Cholesky decomposition of A computed by <a 
href="#x6-570004.3.2">pnl_mat_chol</a>. The
     solution of the system is stored in <span class='var'>b</span> on exit.
     </li>
     <li class="itemize"><a 
 id="dx6-57008"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lu_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>LU, const <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p,
     const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A x = b using a LU decomposition. <span class='var'>LU</span> and <span class='var'>P</span> are
     assumed to be the PA = LU decomposition as computed by <a 
href="#x6-570004.3.2">pnl_mat_lu</a>. In particular,
     the structure of the matrix <span class='var'>LU</span> is the following : the lower part of <span class='var'>A</span> contains L while
     the upper part (including the diagonal terms) contains U. Remember that the diagonal
     elements of <span class='var'>L</span> are all 1.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-57009"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lu_syslin_inplace</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>LU, const <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p,
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A x = b using a LU decomposition. <span class='var'>LU</span> and <span class='var'>P</span> are
     assumed to be the PA = LU decomposition as computed by <a 
href="#x6-570004.3.2">pnl_mat_lu</a>. In particular,
     the structure of the matrix <span class='var'>LU</span> is the following : the lower part of <span class='var'>A</span> contains L while
     the upper part (including the diagonal terms) contains U. Remember that the diagonal
     elements of <span class='var'>L</span> are all 1. The solution of the system is stored in <span class='var'>b</span> on exit.
     </li>
     <li class="itemize"><a 
 id="dx6-57010"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A x = b using a LU factorization which is computed
     inside this function.
     </li>
     <li class="itemize"><a 
 id="dx6-57011"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_syslin_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A x = b using a LU factorization which is computed
     inside this function. The solution of the system is stored in <span class='var'>b</span> and <span class='var'>A</span> is overwritten by
     its LU decomposition.
     </li>
     <li class="itemize"><a 
 id="dx6-57012"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_syslin_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  a  linear  system  A  X  =  B  using  a  LU  factorization  which  is
     computed inside this function. <span class='var'>A</span> and <span class='var'>B</span> are matrices. <span class='var'>A</span> must be square. The solution
     of the system is stored in <span class='var'>B</span> on exit. On exit, <span class='var'>A</span> contains the LU decomposition of the
     input matrix which is lost.
     </li>
     <li class="itemize"><a 
 id="dx6-57013"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_chol_syslin_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  a  linear  system  A  X  =  B  using  a  Cholesky  factorization  of
     the symmetric positive defnite matrix <span class='var'>A</span>. <span class='var'>A</span> contains the Cholesky decomposition as
     computed by <a 
href="#x6-570004.3.2">pnl_mat_chol</a>. <span class='var'>B</span> is matrix with the same number of rows as <span class='var'>A</span>. The
     solution of the system is stored in <span class='var'>B</span> on exit.
     </li>
     <li class="itemize"><a 
 id="dx6-57014"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lu_syslin_mat</span></span>&#x00A0;(<span class='args'>const  <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>A,  const  <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>p,
     <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A X = B using a <span class='var'>P A = L U</span> factorization. <span class='var'>A</span>
     contains the <span class='var'>L U</span> factors and <span class='var'>p</span> the associated permutation. <span class='var'>A</span> and <span class='var'>p</span> must have been
     computed by <a 
href="#x6-570004.3.2">pnl_mat_lu</a>. <span class='var'>B</span> is matrix with the same number of rows as <span class='var'>A</span>. The solution
     of the system is stored in <span class='var'>B</span> on exit.
     </li></ul>
<!--l. 1310--><p class="noindent" >The following functions are designed to invert matrices. The authors provide these functions
although they cannot find good reasons to use them. Note that to solve a linear system, one must
used the <span class='var'>syslin</span> functions and not invert the system matrix because it is much longer.
</p>
                                                                                    

                                                                                    
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-57015"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_upper_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Inversion of an upper triangular matrix
     </li>
     <li class="itemize"><a 
 id="dx6-57016"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_lower_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Inversion of a lower triangular matrix
     </li>
     <li class="itemize"><a 
 id="dx6-57017"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>inverse, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse of a matrix A and stores the result into <span class='var'>inverse</span>. A
     LU factorisation of the matrix <span class='var'>A</span> is computed inside this function.
     </li>
     <li class="itemize"><a 
 id="dx6-57018"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_inverse_with_chol</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>inverse, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute the inverse of a symmetric positive definite matrix A and stores
     the result into <span class='var'>inverse</span>. The Cholesky factorisation of the matrix <span class='var'>A</span> is computed inside
     this function.</li></ul>
<!--l. 1335--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.3   </span> <a 
 id="x6-580004.3.3"></a>Functions specific to base type <span 
class="ec-lmtt-10x-x-109">double</span></h5>
<!--l. 1338--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-590004.3.3"></a><span 
class="ec-lmbx-10x-x-109">Linear systems and matrix decompositions</span></span>
The following functions are designed to solve linear system of the from <span class='var'>A x = b</span> where <span class='var'>A</span> is a matrix
and <span class='var'>b</span> is a vector except in the functions <a 
href="#x6-570004.3.2">pnl_mat_syslin_mat</a>, <a 
href="#x6-570004.3.2">pnl_mat_lu_syslin_mat</a> and
<a 
href="#x6-570004.3.2">pnl_mat_chol_syslin_mat</a> which expect the right hand side member to be a matrix too. Whenever
the vector <span class='var'>b</span> is not needed once the system is solved, you should consider using &#8220;inplace&#8221;
functions.
</p><!--l. 1348--><p class="noindent" >All the functions described in this paragraph return <span class='var'>OK</span> if the computations have been carried out
successfully and <span class='var'>FAIL</span> otherwise.
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-59001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_qr</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Q, <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>R, <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute a <span class='var'>A P = QR</span> decomposition. If on entry <span class='var'>P=NULL</span>, then the
     decomposition is computed without pivoting, i.e <span class='var'>A = QR</span>. When <span 
class="lmmi-10x-x-109">P</span><span 
class="lmmi-10x-x-109">&#x2260;</span><span 
class="lmmi-10x-x-109">NULL</span>, <span class='var'>P</span> must be
     an already allocated <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> . <span class='var'>Q</span> is an orthogonal matrix, i.e <span class='var'><span 
class="lmmi-10x-x-109">Q</span></span><sup><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span></sup> <span 
class="rm-lmr-10x-x-109">=</span><span class='var'> <span 
class="lmmi-10x-x-109">Q</span></span><sup><span 
class="lmmi-8">T</span> </sup> and
     <span class='var'>R</span> is an upper triangular matrix. The use of pivoting improves the numerical stability
     when <span class='var'>A</span> is almost rank deficient, i.e when the smallest eigenvalue of <span class='var'>A</span> is very close to
     <span 
class="rm-lmr-10x-x-109">0</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-59002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_qr_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Q, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>R, const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system <span class='var'>A x = b</span> where <span class='var'>A</span> is given by its QR decomposition
     with column pivoting as computed by the function <a 
href="#x6-590004.3.3">pnl_mat_qr</a>.
     </li>
     <li class="itemize"><a 
 id="dx6-59003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_ls</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  a  linear  system  A  x  =  b  in  the  least  square  sense,  i.e.  <span class='var'><span 
class="lmmi-10x-x-109">x</span></span>  <span 
class="rm-lmr-10x-x-109">=</span>
     <span 
class="rm-lmr-10x-x-109">arg</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">U</span></sub><span 
class="lmsy-10x-x-109">&#x2225;</span><span 
class="lmmi-10x-x-109">A </span><span 
class="lmsy-10x-x-109">* </span><span 
class="lmmi-10x-x-109">u </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">b</span><span 
class="lmsy-10x-x-109">&#x2225;</span><sup><span 
class="rm-lmr-8">2</span></sup>. The solution is stored into <span class='var'>b</span> on exit. It internally uses a <span class='var'>AP =
     QR</span> decomposition.
     </li>
     <li class="itemize"><a 
 id="dx6-59004"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_ls_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>B</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system A X = B with <span class='var'>A</span> and <span class='var'>B</span> two matrices in the least
     square sense, i.e. <span class='var'><span 
class="lmmi-10x-x-109">X</span></span> <span 
class="rm-lmr-10x-x-109">=</span> <span 
class="rm-lmr-10x-x-109">arg</span> <span 
class="rm-lmr-10x-x-109">min</span> <sub><span 
class="lmmi-8">U</span></sub><span 
class="lmsy-10x-x-109">&#x2225;</span><span 
class="lmmi-10x-x-109">A </span><span 
class="lmsy-10x-x-109">* </span><span 
class="lmmi-10x-x-109">U </span><span 
class="lmsy-10x-x-109">- </span><span 
class="lmmi-10x-x-109">B</span><span 
class="lmsy-10x-x-109">&#x2225;</span><sup><span 
class="rm-lmr-8">2</span></sup>. The solution is stored into <span class='var'>B</span> on exit. It
     internally uses a <span class='var'>AP = QR</span> decomposition. Same function as <a 
href="#x6-590004.3.3">pnl_mat_ls</a> but handles
     several r.h.s.
     </li></ul>
<!--l. 1384--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.4   </span> <a 
 id="x6-600004.3.4"></a>Functions specific to base type <span 
class="ec-lmtt-10x-x-109">dcomplex</span></h5>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-60001"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMatComplex</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_complex_create_from_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>R</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a complex matrix using a real one. The complex parts of the
     entries of the returned matrix are all set to zero.</li></ul>
<!--l. 1392--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.3.5   </span> <a 
 id="x6-610004.3.5"></a>Permutations</h5>
<a 
 id="dx6-61001"></a>
                                                                                    

                                                                                    
<div class="verbatim" id="verbatim-24">
typedef&#x00A0;PnlVectInt&#x00A0;PnlPermutation;
</div>
<!--l. 1397--><p class="nopar" >
</p><!--l. 1399--><p class="noindent" >The <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlPermutation</span></span></span> type is actually nothing else than a vector of integers, i.e. a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlVectInt</span></span></span>. It is
used to store the partial pivoting with row interchanges transformation needed in the LU
decomposition. We use the <span 
class="ec-lmri-10x-x-109">Blas </span>convention for storing permutations. Consider a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">PnlPermutation</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;p</span></span></span>
generated by a LU decomposition of a matrix <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">A</span></span></span> : to compute the decomposition, row <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">i</span></span></span> of <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">A</span></span></span> was
interchanged with row <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">p(i)</span></span></span>.
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-61002"></a> <span class='ret'><a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-61003"></a> <span class='ret'><a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_create</span></span>&#x00A0;(<span class='args'>int n</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> of size <span class='var'>n</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-61004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-61005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>inv, const <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute in <span class='var'>inv</span> the inverse of the permutation <span class='var'>p</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-61006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_permute</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>px, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply a <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> to a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-61007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_permute_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply a <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> to a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> in-place.
     </li>
     <li class="itemize"><a 
 id="dx6-61008"></a>   <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_permute_inverse</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>px,   const   <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>x,   const
     <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply the inverse of <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> to a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-61009"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_permute_inverse_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>x,  const  <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply the inverse of a <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> to a <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> in-place.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-61010"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_col_permute</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>pX,    const    <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>X,    const
     <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply a <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> to the columns of a matrix. <span class='var'>pX</span> contains the
     result of the permutation applied to <span class='var'>X</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-61011"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_row_permute</span></span>&#x00A0;(<span class='args'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>pX,    const    <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>X,    const
     <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Apply a <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> to the rows of a matrix. <span class='var'>pX</span> contains the result
     of the permutation applied to <span class='var'>X</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-61012"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a permutation to a file.
     </li>
     <li class="itemize"><a 
 id="dx6-61013"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_permutation_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a permutation to the standard output.</li></ul>
<!--l. 1458--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.4   </span> <a 
 id="x6-620004.4"></a>Tridiagonal Matrices</h4>
<!--l. 1459--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.4.1   </span> <a 
 id="x6-630004.4.1"></a>Overview</h5>
<!--l. 1461--><p class="noindent" >The structures and functions related to tridiagonal matrices are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_tridiag_matrix.h</span></span></span>.
</p><!--l. 1464--><p class="noindent" >We only store the three main diagonals as three vectors.
<a 
 id="dx6-63001"></a>
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-25">
typedef&#x00A0;struct&#x00A0;PnlTridiagMat{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlTridiagMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows,&#x00A0;the&#x00A0;matrix&#x00A0;must&#x00A0;be&#x00A0;square&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*D;&#x00A0;/*!&#x003C;&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*DU;&#x00A0;/*!&#x003C;&#x00A0;upper&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*DL;&#x00A0;/*!&#x003C;&#x00A0;lower&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlTridiagMat;
</div>
<!--l. 1479--><p class="nopar" ><span class='var'>size</span> is the size of the matrix, <span class='var'>D</span> is an array of size <span class='var'>size</span> containing the diagonal terms. <span class='var'>DU</span>, <span class='var'>DL</span> are
two arrays of size <span class='var'>size-1</span> containing respectively the upper diagonal (<span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i,i</span><span 
class="rm-lmr-8">+1</span></sub>) and the lower diagonal
(<span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i</span><span 
class="lmsy8-">-</span><span 
class="rm-lmr-8">1</span><span 
class="lmmi-8">,i</span></sub>).
<a 
 id="dx6-63002"></a>
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-26">
typedef&#x00A0;struct&#x00A0;PnlTridiagMatLU{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlTridiagMatLU&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;size;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows,&#x00A0;the&#x00A0;matrix&#x00A0;must&#x00A0;be&#x00A0;square&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*D;&#x00A0;/*!&#x003C;&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*DU;&#x00A0;/*!&#x003C;&#x00A0;upper&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*DU2;&#x00A0;/*!&#x003C;&#x00A0;second&#x00A0;upper&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*DL;&#x00A0;/*!&#x003C;&#x00A0;lower&#x00A0;diagonal&#x00A0;elements&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*ipiv;&#x00A0;/*!&#x003C;&#x00A0;Permutation:&#x00A0;row&#x00A0;i&#x00A0;has&#x00A0;been&#x00A0;interchanged&#x00A0;with&#x00A0;row&#x00A0;ipiv(i)&#x00A0;*/
&#x00A0;<br />};
</div>
<!--l. 1500--><p class="nopar" >This type is used to store the LU decomposition of a tridiagonal matrix.
</p><!--l. 1503--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.4.2   </span> <a 
 id="x6-640004.4.2"></a>Functions</h5>
<!--l. 1504--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-650004.4.2"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-65001"></a> <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> with size 0
     </li>
     <li class="itemize"><a 
 id="dx6-65002"></a> <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create</span></span>&#x00A0;(<span class='args'>int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> with size <span class='var'>size</span>
     </li>
     <li class="itemize"><a 
 id="dx6-65003"></a> <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create_from_scalar</span></span>&#x00A0;(<span class='args'>int size, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> with the 3 diagonals filled with <span class='var'>x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-65004"></a> <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create_from_two_scalar</span></span>&#x00A0;(<span class='args'>int size, double
     x, double y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> with the diagonal filled with <span class='var'>x</span> and the upper
     and lower diagonals filled with <span class='var'>y</span>
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-65005"></a>  <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create_from_ptr</span></span>&#x00A0;(<span class='args'>int  size,  const  double
     <span 
class="ts1-lmr10-x-x-109">*</span>lower_D, const double <span 
class="ts1-lmr10-x-x-109">*</span>D, const double <span 
class="ts1-lmr10-x-x-109">*</span>upper_D</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     </li>
     <li class="itemize"><a 
 id="dx6-65006"></a> <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_create_from_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>mat</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a tridiagonal matrix from a full matrix (all the elements but the
     3 diagonal ones are ignored).
     </li>
     <li class="itemize"><a 
 id="dx6-65007"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_to_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a full matrix from a tridiagonal one.
     </li>
     <li class="itemize"><a 
 id="dx6-65008"></a> <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy a tridiagonal matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-65009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>T</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy the content of <span class='var'>T</span> into <span class='var'>clone</span>
     </li>
     <li class="itemize"><a 
 id="dx6-65010"></a> <span class='ret'>void </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>v</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     </li>
     <li class="itemize"><a 
 id="dx6-65011"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> .</li></ul>
<!--l. 1540--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-660004.4.2"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements.</span></span>
If it is supported by the compiler, the following functions are declared inline. To speed up these
functions, you can use the macro constant <span 
class="ec-lmtt-10x-x-109">PNL_RANGE_CHECK_OFF</span>, see Section&#x00A0;<a 
href="pnl-manualse1.html#x3-100001.3.2">1.3.2<!--tex4ht:ref: sec:inline --></a> for an
explanation. </p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-66001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int d, int up, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set <span class='var'>self[d, d+up] = x</span>, <span class='var'>up</span> can be <span 
class="lmsy-10x-x-109">{-</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmsy-10x-x-109">}</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-66002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int d, int up</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Get <span class='var'>self[d, d+up]</span>, <span class='var'>up</span> can be <span 
class="lmsy-10x-x-109">{-</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmsy-10x-x-109">}</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-66003"></a> <span class='ret'>double <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int d, int up</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address <span class='var'>self[d, d+up] = x</span>, <span class='var'>up</span> can be <span 
class="lmsy-10x-x-109">{-</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">,</span><span 
class="rm-lmr-10x-x-109">1</span><span 
class="lmsy-10x-x-109">}</span>.</li></ul>
                                                                                    

                                                                                    
<!--l. 1554--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-670004.4.2"></a><span 
class="ec-lmbx-10x-x-109">Printing Matrix</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-67001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a tri-diagonal matrix to a file.
     </li>
     <li class="itemize"><a 
 id="dx6-67002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a tridiagonal matrix to the standard output.</li></ul>
<!--l. 1562--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-680004.4.2"></a><span 
class="ec-lmbx-10x-x-109">Algebra operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-68001"></a>     <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_plus_tridiag_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>     <span 
class="ts1-lmr10-x-x-109">*</span>lhs,     const
     <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix addition
     </li>
     <li class="itemize"><a 
 id="dx6-68002"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_minus_tridiag_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>lhs,    const
     <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix substraction
     </li>
     <li class="itemize"><a 
 id="dx6-68003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar addition
     </li>
     <li class="itemize"><a 
 id="dx6-68004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar substraction
     </li>
     <li class="itemize"><a 
 id="dx6-68005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar multiplication
     </li>
     <li class="itemize"><a 
 id="dx6-68006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar division</li></ul>
<!--l. 1578--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-690004.4.2"></a><span 
class="ec-lmbx-10x-x-109">Element-wise operations</span></span>
</p>
                                                                                    

                                                                                    
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-69001"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_mult_tridiag_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>lhs,  const
     <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix term by term product
     </li>
     <li class="itemize"><a 
 id="dx6-69002"></a>   <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_div_tridiag_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>lhs,   const
     <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix matrix term by term division
     </li>
     <li class="itemize"><a 
 id="dx6-69003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_map_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs)</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-69004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_map_tridiag_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const
     <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double, double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs, rhs)</span>.</li></ul>
<!--l. 1594--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-700004.4.2"></a><span 
class="ec-lmbx-10x-x-109">Standard matrix operations &amp; Linear systems</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-70001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_mult_vect_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>mat, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In place matrix multiplication. The vector <span class='var'>lhs</span> must be different from <span class='var'>rhs</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-70002"></a>   <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_mult_vect</span></span>&#x00A0;(<span class='args'>const   <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>mat,   const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>vec</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Matrix multiplication
     </li>
     <li class="itemize"><a 
 id="dx6-70003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lAxpby</span></span>&#x00A0;(<span class='args'>double lambda, const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double mu, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>b := lambda A x + mu b</span>. When <span class='var'>mu==0</span>, the content of <span class='var'>b</span> is
     not used on input and instead <span class='var'>b</span> is resized to match <span class='var'>A*x</span>. Note that the vectors <span class='var'>x</span> and
     <span class='var'>b</span> must be different.
     </li>
     <li class="itemize"><a 
 id="dx6-70004"></a>  <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_scalar_prod</span></span>&#x00A0;(<span class='args'>const  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>x,const  <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>x&#8217; * A * y</span>
     </li>
     <li class="itemize"><a 
 id="dx6-70005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_syslin_inplace</span></span>&#x00A0;(<span class='args'> <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system M x = b. The solution is written into <span class='var'>b</span> on exit.
     On exit, <span class='var'>M</span> is modified and becomes unusable.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-70006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system M x = b. On exit, <span class='var'>M</span> is modified and becomes
     unusable.
     </li>
     <li class="itemize"><a 
 id="dx6-70007"></a> <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>
     </li>
     <li class="itemize"><a 
 id="dx6-70008"></a> <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_create</span></span>&#x00A0;(<span class='args'>int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> with size <span class='var'>size</span>
     </li>
     <li class="itemize"><a 
 id="dx6-70009"></a> <span class='ret'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>mat</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> which is a copy of <span class='var'>mat</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-70010"></a>        <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>        <span 
class="ts1-lmr10-x-x-109">*</span>clone,        const
     <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>mat</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone  a  <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>  .  <span class='var'>clone</span>  must  already  exist,  no  memory  is
     allocated for the envelope.
     </li>
     <li class="itemize"><a 
 id="dx6-70011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>m</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>
     </li>
     <li class="itemize"><a 
 id="dx6-70012"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>v, int size</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>
     </li>
     <li class="itemize"><a 
 id="dx6-70013"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_compute</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>LU, const <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>A</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  LU  factorisation  of  a  tridiagonal  matrix  <span class='var'>A</span>.  <span class='var'>LU</span>  must
     have already been created using <a 
href="#x6-700004.4.2">pnl_tridiag_mat_lu_new</a>. On exit, <span class='var'>LU</span> contains the
     decomposition which is suitable for use in <a 
href="#x6-700004.4.2">pnl_tridiag_mat_lu_syslin</a>.
     </li>
     <li class="itemize"><a 
 id="dx6-70014"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_syslin_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>LU, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system <span class='var'>A x = b</span> where the matrix <span class='var'>LU</span> is given the LU
     decomposition of A previously computed by <a 
href="#x6-700004.4.2">pnl_tridiag_mat_lu_compute</a>. On exit, <span class='var'>b</span>
     is overwritten by the solution <span class='var'>x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-70015"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_tridiag_mat_lu_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>x,  <a 
href="#x6-630004.4.1"><span class='struct'>PnlTridiagMatLU</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>LU,  const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve a linear system <span class='var'>A x = b</span> where the matrix <span class='var'>LU</span> is given the LU
     decomposition of A previously computed by <a 
href="#x6-700004.4.2">pnl_tridiag_mat_lu_compute</a>.</li></ul>
                                                                                    

                                                                                    
<!--l. 1651--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.5   </span> <a 
 id="x6-710004.5"></a>Band Matrices</h4>
<!--l. 1652--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.5.1   </span> <a 
 id="x6-720004.5.1"></a>Overview</h5>
<a 
 id="dx6-72001"></a>
                                                                                    

                                                                                    
<div class="verbatim" id="verbatim-27">
typedef&#x00A0;struct
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlBandMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;nu;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;of&#x00A0;upperdiagonals&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;nl;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;of&#x00A0;lowerdiagonals&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;m_band;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;rows&#x00A0;of&#x00A0;the&#x00A0;band&#x00A0;storage&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;n_band;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;columns&#x00A0;of&#x00A0;the&#x00A0;band&#x00A0;storage&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;&#x00A0;/*!&#x003C;&#x00A0;a&#x00A0;block&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;bands&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlBandMat;
</div>
<!--l. 1671--><p class="nopar" >
</p><!--l. 1674--><p class="noindent" >The structures and functions related to band matrices are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_band_matrix.h</span></span></span>.
</p><!--l. 1678--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.5.2   </span> <a 
 id="x6-730004.5.2"></a>Functions</h5>
<!--l. 1679--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-740004.5.2"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-74001"></a> <span class='ret'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a band matrix of size 0.
     </li>
     <li class="itemize"><a 
 id="dx6-74002"></a> <span class='ret'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_create</span></span>&#x00A0;(<span class='args'>int m, int n, int nl, int nu</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a band matrix of size <span class='var'>m x n</span> with <span class='var'>nl</span> lower diagonals and <span class='var'>nu</span> upper
     diagonals.
     </li>
     <li class="itemize"><a 
 id="dx6-74003"></a> <span class='ret'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_create_from_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM, int nl,
     int nu</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Extract a band matrix from a <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-74004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a band matrix.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-74005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy the band matrix <span class='var'>M</span> into <span class='var'>clone</span>. No new <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> is created.
     </li>
     <li class="itemize"><a 
 id="dx6-74006"></a> <span class='ret'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_copy</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new band matrix which is a copy of <span class='var'>BM</span>. Each band matrix
     owns its data array.
     </li>
     <li class="itemize"><a 
 id="dx6-74007"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_to_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a full matrix from a band matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-74008"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM, int m, int n, int nl, int nu</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize <span class='var'>BM</span> to store a <span class='var'>m x n</span> band matrix with <span class='var'>nu</span> upper diagonals and
     <span class='var'>nl</span> lower diagonals.</li></ul>
<!--l. 1714--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-750004.5.2"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements.</span></span>
If it is supported by the compiler, the following functions are declared inline. To speed up these
functions, you can use the macro constant <span 
class="ec-lmtt-10x-x-109">PNL_RANGE_CHECK_OFF</span>, see Section&#x00A0;<a 
href="pnl-manualse1.html#x3-100001.3.2">1.3.2<!--tex4ht:ref: sec:inline --></a> for an
explanation. </p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-75001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i,j</span></sub> <span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-75002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_get</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i,j</span></sub>.
     </li>
     <li class="itemize"><a 
 id="dx6-75003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address <span 
class="rm-lmr-10x-x-109">&amp;(</span><span 
class="lmmi-10x-x-109">M</span><sub><span 
class="lmmi-8">i,j</span></sub><span 
class="rm-lmr-10x-x-109">)</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-75004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_set_all</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set all the elements of <span class='var'>M</span> to <span class='var'>x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-75005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_print_as_full</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a band matrix in a full format.</li></ul>
                                                                                    

                                                                                    
<!--l. 1740--><p class="noindent" ><span class="subparagraphHead"> <a 
 id="x6-760004.5.2"></a><span 
class="ec-lmbx-10x-x-109">Element wise operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-76001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place addition, <span class='var'>lhs += x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place substraction <span class='var'>lhs -= x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = lhs ./ x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = lhs * x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76005"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_plus_band_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>lhs,  const  <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place addition, <span class='var'>lhs += rhs</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_minus_band_mat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place substraction <span class='var'>lhs -= rhs</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_inv_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term inversion <span class='var'>lhs = 1 ./ rhs</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76008"></a>     <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_div_band_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a>     <span 
class="ts1-lmr10-x-x-109">*</span>lhs,     const
     <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term division <span class='var'>lhs = lhs ./ rhs</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76009"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_mult_band_mat_term</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>lhs,    const
     <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place term by term multiplication <span class='var'>lhs = lhs .* rhs</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76010"></a>    <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_map</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>lhs,    const    <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a>    <span 
class="ts1-lmr10-x-x-109">*</span>rhs,
     double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(rhs)</span>
     </li>
     <li class="itemize"><a 
 id="dx6-76011"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_map_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs)</span>
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-76012"></a>   <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_map_band_mat_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a>   <span 
class="ts1-lmr10-x-x-109">*</span>lhs,   const
     <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs, double(<span 
class="ts1-lmr10-x-x-109">*</span>f)(double,double)</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>lhs = f(lhs,rhs)</span></li></ul>
<!--l. 1791--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-770004.5.2"></a><span 
class="ec-lmbx-10x-x-109">Standard matrix operations &amp; Linear system</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-77001"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lAxpby</span></span>&#x00A0;(<span class='args'>double  lambda,  const  <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>A,  const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, double mu, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>b := lambda A x + mu b</span>. When <span class='var'>mu==0</span>, the content of <span class='var'>b</span> is
     not used on input and instead <span class='var'>b</span> is resized to match the size of <span class='var'>A*x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-77002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_mult_vect_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM,
     const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>y = BM * x</span>
     </li>
     <li class="itemize"><a 
 id="dx6-77003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_syslin_inplace</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with <span class='var'>M</span> a <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> . <span 
class="ec-lmbx-10x-x-109">Note </span>that M
     is modified on output and becomes unusable. On exit, the solution <span class='var'>x</span> is stored in <span class='var'>b</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-77004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x,<a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with <span class='var'>M</span> a <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> . <span 
class="ec-lmbx-10x-x-109">Note </span>that M
     is modified on output and becomes unusable.
     </li>
     <li class="itemize"><a 
 id="dx6-77005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lu</span></span>&#x00A0;(<span class='args'><a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>BM, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute  the  LU  decomposition  with  partial  pivoting  with  row
     interchanges. On exit, <span class='var'>BM</span> is enlarged to store the LU decomposition. On exit, <span class='var'>p</span> stores
     the permutation applied to the rows. Note that the Lapack format is used to store <span class='var'>p</span>,
     this format differs from the one used by <a 
href="#x6-610004.3.5"><span class='struct'>PnlPermutation</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-77006"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lu_syslin_inplace</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>p,
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the band linear system <span class='var'>M x = b</span> where <span class='var'>M</span> is the LU decomposition
     computed by <a 
href="#x6-770004.5.2">pnl_band_mat_lu</a> and <span class='var'>p</span> the associated permutation. On exit, the solution
     <span class='var'>x</span> is stored in <span class='var'>b</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-77007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_band_mat_lu_syslin</span></span>&#x00A0;(<span class='args'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-720004.5.1"><span class='struct'>PnlBandMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVectInt</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>p, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the band linear system <span class='var'>M x = b</span> where <span class='var'>M</span> is the LU decomposition
     computed by <a 
href="#x6-770004.5.2">pnl_band_mat_lu</a> and <span class='var'>p</span> the associated permutation.</li></ul>
                                                                                    

                                                                                    
<!--l. 1831--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.6   </span> <a 
 id="x6-780004.6"></a>Sparse Matrices</h4>
<!--l. 1832--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.6.1   </span> <a 
 id="x6-790004.6.1"></a>Short description</h5>
<!--l. 1833--><p class="noindent" >The structures and functions related to matrices are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_sp_matrix.h</span></span></span>.
<a 
 id="dx6-79001"></a>
<a 
 id="dx6-79002"></a>
<a 
 id="dx6-79003"></a>
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-28">
typedef&#x00A0;struct&#x00A0;_PnlSpMat
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;a&#x00A0;PnlSpMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;columns&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;nz;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;non-zero&#x00A0;elements&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*J;&#x00A0;/*!&#x003C;&#x00A0;column&#x00A0;indices,&#x00A0;vector&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*I;&#x00A0;/*!&#x003C;&#x00A0;row&#x00A0;offset&#x00A0;integer&#x00A0;vector,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;array[I[i]]&#x00A0;is&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;of&#x00A0;row&#x00A0;i.
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Vector&#x00A0;of&#x00A0;size&#x00A0;(m+1)&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;of&#x00A0;size&#x00A0;nzmax*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;nzmax;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlSpMat;
&#x00A0;<br />
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;_PnlSpMatInt
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;a&#x00A0;PnlSpMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;columns&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;nz;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;non-zero&#x00A0;elements&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*J;&#x00A0;/*!&#x003C;&#x00A0;column&#x00A0;indices,&#x00A0;vector&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*I;&#x00A0;/*!&#x003C;&#x00A0;row&#x00A0;offset&#x00A0;integer&#x00A0;vector,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;array[I[i]]&#x00A0;is&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;of&#x00A0;row&#x00A0;i.
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Vector&#x00A0;of&#x00A0;size&#x00A0;(m+1)&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;nzmax;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlSpMatInt;
&#x00A0;<br />
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;_PnlSpMatComplex
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;a&#x00A0;PnlSpMat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
                                                                                    

                                                                                    
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;m;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;rows&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;n;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;columns&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;nz;&#x00A0;/*!&#x003C;&#x00A0;number&#x00A0;of&#x00A0;non-zero&#x00A0;elements&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*J;&#x00A0;/*!&#x003C;&#x00A0;column&#x00A0;indices,&#x00A0;vector&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*I;&#x00A0;/*!&#x003C;&#x00A0;row&#x00A0;offset&#x00A0;integer&#x00A0;vector,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;array[I[i]]&#x00A0;is&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;of&#x00A0;row&#x00A0;i.
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Vector&#x00A0;of&#x00A0;size&#x00A0;(m+1)&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;dcomplex&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;data&#x00A0;of&#x00A0;size&#x00A0;nzmax&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;nzmax;&#x00A0;/*!&#x003C;&#x00A0;size&#x00A0;of&#x00A0;the&#x00A0;memory&#x00A0;block&#x00A0;allocated&#x00A0;for&#x00A0;array&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlSpMatComplex;
</div>
<!--l. 1891--><p class="nopar" >
</p><!--l. 1893--><p class="noindent" >The non zero elements of row <span class='var'>i</span> are stored in <span class='var'>array</span> between the indices <span class='var'>I[i]</span> and <span class='var'>I[i+1]-1</span>. The array <span class='var'>J</span>
contains the column indices of every element of <span class='var'>array</span>. <br 
class="newline" />
</p><!--l. 1898--><p class="noindent" >Sparse matrices are defined using the internal template approach and can be used for integer, float
or complex base data according to the following table </p>
<div class="center" 
>
<!--l. 1900--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-9" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-9-1g"><col 
id="TBL-9-1" /><col 
id="TBL-9-2" /><col 
id="TBL-9-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-9-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-1-1"  
class="td11">base type</td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-1-2"  
class="td11">prefix                      </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-1-3"  
class="td11">type                   </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-2-1"  
class="td11">double     </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-2-2"  
class="td11">pnl_sp_mat             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-2-3"  
class="td11">PnlSpMat            </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-3-1"  
class="td11">int          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-3-2"  
class="td11">pnl_sp_mat_int       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-3-3"  
class="td11">PnlSpMatInt        </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-4-1"  
class="td11">dcomplex </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-4-2"  
class="td11">pnl_sp_mat_complex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-4-3"  
class="td11">PnlSpMatComplex</td></tr></table></div></div>
<!--l. 1912--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.6.2   </span> <a 
 id="x6-800004.6.2"></a>Functions</h5>
<!--l. 1914--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-810004.6.2"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-81001"></a> <span class='ret'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty sparse matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-81002"></a> <span class='ret'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_create</span></span>&#x00A0;(<span class='args'>int m, int n, int nzmax</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a sparse matrix with size <span class='var'>m x n</span> designed to hold at most <span class='var'>nzmax</span>
     non zero elements.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-81003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>dest, const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone <span class='var'>src</span> into <span class='var'>dest</span>, which is automatically resized. On output, <span class='var'>dest</span> and
     <span class='var'>src</span> are equal but independent.
     </li>
     <li class="itemize"><a 
 id="dx6-81004"></a> <span class='ret'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_copy</span></span>&#x00A0;(<span class='args'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>src</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an independent copy of <span class='var'>src</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-81005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Delete a sparse matrix.
     </li>
     <li class="itemize"><a 
 id="dx6-81006"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int m, int n, int nzmax</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize an existing <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> to become a <span class='var'>m x n</span> sparse matrices holding
     at most <span class='var'>nzmax</span>. Note that no old data are kept except if <span class='var'>M-&#x003E;m</span> is left unchanged and
     we only call this function to increase <span class='var'>M-&#x003E;nzmax</span>. Return <span class='var'>OK</span> or <span class='var'>FAIL</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-81007"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_create_from_sp_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a dense <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> from a spare one.
     </li>
     <li class="itemize"><a 
 id="dx6-81008"></a> <span class='ret'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_create_from_mat</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a sparse matrix from a dense one.
     </li>
     <li class="itemize"><a 
 id="dx6-81009"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_create_from_file</span></span>&#x00A0;(<span class='args'>char *file</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Read a sparse matrix from the file with name <span class='var'>file</span>. We use the Matrix Market
     Exchange Format
                                                                                    

                                                                                    
     <div class="verbatim" id="verbatim-29">
     M&#x00A0;&#x00A0;N&#x00A0;&#x00A0;L&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x003C;---&#x00A0;rows,&#x00A0;columns,&#x00A0;entries
     &#x00A0;<br />I1&#x00A0;&#x00A0;J1&#x00A0;&#x00A0;A(I1,&#x00A0;J1)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x003C;--+
     &#x00A0;<br />I2&#x00A0;&#x00A0;J2&#x00A0;&#x00A0;A(I2,&#x00A0;J2)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x00A0;&#x00A0;&#x00A0;|
     &#x00A0;<br />I3&#x00A0;&#x00A0;J3&#x00A0;&#x00A0;A(I3,&#x00A0;J3)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x00A0;&#x00A0;&#x00A0;|--&#x00A0;L&#x00A0;lines
     &#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;.&#x00A0;.&#x00A0;.&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x00A0;&#x00A0;&#x00A0;|
     &#x00A0;<br />IL&#x00A0;JL&#x00A0;&#x00A0;A(IL,&#x00A0;JL)&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;|&#x00A0;&#x003C;--+
     &#x00A0;<br />&#x00A0;&#x00A0;
</div>
     <!--l. 1947--><p class="nopar" >The format <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">(I1,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;J1)</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;A(I1,</span><span 
class="ec-lmtt-10x-x-109">&#x00A0;J1)</span></span></span> is also accepted. Anything after a <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">#</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">%</span></span></span> is ignored up to the
     end of the line.</p></li></ul>
<!--l. 1951--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-820004.6.2"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-82001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set <span class='var'>M[i,j] = x</span>. This function increases <span class='var'>M-&#x003E;nzmax</span> if necessary.
     </li>
     <li class="itemize"><a 
 id="dx6-82002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, int i, int j</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return <span class='var'>M[i,j]</span>. If <span class='var'>M</span> has no entry with such an index, zero is returned.</li></ul>
<!--l. 1962--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-830004.6.2"></a><span 
class="ec-lmbx-10x-x-109">Applying external operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-83001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_plus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Add <span class='var'>x</span> to all non zero entries of <span class='var'>M</span>. To apply the operation to all entries
     including the zero ones, first convert <span class='var'>M</span> to a dense matrix and use <a 
href="#x6-520004.3.2">pnl_mat_plus_scalar</a>.
     </li>
     <li class="itemize"><a 
 id="dx6-83002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_minus_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Substract  <span class='var'>x</span>  to  all  non  zero  entries  of  <span class='var'>M</span>.  To  apply  the  operation
     to  all  entries  including  the  zero  ones,  first  convert  <span class='var'>M</span>  to  a  dense  matrix  and  use
     <a 
href="#x6-520004.3.2">pnl_mat_minus_scalar</a>.
     </li>
     <li class="itemize"><a 
 id="dx6-83003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar multiplication
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-83004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_div_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>In-place matrix scalar division</li></ul>
<!--l. 1980--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-840004.6.2"></a><span 
class="ec-lmbx-10x-x-109">Standard matrix operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-84001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_fprint</span></span>&#x00A0;(<span class='args'>FILE <span 
class="ts1-lmr10-x-x-109">*</span>fic, const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print a sparse matrix to a file descriptor using the format <span class='var'>(row, col) &#8211;&#x003E;
     val</span>. The file can be read by <a 
href="#x6-810004.6.2">pnl_sp_mat_create_from_file</a>.
     </li>
     <li class="itemize"><a 
 id="dx6-84002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Same as <a 
href="#x6-840004.6.2">pnl_sp_mat_fprint</a> but print to standard output.
     </li>
     <li class="itemize"><a 
 id="dx6-84003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_mult_vect</span></span>&#x00A0;(<span class='args'>(</span>)<a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span><span class='var'>y = A x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-84004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_lAxpby</span></span>&#x00A0;(<span class='args'>double lambda, const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>A, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x,
     double b, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>y := lambda A x + b y</span>. When <span class='var'>b=0</span>, the content of <span class='var'>y</span> is not
     used on input and instead <span class='var'>y</span> is resized to match <span class='var'>A*x</span>. The vectors <span class='var'>x</span> and <span class='var'>y</span> must be
     different.</li></ul>
<!--l. 1999--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-850004.6.2"></a><span 
class="ec-lmbx-10x-x-109">Comparison functions</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-85001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_isequal</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, double abserr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two sparse matrices are equal up to <span class='var'>err</span> component&#8211;wise. The
     error <span class='var'>err</span> is either relative or absolute depending on the magnitude of the components.
     Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-85002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_isequal_abs</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, double
     relerr</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test if two sparse matrices are equal up to an absolute error <span class='var'>abserr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-85003"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_sp_mat_isequal_rel</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-790004.6.1"><span class='struct'>PnlSpMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>y, double err</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Test  if  two  sparse  matrices  are  equal  up  to  a  relative  error  <span class='var'>relerr</span>
     component&#8211;wise. Return <span class='var'>TRUE</span> or <span class='var'>FALSE</span>.</li></ul>
<!--l. 2011--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.7   </span> <a 
 id="x6-860004.7"></a>Hyper Matrices</h4>
<!--l. 2012--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.7.1   </span> <a 
 id="x6-870004.7.1"></a>Short description</h5>
<!--l. 2014--><p class="noindent" >The Hyper matrix types and related functions are defined in the header <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_matrix.h</span></span></span>.
<a 
 id="dx6-87001"></a>
<a 
 id="dx6-87002"></a>
<a 
 id="dx6-87003"></a>
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-30">
typedef&#x00A0;struct&#x00A0;PnlHmat{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlHmat&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;ndim;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;dimensions&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*dims;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;values&#x00A0;of&#x00A0;the&#x00A0;ndim&#x00A0;dimensions&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;dim_1&#x00A0;*...*dim_ndim&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*pdims;&#x00A0;/*!&#x003C;&#x00A0;array&#x00A0;of&#x00A0;size&#x00A0;ndim,&#x00A0;s.t.&#x00A0;pdims[i]&#x00A0;=&#x00A0;dims[ndim-1]&#x00A0;x&#x00A0;...&#x00A0;dims[i+1]
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;with&#x00A0;pdims[ndim&#x00A0;-&#x00A0;1]&#x00A0;=&#x00A0;1&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlHmat;
&#x00A0;<br />
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;PnlHmatInt{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlHmatInt&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;ndim;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;dimensions&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*dims;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;value&#x00A0;of&#x00A0;the&#x00A0;ndim&#x00A0;dimensions&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;dim_1&#x00A0;*...*dim_ndim&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*pdims;&#x00A0;/*!&#x003C;&#x00A0;array&#x00A0;of&#x00A0;size&#x00A0;ndim,&#x00A0;s.t.&#x00A0;pdims[i]&#x00A0;=&#x00A0;dims[ndim-1]&#x00A0;x&#x00A0;...&#x00A0;dims[i+1]
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;with&#x00A0;pdims[ndim&#x00A0;-&#x00A0;1]&#x00A0;=&#x00A0;1&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlHmatInt;
&#x00A0;<br />
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;PnlHmatComplex{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlHmatComplex&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;ndim;&#x00A0;/*!&#x003C;&#x00A0;nb&#x00A0;dimensions&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*dims;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;the&#x00A0;value&#x00A0;of&#x00A0;the&#x00A0;ndim&#x00A0;dimensions&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;mn;&#x00A0;/*!&#x003C;&#x00A0;product&#x00A0;dim_1&#x00A0;*...*dim_ndim&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;*pdims;&#x00A0;/*!&#x003C;&#x00A0;array&#x00A0;of&#x00A0;size&#x00A0;ndim,&#x00A0;s.t.&#x00A0;pdims[i]&#x00A0;=&#x00A0;dims[ndim-1]&#x00A0;x&#x00A0;...&#x00A0;dims[i+1]
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;with&#x00A0;pdims[ndim&#x00A0;-&#x00A0;1]&#x00A0;=&#x00A0;1&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;dcomplex&#x00A0;*array;&#x00A0;/*!&#x003C;&#x00A0;pointer&#x00A0;to&#x00A0;store&#x00A0;*/
&#x00A0;<br />}&#x00A0;PnlHmatComplex;
</div>
                                                                                    

                                                                                    
<!--l. 2059--><p class="nopar" ><span class='var'>ndim</span> is the number of dimensions, <span class='var'>dim</span> is an array to store the size of each dimension and <span class='var'>nm</span>
contains the product of the sizes of each dimension. <span class='var'>array</span> is an array of size <span class='var'>mn</span> containing the data.
The integer array <span class='var'>pdims</span> is used to create the one&#8211;to&#8211;one map between the natural indexing and the
linear indexing used in <span class='var'>array</span>.
</p><!--l. 2067--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.7.2   </span> <a 
 id="x6-880004.7.2"></a>Functions</h5>
<!--l. 2068--><p class="noindent" >These functions exist for all types of hypermatrices no matter what the basic type is. The following
conventions are used to name functions operating on hypermatrices. Here is the table of prefixes
used for the different basic types.
</p>
<div class="center" 
>
<!--l. 2072--><p class="noindent" >
</p>
<div class="tabular"> <table id="TBL-10" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-10-1g"><col 
id="TBL-10-1" /><col 
id="TBL-10-2" /><col 
id="TBL-10-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-10-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-1-1"  
class="td11">base type</td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-1-2"  
class="td11">prefix                   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-1-3"  
class="td11">type                  </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-2-1"  
class="td11">double     </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-2-2"  
class="td11">pnl_hmat             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-2-3"  
class="td11">PnlHmat            </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-3-1"  
class="td11">int          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-3-2"  
class="td11">pnl_hmat_int       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-3-3"  
class="td11">PnlHmatInt        </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-10-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-10-4-1"  
class="td11">dcomplex </td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-4-2"  
class="td11">pnl_hmat_complex</td><td  style="white-space:nowrap; text-align:left;" id="TBL-10-4-3"  
class="td11">PnlHmatComplex</td></tr></table></div></div>
<!--l. 2084--><p class="noindent" >In this paragraph, we present the functions operating on <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> which exist for all types. To
deduce the prototypes of these functions for other basic types, one must replace <span 
class="ec-lmtt-10x-x-109">pnl_hmat </span>and
<span 
class="ec-lmtt-10x-x-109">double </span>according the above table.
</p>
<!--l. 2090--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-890004.7.2"></a><span 
class="ec-lmbx-10x-x-109">Constructors and destructors</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-89001"></a> <span class='ret'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-89002"></a> <span class='ret'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_create</span></span>&#x00A0;(<span class='args'>int ndim, const int <span 
class="ts1-lmr10-x-x-109">*</span>dims</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> with <span class='var'>ndim</span> dimensions and the size of each dimension
     is given by the entries of the integer array <span class='var'>dims</span>
     </li>
     <li class="itemize"><a 
 id="dx6-89003"></a> <span class='ret'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_create_from_scalar</span></span>&#x00A0;(<span class='args'>int ndim, const int <span 
class="ts1-lmr10-x-x-109">*</span>dims, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> with <span class='var'>ndim</span> dimensions given by <span 
class="lmex-10">&#x220F;</span>
  <sub><span 
class="lmmi-8">i</span></sub><span class='var'><span 
class="lmmi-10x-x-109">dims</span><span 
class="rm-lmr-10x-x-109">[</span><span 
class="lmmi-10x-x-109">i</span><span 
class="rm-lmr-10x-x-109">]</span></span> filled with
     <span class='var'>x</span>.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-89004"></a> <span class='ret'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_create_from_ptr</span></span>&#x00A0;(<span class='args'>int ndim, const int <span 
class="ts1-lmr10-x-x-109">*</span>dims, const double
     <span 
class="ts1-lmr10-x-x-109">*</span>x</span>)
     </li>
     <li class="itemize"><a 
 id="dx6-89005"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>H</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Free a <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a>
     </li>
     <li class="itemize"><a 
 id="dx6-89006"></a> <span class='ret'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_copy</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Copy a <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-89007"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_clone</span></span>&#x00A0;(<span class='args'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>clone, const <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Clone a <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> .
     </li>
     <li class="itemize"><a 
 id="dx6-89008"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_resize</span></span>&#x00A0;(<span class='args'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H, int ndim, const int <span 
class="ts1-lmr10-x-x-109">*</span>dims</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Resize a <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> .</li></ul>
<!--l. 2121--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-900004.7.2"></a><span 
class="ec-lmbx-10x-x-109">Accessing elements</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-90001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_set</span></span>&#x00A0;(<span class='args'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int <span 
class="ts1-lmr10-x-x-109">*</span>tab, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Set the element of index <span class='var'>tab</span> to <span class='var'>x</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-90002"></a> <span class='ret'>double</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_get</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int <span 
class="ts1-lmr10-x-x-109">*</span>tab</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the value of the element of index <span class='var'>tab</span>
     </li>
     <li class="itemize"><a 
 id="dx6-90003"></a> <span class='ret'>double<span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_lget</span></span>&#x00A0;(<span class='args'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>self, int <span 
class="ts1-lmr10-x-x-109">*</span>tab</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return the address of self[tab] for use as a lvalue.
     </li>
     <li class="itemize"><a 
 id="dx6-90004"></a> <span class='ret'><a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_wrap_hmat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H, int <span 
class="ts1-lmr10-x-x-109">*</span>t</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a true <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> not a pointer holding the data <span class='var'>H(t,:,:)</span>. Note that <span class='var'>t</span>
     must be of size <span class='var'>ndim-2</span> and that it cannot be checked within the function. The returned
     matrix shares its data with <span class='var'>H</span>, it is only a view not a true copy.
     </li>
     <li class="itemize"><a 
 id="dx6-90005"></a> <span class='ret'><a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> </span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_vect_wrap_hmat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H, int <span 
class="ts1-lmr10-x-x-109">*</span>t</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Return a true <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> not a pointer holding the data <span class='var'>H(t,:)</span>. Note that <span class='var'>t</span>
     must be of size <span class='var'>ndim-1</span> and that it cannot be checked within the function. The returned
     vector shares its data with <span class='var'>H</span>, it is only a view not a true copy.
     </li></ul>
                                                                                    

                                                                                    
<!--l. 2148--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-910004.7.2"></a><span 
class="ec-lmbx-10x-x-109">Printing hypermatrices</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-91001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_print</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>H</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Print an hypermatrix.</li></ul>
<!--l. 2155--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-920004.7.2"></a><span 
class="ec-lmbx-10x-x-109">Term by term operations</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-92001"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_plus_hmat</span></span>&#x00A0;(<span class='args'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, const <a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>rhs</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>lhs += rhs</span>.
     </li>
     <li class="itemize"><a 
 id="dx6-92002"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_hmat_mult_scalar</span></span>&#x00A0;(<span class='args'><a 
href="#x6-870004.7.1"><span class='struct'>PnlHmat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>lhs, double x</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Compute <span class='var'>lhs *= x</span> where x is a real number.</li></ul>
<!--l. 2381--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">4.8   </span> <a 
 id="x6-930004.8"></a>Iterative Solvers</h4>
<!--l. 2382--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.8.1   </span> <a 
 id="x6-940004.8.1"></a>Overview</h5>
<!--l. 2384--><p class="noindent" >The structures and functions related to solvers are declared in <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-10x-x-109">pnl/pnl_linalgsolver.h</span></span></span>.
<a 
 id="dx6-94001"></a>
<a 
 id="dx6-94002"></a>
<a 
 id="dx6-94003"></a>
<a 
 id="dx6-94004"></a>
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-31">
typedef&#x00A0;struct&#x00A0;_PnlIterationBase&#x00A0;PnlIterationBase;
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;_PnlCgSolver&#x00A0;PnlCgSolver;
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;_PnlBicgSolver&#x00A0;PnlBicgSolver;
&#x00A0;<br />typedef&#x00A0;struct&#x00A0;_PnlGmresSolver&#x00A0;PnlGmresSolver;
&#x00A0;<br />
&#x00A0;<br />struct&#x00A0;_PnlIterationBase
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlVectXXX&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;iteration;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;max_iter;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;normb;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;tol_;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;resid;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;error;
&#x00A0;<br />&#x00A0;&#x00A0;/*&#x00A0;char&#x00A0;*&#x00A0;&#x00A0;err_msg;&#x00A0;*/
&#x00A0;<br />};
&#x00A0;<br />
&#x00A0;<br />/*&#x00A0;When&#x00A0;you&#x00A0;repeatedly&#x00A0;use&#x00A0;iterative&#x00A0;solvers,&#x00A0;do&#x00A0;not&#x00A0;malloc&#x00A0;each&#x00A0;time&#x00A0;*/
&#x00A0;<br />struct&#x00A0;_PnlCgSolver
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlCgSolver&#x00A0;&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;z;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;p;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;q;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;rho;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;oldrho;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;beta;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;alpha;
&#x00A0;<br />&#x00A0;&#x00A0;PnlIterationBase&#x00A0;*&#x00A0;iter;
&#x00A0;<br />}&#x00A0;;
&#x00A0;<br />
&#x00A0;<br />struct&#x00A0;_PnlBicgSolver
&#x00A0;<br />{
                                                                                    

                                                                                    
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlBicgSolver&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;rho_1,&#x00A0;rho_2,&#x00A0;alpha,&#x00A0;beta,&#x00A0;omega;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;p;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;phat;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;s;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;shat;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;t;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;v;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;&#x00A0;rtilde;
&#x00A0;<br />&#x00A0;&#x00A0;PnlIterationBase&#x00A0;*&#x00A0;iter;
&#x00A0;<br />}&#x00A0;;
&#x00A0;<br />
&#x00A0;<br />struct&#x00A0;_PnlGmresSolver
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;/**
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;Must&#x00A0;be&#x00A0;the&#x00A0;first&#x00A0;element&#x00A0;in&#x00A0;order&#x00A0;for&#x00A0;the&#x00A0;object&#x00A0;mechanism&#x00A0;to&#x00A0;work
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*&#x00A0;properly.&#x00A0;This&#x00A0;allows&#x00A0;any&#x00A0;PnlGmresSolver&#x00A0;pointer&#x00A0;to&#x00A0;be&#x00A0;cast&#x00A0;to&#x00A0;a&#x00A0;PnlObject
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;PnlObject&#x00A0;object;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;restart;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;beta;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;s;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;cs;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;sn;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;w;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;r;
&#x00A0;<br />&#x00A0;&#x00A0;PnlMat&#x00A0;*&#x00A0;H;
&#x00A0;<br />&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;v[MAX_RESTART];
&#x00A0;<br />&#x00A0;&#x00A0;PnlIterationBase&#x00A0;*iter;
&#x00A0;<br />&#x00A0;&#x00A0;PnlIterationBase&#x00A0;*iter_inner;
&#x00A0;<br />}&#x00A0;;
</div>
<!--l. 2470--><p class="nopar" >
</p><!--l. 2472--><p class="noindent" >A Left preconditioner solves the problem :
</p>
<center class="math-display" >
<img 
src="pnl-manual16x.png" alt="PM x = P b,  " class="math-display"  /></center> and
whereas right preconditioner solves
<center class="math-display" >
<img 
src="pnl-manual17x.png" alt="M  Py = b,    P y = x.
" class="math-display"  /></center>
<!--l. 2485--><p class="noindent" >More information is given in <span 
class="ec-lmri-10x-x-109">Saad, Yousef (2003). Iterative methods for sparse linear systems (2nd</span>
<span 
class="ec-lmri-10x-x-109">ed. ed.). SIAM. ISBN 0898715342. OCLC 51266114</span>. The reader will find in this book
some discussion about right or/and left preconditioner and a description of the following
algorithms.
</p><!--l. 2490--><p class="noindent" >These algorithms, we implemented with a left preconditioner. Right preconditioner can be easily
computed changing matrix vector multiplication operator from <span 
class="lmmi-10x-x-109">M</span><span 
class="lmmi-10x-x-109">&#x00A0;x </span>to <span 
class="lmmi-10x-x-109">M</span><span 
class="lmmi-10x-x-109">&#x00A0;P</span><sub><span 
class="lmmi-8">R</span></sub><span 
class="lmmi-10x-x-109">&#x00A0;x </span>and solving
<span 
class="lmmi-10x-x-109">P</span><sub><span 
class="lmmi-8">R</span></sub><span 
class="lmmi-10x-x-109">y </span><span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">x </span>at the end of algorithm.
</p><!--l. 2495--><p class="noindent" >
</p>
<h5 class="subsubsectionHead"><span class="titlemark">4.8.2   </span> <a 
 id="x6-950004.8.2"></a>Functions</h5>
<!--l. 2497--><p class="noindent" >Three methods are implemented : Conjugate Gradient, BICGstab and GMRES with restart. For
each of them a structure is created to store temporary vectors used in the algorithm. In some cases,
we have to apply iterative methods more than once : for example to solve at each time step a
discrete form of an elliptic problem come from parabolic problem. In the cases, do not call the
constructor and destructor at each time, but instead use the initialization and solve
procedures.
</p><!--l. 2504--><p class="noindent" >Formally we have,
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-32">
Create&#x00A0;iterative&#x00A0;method
&#x00A0;<br />For&#x00A0;each&#x00A0;time&#x00A0;step
&#x00A0;<br />&#x00A0;&#x00A0;Initialisation&#x00A0;of&#x00A0;iterative&#x00A0;method
&#x00A0;<br />&#x00A0;&#x00A0;Solve&#x00A0;linear&#x00A0;system&#x00A0;link&#x00A0;to&#x00A0;elliptic&#x00A0;problem
&#x00A0;<br />end&#x00A0;for
&#x00A0;<br />free&#x00A0;iterative&#x00A0;method
</div>
<!--l. 2512--><p class="nopar" >
</p><!--l. 2514--><p class="noindent" >In these functions, we don&#8217;t use any particular matrix structure. We give the matrix vector
multiplication as a parameter of the solver.
</p>
<!--l. 2517--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-960004.8.2"></a><span 
class="ec-lmbx-10x-x-109">Conjugate Gradient method</span></span>
Only available for symmetric and positive matrices. </p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-96001"></a> <span class='ret'><a 
href="#x6-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x6-940004.8.1"><span class='struct'>PnlCgSolver</span></a>
     </li>
     <li class="itemize"><a 
 id="dx6-96002"></a> <span class='ret'><a 
href="#x6-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_create</span></span>&#x00A0;(<span class='args'>int Size, int max-iter, double tolerance</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-940004.8.1"><span class='struct'>PnlCgSolver</span></a> pointer.
     </li>
     <li class="itemize"><a 
 id="dx6-96003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_initialisation</span></span>&#x00A0;(<span class='args'><a 
href="#x6-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Initialisation of the solver at the beginning of iterative method.
     </li>
     <li class="itemize"><a 
 id="dx6-96004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Destructor of iterative solver
     </li>
     <li class="itemize"><a 
 id="dx6-96005"></a>   <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_cg_solver_solve</span></span>&#x00A0;(<span class='args'>void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix   vector-product)(const   void   <span 
class="ts1-lmr10-x-x-109">*</span>,   const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>,  const  double,  const  double,  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>),  const  void  <span 
class="ts1-lmr10-x-x-109">*</span>Matrix-Data,
     void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix vector-product-PC)(const void <span 
class="ts1-lmr10-x-x-109">*</span>, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, const double, const
     double, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>), const void <span 
class="ts1-lmr10-x-x-109">*</span>PC-Data, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x6-940004.8.1"><span class='struct'>PnlCgSolver</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  the  linear  system  matrix  vector-product  is  the  matrix  vector
     multiplication  function  matrix  vector-product-PC  is  the  preconditionner  function
     Matrix-Data &amp; PC-Data is data to compute matrix vector multiplication.</li></ul>
                                                                                    

                                                                                    
<!--l. 2532--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-970004.8.2"></a><span 
class="ec-lmbx-10x-x-109">BICG stab</span></span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-97001"></a> <span class='ret'><a 
href="#x6-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x6-940004.8.1"><span class='struct'>PnlBicgSolver</span></a>.
     </li>
     <li class="itemize"><a 
 id="dx6-97002"></a> <span class='ret'><a 
href="#x6-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_create</span></span>&#x00A0;(<span class='args'>int Size, int max-iter, double tolerance</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> pointer.
     </li>
     <li class="itemize"><a 
 id="dx6-97003"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_initialisation</span></span>&#x00A0;(<span class='args'><a 
href="#x6-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Initialisation of the solver at the beginning of iterative method.
     </li>
     <li class="itemize"><a 
 id="dx6-97004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Destructor of iterative solver
     </li>
     <li class="itemize"><a 
 id="dx6-97005"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_bicg_solver_solve</span></span>&#x00A0;(<span class='args'>void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix  vector-product)(const  void  <span 
class="ts1-lmr10-x-x-109">*</span>,  const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>,  const  double,  const  double,  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>),  const  void  <span 
class="ts1-lmr10-x-x-109">*</span>Matrix-Data,
     void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix vector-product-PC)(const void <span 
class="ts1-lmr10-x-x-109">*</span>, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, const double, const
     double, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>), const void <span 
class="ts1-lmr10-x-x-109">*</span>PC-Data, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x6-940004.8.1"><span class='struct'>PnlBicgSolver</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  the  linear  system  matrix  vector-product  is  the  matrix  vector
     multiplication  function  matrix  vector-product-PC  is  the  preconditioner  function
     Matrix-Data &amp; PC-Data is data to compute matrix vector multiplication.</li></ul>
<!--l. 2546--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-980004.8.2"></a><span 
class="ec-lmbx-10x-x-109">GMRES with restart</span></span>
See <span 
class="ec-lmri-10x-x-109">Saad, Yousef (2003) </span>for a discussion about the restart parameter. For GMRES we need to
store at the p-th iteration <span 
class="lmmi-10x-x-109">p </span>vectors of the same size of the right and side. It could be
very expensive in term of memory allocation. So GMRES with restart algorithm stop if
<span 
class="lmmi-10x-x-109">p </span><span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">restart </span>and restarts the algorithm with the previously computed solution as initial
guess.
</p><!--l. 2553--><p class="noindent" >Note that if restart equals <span 
class="lmmi-10x-x-109">m</span>, we have a classical GMRES algorithm.
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-98001"></a> <span class='ret'><a 
href="#x6-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_new</span></span>&#x00A0;(<span class='args'></span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create an empty <a 
href="#x6-940004.8.1"><span class='struct'>PnlGmresSolver</span></a>
     </li>
     <li class="itemize"><a 
 id="dx6-98002"></a> <span class='ret'><a 
href="#x6-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span></span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_create</span></span>&#x00A0;(<span class='args'>int Size, int max-iter, int restart,
     double tolerance</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Create a new <a 
href="#x6-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> pointer.
                                                                                    

                                                                                    
     </li>
     <li class="itemize"><a 
 id="dx6-98003"></a>  <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_initialisation</span></span>&#x00A0;(<span class='args'><a 
href="#x6-940004.8.1"><span class='struct'>PnlGmresSolver</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>Solver,  const  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>b</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Initialisation of the solver at the beginning of iterative method.
     </li>
     <li class="itemize"><a 
 id="dx6-98004"></a> <span class='ret'>void</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_free</span></span>&#x00A0;(<span class='args'><a 
href="#x6-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> <span 
class="ts1-lmr10-x-x-109">**</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Destructor of iterative solver
     </li>
     <li class="itemize"><a 
 id="dx6-98005"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_gmres_solver_solve</span></span>&#x00A0;(<span class='args'>void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix  vector-product)(const  void  <span 
class="ts1-lmr10-x-x-109">*</span>,  const
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>,  const  double,  const  double,  <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>),  const  void  <span 
class="ts1-lmr10-x-x-109">*</span>Matrix-Data,
     void(<span 
class="ts1-lmr10-x-x-109">*</span>matrix vector-product-PC)(const void <span 
class="ts1-lmr10-x-x-109">*</span>, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>, const double, const
     double, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>), const void <span 
class="ts1-lmr10-x-x-109">*</span>PC-Data, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x6-940004.8.1"><span class='struct'>PnlGmresSolver</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve  the  linear  system  matrix  vector-product  is  the  matrix  vector
     multiplication  function  matrix  vector-product-PC  is  the  preconditionner  function
     Matrix-Data &amp; PC-Data is data to compute matrix vector multiplication.</li></ul>
<!--l. 2569--><p class="noindent" >In the next paragraph, we write all the solvers for <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> . This will be done as follows: construct
an application matrix vector.
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-33">
static&#x00A0;void&#x00A0;pnl_mat_mult_vect_applied(const&#x00A0;void&#x00A0;*mat,&#x00A0;const&#x00A0;PnlVect&#x00A0;*vec,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;double&#x00A0;a&#x00A0;,&#x00A0;const&#x00A0;double&#x00A0;b,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVect&#x00A0;*lhs)
&#x00A0;<br />{pnl_mat_lAxpby(a,&#x00A0;(PnlMat*)mat,&#x00A0;vec,&#x00A0;b,&#x00A0;lhs);}
</div>
<!--l. 2576--><p class="nopar" >and give it as the parameter of the iterative method
                                                                                    

                                                                                    
</p>
<div class="verbatim" id="verbatim-34">
int&#x00A0;pnl_mat_cg_solver_solve(const&#x00A0;PnlMat&#x00A0;*&#x00A0;Matrix,&#x00A0;const&#x00A0;PnlMat&#x00A0;*&#x00A0;PC,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;PnlVect&#x00A0;*&#x00A0;x,&#x00A0;const&#x00A0;PnlVect&#x00A0;*b,&#x00A0;PnlCgSolver&#x00A0;*&#x00A0;Solver)
&#x00A0;<br />{&#x00A0;return&#x00A0;pnl_cg_solver_solve(pnl_mat_mult_vect_applied,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Matrix,&#x00A0;pnl_mat_mult_vect_applied,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;PC,&#x00A0;x,&#x00A0;b,&#x00A0;Solver);}
</div>
<!--l. 2584--><p class="nopar" >
</p><!--l. 2586--><p class="noindent" >In practice, we cannot define all iterative methods for all structures. With this implementation, the
user can easily : </p>
     <ul class="itemize1">
     <li class="itemize">implement right precondioner,
     </li>
     <li class="itemize">implement  method  with  sparse  matrix  and  diagonal  preconditioner,  or  special
     combination of this form <span 
class="lmmi-10x-x-109">&#x2026;</span><span style="margin-left:0.3em" class="thinspace"></span></li></ul>
<!--l. 2595--><p class="noindent" ><span class="paragraphHead"><a 
 id="x6-990004.8.2"></a><span 
class="ec-lmbx-10x-x-109">Iterative algorithms for </span><a 
href="#x6-470004.3.1"><span class='struct'><span 
class="ec-lmbx-10x-x-109">PnlMat</span></span></a> </span>
</p>
     <ul class="itemize1">
     <li class="itemize"><a 
 id="dx6-99001"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_cg_solver_solve</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>PC, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x6-940004.8.1"><span class='struct'>PnlCgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with preconditionner PC.
     </li>
     <li class="itemize"><a 
 id="dx6-99002"></a> <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_bicg_solver_solve</span></span>&#x00A0;(<span class='args'>const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>M, const <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>PC, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a>
     <span 
class="ts1-lmr10-x-x-109">*</span>x, const <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x6-940004.8.1"><span class='struct'>PnlBicgSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with preconditionner PC.
     </li>
     <li class="itemize"><a 
 id="dx6-99003"></a>  <span class='ret'>int</span>&#x00A0;<span class='fun'><span 
class="ec-lmbx-10x-x-109">pnl_mat_gmres_solver_solve</span></span>&#x00A0;(<span class='args'>const  <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>M,  const  <a 
href="#x6-470004.3.1"><span class='struct'>PnlMat</span></a>  <span 
class="ts1-lmr10-x-x-109">*</span>PC,
     <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>x, <a 
href="#x6-290004.1.1"><span class='struct'>PnlVect</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>b, <a 
href="#x6-940004.8.1"><span class='struct'>PnlGmresSolver</span></a> <span 
class="ts1-lmr10-x-x-109">*</span>Solver</span>)<br 
class="newline" />   <span class='description'>Description&#x00A0;</span>Solve the linear system <span class='var'>M x = b</span> with preconditionner PC.</li></ul>
                                                                                    

                                                                                    
<!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="pnl-manualse5.html" >next</a>] [<a 
href="pnl-manualse3.html" >prev</a>] [<a 
href="pnl-manualse3.html#tailpnl-manualse3.html" >prev-tail</a>] [<a 
href="pnl-manualse4.html" >front</a>] [<a 
href="pnl-manual.html#pnl-manualse4.html" >up</a>] </p></div>
<!--l. 1--><p class="noindent" ><a 
 id="tailpnl-manualse4.html"></a>   </p> 
</body></html> 
